00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 1:36:01 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 000022B8        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 0844                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 00001186             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048  6E00 000E                 42      BGT letsgo
0000104C  B67C 0004                 43      CMP #4,D3 
00001050  6700 0006                 44      BEQ letsgo
00001054  6F00 0002                 45      BLE letsgo
00001058                            46     
00001058                            47  letsgo
00001058                            48      
00001058                            49  * calls-------------------------------------------------------
00001058  347C 100C                 50      MOVE.W #$100C, A2
0000105C  6100 0154                 51      BSR     OPCODE * test MOVE.B
00001060                            52  
00001060  347C 1010                 53      MOVE.W #$1010, A2
00001064  6100 014C                 54      BSR     OPCODE * test MOVEA.W
00001068                            55      
00001068  347C 1014                 56      MOVE.W #$1014, A2
0000106C  6100 0144                 57      BSR     OPCODE * test MOVEQ
00001070                            58     
00001070  347C 1016                 59      MOVE.W #$1016, A2
00001074  6100 013C                 60      BSR     OPCODE *test MOVEA.L
00001078                            61      
00001078  347C 1018                 62      MOVE.W #$1018, A2
0000107C  6100 0134                 63      BSR     OPCODE *test DATA
00001080                            64      
00001080                            65      
00001080  347C 101A                 66      MOVE.W #$101A, A2
00001084  6100 012C                 67      BSR     OPCODE *test SUB.L
00001088                            68      
00001088  347C 101C                 69      MOVE.W #$101C, A2
0000108C  6100 0124                 70      BSR     OPCODE *test BRA
00001090                            71      
00001090  347C 1020                 72      MOVE.W #$1020, A2
00001094  6100 011C                 73      BSR     OPCODE *test JSR
00001098                            74      
00001098                            75      
00001098  43F9 00002347             76      LEA empty,A1
0000109E  13FC 0001 000022B9        77      MOVE.B  #1,(OutputType)       
000010A6  6100 0E2E                 78      BSR    OUTPUT
000010AA                            79  
000010AA                            80      
000010AA  347C 1026                 81      MOVE.W #$1026, A2
000010AE  6100 0102                 82      BSR     OPCODE *test NOT
000010B2                            83      
000010B2  347C 1028                 84      MOVE.W #$1028, A2
000010B6  6100 00FA                 85      BSR     OPCODE *test LEA
000010BA                            86      
000010BA  347C 102A                 87      MOVE.W #$102A, A2
000010BE  6100 00F2                 88      BSR     OPCODE *test OR
000010C2                            89      
000010C2  43F9 00002347             90       LEA empty,A1
000010C8  13FC 0001 000022B9        91      MOVE.B  #1,(OutputType)       
000010D0  6100 0E04                 92      BSR    OUTPUT
000010D4                            93  
000010D4                            94      
000010D4  347C 1030                 95      MOVE.W #$1030, A2
000010D8  6100 00D8                 96      BSR     OPCODE *test MOVEM
000010DC                            97  
000010DC  347C 1034                 98      MOVE.W #$1034, A2
000010E0  6100 00D0                 99      BSR     OPCODE *test AND
000010E4                           100      
000010E4  347C 1036                101      MOVE.W #$1036, A2
000010E8  6100 00C8                102      BSR     OPCODE *test ADD
000010EC                           103      
000010EC  43F9 00002347            104      LEA empty,A1
000010F2  13FC 0001 000022B9       105      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0DDA                106      BSR    OUTPUT
000010FE                           107  
000010FE  347C 1038                108      MOVE.W #$1038, A2
00001102  6100 00AE                109      BSR     OPCODE *test ADDA
00001106                           110      
00001106  347C 103A                111      MOVE.W #$103A, A2
0000110A  6100 00A6                112      BSR     OPCODE *test ADDQ
0000110E                           113      
0000110E  347C 103C                114      MOVE.W #$103C, A2
00001112  6100 009E                115      BSR     OPCODE *test LSL
00001116                           116  
00001116  347C 103E                117      MOVE.W #$103E, A2
0000111A  6100 0096                118      BSR     OPCODE *test LSR
0000111E                           119      
0000111E  347C 1040                120      MOVE.W #$1040, A2
00001122  6100 008E                121      BSR     OPCODE *test ASL
00001126                           122      
00001126  43F9 00002347            123      LEA empty,A1
0000112C  13FC 0001 000022B9       124      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0DA0                125      BSR    OUTPUT
00001138                           126  
00001138                           127  
00001138  347C 1042                128      MOVE.W #$1042, A2
0000113C  6100 0074                129      BSR     OPCODE *test ASR
00001140                           130      
00001140                           131      
00001140  347C 1044                132      MOVE.W #$1044, A2
00001144  6100 006C                133      BSR     OPCODE *test ROL
00001148                           134  
00001148  347C 1046                135      MOVE.W #$1046, A2
0000114C  6100 0064                136      BSR     OPCODE *test ROR
00001150                           137      
00001150  43F9 00002347            138      LEA empty,A1
00001156  13FC 0001 000022B9       139      MOVE.B  #1,(OutputType) * new line  
0000115E  6100 0D76                140      BSR    OUTPUT
00001162                           141  
00001162  347C 1048                142      MOVE.W #$1048, A2
00001166  6100 004A                143      BSR     OPCODE *test BGT
0000116A                           144  
0000116A  347C 1050                145      MOVE.W #$1050, A2
0000116E  6100 0042                146      BSR     OPCODE *test BLE
00001172                           147      
00001172  347C 1054                148      MOVE.W #$1054, A2
00001176  6100 003A                149      BSR     OPCODE *test BEQ
0000117A                           150      
0000117A                           151  
0000117A                           152    
0000117A  347C 1186                153      MOVE.W #$1186, A2
0000117E  6100 0032                154      BSR     OPCODE *test RTS
00001182                           155  
00001182                           156  
00001182                           157  * calls---------------------------------------------------------    
00001182  6000 0004                158      BRA userInputRepeat
00001186                           159  there    
00001186  4E75                     160      RTS
00001188                           161  * end testing--------------------------------------------------------------
00001188                           162   
00001188                           163  
00001188                           164       
00001188                           165    
00001188                           166  
00001188                           167      
00001188                           168  userInputRepeat
00001188  43F9 00002244            169      LEA     INPUTREPEAT,A1
0000118E  103C 000E                170      MOVE.B  #14,D0
00001192  4E4F                     171      TRAP    #15
00001194  5239 000022B8            172      ADD.B   #1,(LineCounter)
0000119A                           173      
0000119A  43F9 00008008            174      LEA     userInputStored,A1
000011A0  103C 0005                175      MOVE.B  #5,D0
000011A4  4E4F                     176      TRAP    #15
000011A6                           177      
000011A6  0C11 0000                178      CMP.B   #$00,(A1)
000011AA  6700 FE5C                179      BEQ     userInputStart
000011AE                           180   
000011AE  FFFF FFFF                181      SIMHALT
000011B2                           182  
000011B2                           183  **********************************************************
000011B2                           184  *Subroutine: OPCODE
000011B2                           185  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B2                           186  *Registers: 
000011B2                           187  *A1: printing
000011B2                           188  *A2: parameter with instruction address
000011B2                           189  *D0: printing
000011B2                           190  *D3: used for determing the instruction, mostly shifts
000011B2                           191  *D2: used for determing the size
000011B2                           192  *Paramemeters: A2 the memory address to decode from
000011B2                           193  **********************************************************
000011B2                           194  OPCODE:
000011B2  4243                     195      CLR D3
000011B4                           196      
000011B4  0C52 4E75                197      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011B8  6700 0324                198      BEQ rts
000011BC                           199      
000011BC  0C52 4E71                200      CMP #$4E71, (A2) *NOP compare
000011C0  6700 0132                201      BEQ nop
000011C4                           202      
000011C4  3612                     203      Move.W (A2), D3 
000011C6  E04B                     204      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011C8  E84B                     205      LSR #4,D3
000011CA                           206      
000011CA                           207      
000011CA  B67C 0008                208      CMP #%1000, D3 * OR compare
000011CE  6700 0526                209      BEQ or
000011D2                           210      
000011D2                           211      
000011D2  B67C 0003                212      CMP #%0011, D3 *MOVE and MOVEA compare
000011D6  6F00 013C                213      BLE move
000011DA                           214      
000011DA  B67C 0007                215      CMP #%0111, D3 *MOVEQ compare
000011DE  6700 01B2                216      BEQ moveq
000011E2                           217      
000011E2  B67C 0009                218      CMP #%1001, D3 *SUB compare
000011E6  6700 0202                219      BEQ sub
000011EA                           220      
000011EA  B67C 000C                221      CMP #%1100, D3 *AND compare
000011EE  6700 0544                222      BEQ and
000011F2                           223      
000011F2  B67C 0005                224      CMP #%0101, D3 *ADDQ compare
000011F6  6700 0230                225      BEQ addq
000011FA                           226      
000011FA  B67C 0006                227      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
000011FE  6700 0572                228      BEQ bcc
00001202                           229      
00001202                           230  
00001202  3612                     231      Move.W (A2), D3 * reset D3
00001204  0243 F118                232      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
00001208  B67C E108                233      CMP #%1110000100001000,D3 * LSL compare
0000120C  6700 0352                234      BEQ lsl
00001210                           235  
00001210  3612                     236      Move.W (A2), D3 * reset D3
00001212  0243 F118                237      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
00001216  B67C E008                238      CMP #%1110000000001000,D3 * LSR compare
0000121A  6700 0382                239      BEQ lsr
0000121E                           240      
0000121E                           241      
0000121E  3612                     242      Move.W (A2), D3 * reset D3
00001220  0243 F118                243      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001224  B67C E100                244      CMP #%1110000100000000,D3 * ASL compare
00001228  6700 03B2                245      BEQ asl
0000122C                           246  
0000122C  3612                     247      Move.W (A2), D3 * reset D3
0000122E  0243 F118                248      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001232  B67C E000                249      CMP #%1110000000000000,D3 * ASR compare
00001236  6700 03E2                250      BEQ asr
0000123A                           251  
0000123A  3612                     252      Move.W (A2), D3 * reset D3
0000123C  0243 F118                253      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001240  B67C E118                254      CMP #%1110000100011000,D3 * ROL compare
00001244  6700 0412                255      BEQ rol
00001248                           256  
00001248  3612                     257      Move.W (A2), D3 * reset D3
0000124A  0243 F118                258      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000124E  B67C E018                259      CMP #%1110000000011000,D3 * ROR compare
00001252  6700 0442                260      BEQ ror
00001256                           261  
00001256                           262      
00001256                           263      
00001256  3612                     264      Move.W (A2), D3 * reset D3
00001258  0243 F0C0                265      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000125C  B67C D0C0                266      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001260  6700 0242                267      BEQ adda
00001264                           268      
00001264  3612                     269      Move.W (A2), D3 
00001266  E04B                     270      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001268  E84B                     271      LSR #4,D3
0000126A  B67C 000D                272      CMP #%1101, D3 *ADD compare
0000126E  6700 01F6                273      BEQ add
00001272                           274  
00001272                           275    
00001272  3612                     276      Move.W (A2), D3 * reset D3
00001274  0243 FB80                277      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001278  B67C 4880                278      CMP #%0100100010000000,D3 * MOVEM compare
0000127C  6700 0136                279      BEQ movem
00001280                           280  
00001280                           281      
00001280                           282      
00001280  3612                     283      Move.W (A2), D3 * reset D3
00001282  EC4B                     284      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001284  B67C 013A                285      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001288  6700 0276                286      BEQ jsr
0000128C                           287  
0000128C  3612                     288      Move.W (A2), D3 * reset D3
0000128E  E04B                     289      LSR #8,D3 * make D3 only contain the first 8 bits
00001290  B67C 0046                290      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001294  6700 028C                291      BEQ not
00001298                           292      
00001298  3612                     293      Move.W (A2), D3 * reset D3
0000129A  0243 F1C0                294      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000129E  B67C 41C0                295      CMP #%0100000111000000,D3 *LEA compare
000012A2  6700 0430                296      BEQ lea
000012A6                           297      
000012A6                           298      
000012A6                           299      
000012A6                           300      
000012A6                           301      
000012A6                           302  
000012A6                           303  
000012A6                           304     
000012A6  3612                     305      Move.W (A2), D3 * reset D3
000012A8  E04B                     306      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012AA  B67C 0060                307      CMP #%01100000, D3 *BRA compare
000012AE  6700 054E                308      BEQ bra
000012B2                           309      
000012B2                           310      
000012B2  6000 056C                311      BRA data
000012B6                           312      
000012B6                           313  return
000012B6  4E75                     314      RTS
000012B8                           315  byte
000012B8  43F9 00002332            316      LEA    byteout,A1        
000012BE  13FC 0002 000022B9       317      MOVE.B  #2,(OutputType)
000012C6  6100 0C0E                318      BSR     OUTPUT 
000012CA  60EA                     319      BRA return
000012CC                           320  word
000012CC  43F9 00002339            321      LEA    wordout,A1        
000012D2  13FC 0002 000022B9       322      MOVE.B  #2,(OutputType)
000012DA  6100 0BFA                323      BSR     OUTPUT
000012DE  60D6                     324      BRA return
000012E0                           325  long
000012E0  43F9 00002340            326      LEA    longout,A1        
000012E6  13FC 0002 000022B9       327      MOVE.B  #2,(OutputType)
000012EE  6100 0BE6                328      BSR     OUTPUT 
000012F2  60C2                     329      BRA return
000012F4                           330      
000012F4                           331  nop 
000012F4  13FC 0004 000022B9       332      MOVE.B  #4,(OutputType)
000012FC  6100 0BD8                333      BSR     OUTPUT
00001300  43F9 000022BA            334      LEA    nopout,A1        
00001306  13FC 0001 000022B9       335      MOVE.B  #1,(OutputType)
0000130E  6100 0BC6                336      BSR     OUTPUT
00001312  60A2                     337      BRA return
00001314                           338      
00001314                           339  move
00001314                           340      * put the size of the instruction into D2 to use later
00001314                           341      * since the first two bits of D3 are 00 for move moving the entire word works
00001314  3403                     342      Move.W D3, D2
00001316                           343  
00001316                           344  
00001316                           345      * determine if MOVE or MOVEA
00001316                           346      * if bits 8,7,6 = 001 its MOVEA
00001316  3612                     347      MOVE.W (A2),D3
00001318  0243 01C0                348      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
0000131C                           349      
0000131C  B67C 0040                350      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001320  6700 003A                351      BEQ movea
00001324                           352      
00001324  13FC 0004 000022B9       353      MOVE.B  #4,(OutputType)
0000132C  6100 0BA8                354      BSR     OUTPUT
00001330                           355  
00001330  43F9 000022C0            356      LEA    moveout,A1     *print the type
00001336  13FC 0001 000022B9       357      MOVE.B  #1,(OutputType)   
0000133E  6100 0B96                358      BSR    OUTPUT
00001342                           359      
00001342                           360      *now to print size  
00001342  B47C 0002                361      cmp #2,D2 *if the size is 2 branch to long
00001346  6798                     362      BEQ long
00001348  B47C 0003                363      cmp #3,D2 *if the size is 3 branch to word
0000134C  6700 FF7E                364      BEQ word
00001350  6100 FF66                365      BSR byte *otherwise branch to byte
00001354                           366    
00001354  6100 0660                367      BSR MOVE_MOVEA_EA
00001358                           368      
00001358  6000 FF5C                369      BRA return
0000135C                           370      
0000135C                           371      
0000135C                           372  movea
0000135C  13FC 0004 000022B9       373      MOVE.B  #4,(OutputType)
00001364  6100 0B70                374      BSR     OUTPUT
00001368                           375  
00001368  43F9 000022C5            376      LEA    moveaout,A1
0000136E  13FC 0001 000022B9       377      MOVE.B  #1,(OutputType)       
00001376  6100 0B5E                378      BSR    OUTPUT
0000137A                           379      
0000137A                           380      *now to print size  
0000137A  B47C 0002                381      cmp #2,D2 *if the size is 2 branch to long
0000137E  6700 FF60                382      BEQ long
00001382  B47C 0003                383      cmp #3,D2 *if the size is 3 branch to word
00001386  6100 FF44                384      BSR word
0000138A                           385      
0000138A  6100 062A                386      BSR MOVE_MOVEA_EA
0000138E                           387      
0000138E  6000 FF26                388      BRA return
00001392                           389      
00001392                           390  moveq
00001392  13FC 0004 000022B9       391      MOVE.B  #4,(OutputType)
0000139A  6100 0B3A                392      BSR     OUTPUT
0000139E                           393  
0000139E  43F9 000022CB            394      LEA    moveqout,A1
000013A4  13FC 0001 000022B9       395      MOVE.B  #1,(OutputType)       
000013AC  6100 0B28                396      BSR    OUTPUT
000013B0  6000 FF04                397      BRA return
000013B4                           398  
000013B4                           399      
000013B4                           400  movem
000013B4  13FC 0004 000022B9       401      MOVE.B  #4,(OutputType)
000013BC  6100 0B18                402      BSR     OUTPUT
000013C0                           403      
000013C0  43F9 000022D1            404      LEA    movemout,A1
000013C6  13FC 0001 000022B9       405      MOVE.B  #1,(OutputType)       
000013CE  6100 0B06                406      BSR    OUTPUT
000013D2                           407      
000013D2  3412                     408      MOVE.W (A2),D2
000013D4  0242 0040                409      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013D8  EC4A                     410      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013DA  B47C 0001                411      CMP #1, D2 * if the size is 1 branch to long
000013DE  6700 FF00                412      BEQ long
000013E2  6100 FEE8                413      BSR word * otherwise branch to word
000013E6                           414  
000013E6                           415      
000013E6  6000 FECE                416      BRA return
000013EA                           417  sub 
000013EA  13FC 0004 000022B9       418      MOVE.B  #4,(OutputType)
000013F2  6100 0AE2                419      BSR     OUTPUT
000013F6                           420     
000013F6  43F9 000022D7            421      LEA    subout,A1
000013FC  13FC 0001 000022B9       422      MOVE.B  #1,(OutputType)       
00001404  6100 0AD0                423      BSR    OUTPUT
00001408                           424      
00001408  3412                     425      MOVE.W (A2),D2
0000140A  0242 00C0                426      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000140E  EC4A                     427      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001410                           428  
00001410                           429  
00001410                           430      
00001410                           431      *now to print size  
00001410  B47C 0002                432      cmp #2,D2 *if the size is 2 branch to long
00001414  6700 FECA                433      BEQ long
00001418  B47C 0001                434      cmp #1,D2 *if the size is 1 branch to word
0000141C  6700 FEAE                435      BEQ word
00001420  6100 FE96                436      BSR byte *otherwise branch to byte
00001424                           437      
00001424  6000 FE90                438      BRA return
00001428                           439      
00001428                           440  addq 
00001428  13FC 0004 000022B9       441      MOVE.B  #4,(OutputType)
00001430  6100 0AA4                442      BSR     OUTPUT
00001434                           443     
00001434  43F9 000022E4            444      LEA    addqout,A1
0000143A  13FC 0001 000022B9       445      MOVE.B  #1,(OutputType)       
00001442  6100 0A92                446      BSR    OUTPUT
00001446                           447      
00001446  3412                     448      MOVE.W (A2),D2
00001448  0242 00C0                449      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000144C  EC4A                     450      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000144E                           451  
0000144E                           452  
0000144E                           453      
0000144E                           454      *now to print size  
0000144E  B47C 0002                455      cmp #2,D2 *if the size is 2 branch to long
00001452  6700 FE8C                456      BEQ long
00001456  B47C 0001                457      cmp #1,D2 *if the size is 1 branch to word
0000145A  6700 FE70                458      BEQ word
0000145E  6100 FE58                459      BSR byte *otherwise branch to byte
00001462                           460      
00001462  6000 FE52                461      BRA return    
00001466                           462      
00001466                           463      
00001466                           464  add
00001466  13FC 0004 000022B9       465      MOVE.B  #4,(OutputType)
0000146E  6100 0A66                466      BSR     OUTPUT
00001472                           467  
00001472  43F9 000022DB            468      LEA    addout,A1
00001478  13FC 0001 000022B9       469      MOVE.B  #1,(OutputType)       
00001480  6100 0A54                470      BSR    OUTPUT
00001484                           471      
00001484  3412                     472      MOVE.W (A2),D2
00001486  0242 00C0                473      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000148A  EC4A                     474      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000148C                           475  
0000148C                           476  
0000148C                           477      
0000148C                           478      *now to print size  
0000148C  B47C 0002                479      cmp #2,D2 *if the size is 2 branch to long
00001490  6700 FE4E                480      BEQ long
00001494  B47C 0001                481      cmp #1,D2 *if the size is 1 branch to word
00001498  6700 FE32                482      BEQ word
0000149C  6100 FE1A                483      BSR byte *otherwise branch to byte
000014A0                           484      
000014A0  6000 FE14                485      BRA return
000014A4                           486  
000014A4                           487  adda
000014A4                           488  
000014A4  13FC 0004 000022B9       489      MOVE.B  #4,(OutputType)
000014AC  6100 0A28                490      BSR     OUTPUT
000014B0                           491  
000014B0  43F9 000022DF            492      LEA    addaout,A1
000014B6  13FC 0001 000022B9       493      MOVE.B  #1,(OutputType)       
000014BE  6100 0A16                494      BSR    OUTPUT
000014C2                           495      
000014C2  3412                     496      MOVE.W (A2),D2
000014C4  0242 0100                497      ANDI.W #%0000000100000000, D2 * set to only the size bit
000014C8  E04A                     498      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
000014CA                           499  
000014CA                           500  
000014CA                           501      
000014CA                           502      *now to print size  
000014CA  B47C 0001                503      cmp #1,D2 *if the size is 1 branch to long
000014CE  6700 FE10                504      BEQ long
000014D2  B47C 0000                505      cmp #0,D2 *if the size is 0 branch to word
000014D6  6700 FDF4                506      BEQ word
000014DA                           507         
000014DA  6000 FDDA                508      BRA return
000014DE                           509  
000014DE                           510      
000014DE                           511  rts
000014DE  13FC 0004 000022B9       512      MOVE.B  #4,(OutputType)
000014E6  6100 09EE                513      BSR     OUTPUT
000014EA                           514  
000014EA  43F9 00002320            515      LEA    rtsout,A1
000014F0  13FC 0001 000022B9       516      MOVE.B  #1,(OutputType)       
000014F8  6100 09DC                517      BSR    OUTPUT
000014FC  6000 FDB8                518      BRA return
00001500                           519      
00001500                           520      
00001500                           521  jsr 
00001500  13FC 0004 000022B9       522      MOVE.B  #4,(OutputType)
00001508  6100 09CC                523      BSR     OUTPUT
0000150C                           524     
0000150C  43F9 0000231C            525      LEA    jsrout,A1
00001512  13FC 0001 000022B9       526      MOVE.B  #1,(OutputType)       
0000151A  6100 09BA                527      BSR    OUTPUT
0000151E  6000 FD96                528      BRA return
00001522                           529      
00001522                           530      
00001522                           531  not 
00001522  13FC 0004 000022B9       532      MOVE.B  #4,(OutputType)
0000152A  6100 09AA                533      BSR     OUTPUT
0000152E                           534    
0000152E  43F9 000022ED            535      LEA    notout,A1
00001534  13FC 0001 000022B9       536      MOVE.B  #1,(OutputType)       
0000153C  6100 0998                537      BSR    OUTPUT
00001540                           538      
00001540  3412                     539      MOVE.W (A2),D2
00001542  0242 00C0                540      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001546  EC4A                     541      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001548                           542  
00001548                           543      *now to print size  
00001548  B47C 0002                544      cmp #2,D2 *if the size is 2 branch to long
0000154C  6700 FD92                545      BEQ long
00001550  B47C 0001                546      cmp #1,D2 *if the size is 1 branch to word
00001554  6700 FD76                547      BEQ word
00001558  6100 FD5E                548      BSR byte *otherwise branch to byte
0000155C                           549      
0000155C                           550  
0000155C                           551      
0000155C  6000 FD58                552      BRA return
00001560                           553  
00001560                           554  lsl
00001560  13FC 0004 000022B9       555      MOVE.B  #4,(OutputType)
00001568  6100 096C                556      BSR     OUTPUT
0000156C                           557  
0000156C  43F9 000022F8            558      LEA    lslout,A1
00001572  13FC 0001 000022B9       559      MOVE.B  #1,(OutputType)       
0000157A  6100 095A                560      BSR    OUTPUT
0000157E                           561      
0000157E  3412                     562      MOVE.W (A2),D2
00001580  0242 00C0                563      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001584  EC4A                     564      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001586                           565  
00001586                           566  
00001586                           567      
00001586                           568      *now to print size  
00001586  B47C 0002                569      cmp #2,D2 *if the size is 2 branch to long
0000158A  6700 FD54                570      BEQ long
0000158E  B47C 0001                571      cmp #1,D2 *if the size is 1 branch to word
00001592  6700 FD38                572      BEQ word
00001596  6100 FD20                573      BSR byte *otherwise branch to byte
0000159A                           574      
0000159A  6000 FD1A                575      BRA return
0000159E                           576  
0000159E                           577  lsr
0000159E  13FC 0004 000022B9       578      MOVE.B  #4,(OutputType)
000015A6  6100 092E                579      BSR     OUTPUT
000015AA                           580  
000015AA  43F9 000022FC            581      LEA    lsrout,A1
000015B0  13FC 0001 000022B9       582      MOVE.B  #1,(OutputType)       
000015B8  6100 091C                583      BSR    OUTPUT
000015BC                           584      
000015BC  3412                     585      MOVE.W (A2),D2
000015BE  0242 00C0                586      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015C2  EC4A                     587      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015C4                           588  
000015C4                           589  
000015C4                           590      
000015C4                           591      *now to print size  
000015C4  B47C 0002                592      cmp #2,D2 *if the size is 2 branch to long
000015C8  6700 FD16                593      BEQ long
000015CC  B47C 0001                594      cmp #1,D2 *if the size is 1 branch to word
000015D0  6700 FCFA                595      BEQ word
000015D4  6100 FCE2                596      BSR byte *otherwise branch to byte
000015D8                           597      
000015D8  6000 FCDC                598      BRA return
000015DC                           599  asl
000015DC  13FC 0004 000022B9       600      MOVE.B  #4,(OutputType)
000015E4  6100 08F0                601      BSR     OUTPUT
000015E8                           602  
000015E8  43F9 00002300            603      LEA    aslout,A1
000015EE  13FC 0001 000022B9       604      MOVE.B  #1,(OutputType)       
000015F6  6100 08DE                605      BSR    OUTPUT
000015FA                           606      
000015FA  3412                     607      MOVE.W (A2),D2
000015FC  0242 00C0                608      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001600  EC4A                     609      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001602                           610  
00001602                           611  
00001602                           612      
00001602                           613      *now to print size  
00001602  B47C 0002                614      cmp #2,D2 *if the size is 2 branch to long
00001606  6700 FCD8                615      BEQ long
0000160A  B47C 0001                616      cmp #1,D2 *if the size is 1 branch to word
0000160E  6700 FCBC                617      BEQ word
00001612  6100 FCA4                618      BSR byte *otherwise branch to byte
00001616                           619      
00001616  6000 FC9E                620      BRA return
0000161A                           621  
0000161A                           622  asr
0000161A  13FC 0004 000022B9       623      MOVE.B  #4,(OutputType)
00001622  6100 08B2                624      BSR     OUTPUT
00001626                           625  
00001626  43F9 00002304            626      LEA    asrout,A1
0000162C  13FC 0001 000022B9       627      MOVE.B  #1,(OutputType)       
00001634  6100 08A0                628      BSR    OUTPUT
00001638                           629      
00001638  3412                     630      MOVE.W (A2),D2
0000163A  0242 00C0                631      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000163E  EC4A                     632      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001640                           633  
00001640                           634  
00001640                           635      
00001640                           636      *now to print size  
00001640  B47C 0002                637      cmp #2,D2 *if the size is 2 branch to long
00001644  6700 FC9A                638      BEQ long
00001648  B47C 0001                639      cmp #1,D2 *if the size is 1 branch to word
0000164C  6700 FC7E                640      BEQ word
00001650  6100 FC66                641      BSR byte *otherwise branch to byte
00001654                           642      
00001654  6000 FC60                643      BRA return
00001658                           644      
00001658                           645  rol
00001658  13FC 0004 000022B9       646      MOVE.B  #4,(OutputType)
00001660  6100 0874                647      BSR     OUTPUT
00001664                           648  
00001664  43F9 00002308            649      LEA    rolout,A1
0000166A  13FC 0001 000022B9       650      MOVE.B  #1,(OutputType)       
00001672  6100 0862                651      BSR    OUTPUT
00001676                           652      
00001676  3412                     653      MOVE.W (A2),D2
00001678  0242 00C0                654      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000167C  EC4A                     655      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000167E                           656  
0000167E                           657  
0000167E                           658      
0000167E                           659      *now to print size  
0000167E  B47C 0002                660      cmp #2,D2 *if the size is 2 branch to long
00001682  6700 FC5C                661      BEQ long
00001686  B47C 0001                662      cmp #1,D2 *if the size is 1 branch to word
0000168A  6700 FC40                663      BEQ word
0000168E  6100 FC28                664      BSR byte *otherwise branch to byte
00001692                           665      
00001692  6000 FC22                666      BRA return
00001696                           667  
00001696                           668  ror
00001696  13FC 0004 000022B9       669      MOVE.B  #4,(OutputType)
0000169E  6100 0836                670      BSR     OUTPUT
000016A2                           671  
000016A2  43F9 0000230C            672      LEA    rorout,A1
000016A8  13FC 0001 000022B9       673      MOVE.B  #1,(OutputType)       
000016B0  6100 0824                674      BSR    OUTPUT
000016B4                           675      
000016B4  3412                     676      MOVE.W (A2),D2
000016B6  0242 00C0                677      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016BA  EC4A                     678      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016BC                           679  
000016BC                           680  
000016BC                           681      
000016BC                           682      *now to print size  
000016BC  B47C 0002                683      cmp #2,D2 *if the size is 2 branch to long
000016C0  6700 FC1E                684      BEQ long
000016C4  B47C 0001                685      cmp #1,D2 *if the size is 1 branch to word
000016C8  6700 FC02                686      BEQ word
000016CC  6100 FBEA                687      BSR byte *otherwise branch to byte
000016D0                           688      
000016D0  6000 FBE4                689      BRA return
000016D4                           690      
000016D4                           691      
000016D4                           692  
000016D4                           693  lea
000016D4  13FC 0004 000022B9       694      MOVE.B  #4,(OutputType)
000016DC  6100 07F8                695      BSR     OUTPUT
000016E0                           696  
000016E0  43F9 000022E9            697      LEA    leaout,A1
000016E6  13FC 0001 000022B9       698      MOVE.B  #1,(OutputType)       
000016EE  6100 07E6                699      BSR    OUTPUT
000016F2  6000 FBC2                700      BRA return
000016F6                           701      
000016F6                           702  or
000016F6  13FC 0004 000022B9       703      MOVE.B  #4,(OutputType)
000016FE  6100 07D6                704      BSR     OUTPUT
00001702                           705  
00001702  43F9 000022F1            706      LEA    orout,A1
00001708  13FC 0001 000022B9       707      MOVE.B  #1,(OutputType)       
00001710  6100 07C4                708      BSR    OUTPUT
00001714                           709      
00001714                           710          
00001714  3412                     711      MOVE.W (A2),D2
00001716  0242 00C0                712      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000171A  EC4A                     713      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000171C                           714  
0000171C                           715      *now to print size  
0000171C  B47C 0002                716      cmp #2,D2 *if the size is 2 branch to long
00001720  6700 FBBE                717      BEQ long
00001724  B47C 0001                718      cmp #1,D2 *if the size is 1 branch to word
00001728  6700 FBA2                719      BEQ word
0000172C  6100 FB8A                720      BSR byte *otherwise branch to byte
00001730                           721      
00001730  6000 FB84                722      BRA return
00001734                           723      
00001734                           724  and
00001734  13FC 0004 000022B9       725      MOVE.B  #4,(OutputType)
0000173C  6100 0798                726      BSR     OUTPUT
00001740                           727  
00001740  43F9 000022F4            728      LEA    andout,A1
00001746  13FC 0001 000022B9       729      MOVE.B  #1,(OutputType)       
0000174E  6100 0786                730      BSR    OUTPUT
00001752                           731      
00001752                           732          
00001752  3412                     733      MOVE.W (A2),D2
00001754  0242 00C0                734      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001758  EC4A                     735      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000175A                           736  
0000175A                           737      *now to print size  
0000175A  B47C 0002                738      cmp #2,D2 *if the size is 2 branch to long
0000175E  6700 FB80                739      BEQ long
00001762  B47C 0001                740      cmp #1,D2 *if the size is 1 branch to word
00001766  6700 FB64                741      BEQ word
0000176A  6100 FB4C                742      BSR byte *otherwise branch to byte
0000176E                           743      
0000176E  6000 FB46                744      BRA return    
00001772                           745  
00001772                           746  bcc
00001772  4243                     747      CLR D3
00001774  3612                     748      MOVE.W (A2), D3
00001776                           749      
00001776  0243 0F00                750      ANDI.W #%0000111100000000,D3 * bits [11-8]
0000177A  E04B                     751      LSR.W #8,D3
0000177C  B67C 000E                752      CMP #%1110, D3 * BGT compare
00001780  6700 0016                753      BEQ bgt
00001784  B67C 000F                754      CMP #%1111, D3 * BLE compare
00001788  6700 0030                755      BEQ ble
0000178C  B67C 0007                756      CMP #%0111, D3 * BEQ compare
00001790  6700 004A                757      BEQ beq
00001794  6000 008A                758      BRA data * goto data if doesn't work
00001798                           759  
00001798                           760  bgt
00001798  13FC 0004 000022B9       761      MOVE.B  #4,(OutputType)
000017A0  6100 0734                762      BSR     OUTPUT
000017A4                           763  
000017A4  43F9 00002310            764      LEA    bgtout,A1
000017AA  13FC 0001 000022B9       765      MOVE.B  #1,(OutputType)       
000017B2  6100 0722                766      BSR    OUTPUT
000017B6  6000 FAFE                767      BRA return
000017BA                           768  
000017BA                           769  ble
000017BA  13FC 0004 000022B9       770      MOVE.B  #4,(OutputType)
000017C2  6100 0712                771      BSR     OUTPUT
000017C6                           772  
000017C6  43F9 00002314            773      LEA    bleout,A1
000017CC  13FC 0001 000022B9       774      MOVE.B  #1,(OutputType)       
000017D4  6100 0700                775      BSR    OUTPUT
000017D8  6000 FADC                776      BRA return
000017DC                           777  beq
000017DC  13FC 0004 000022B9       778      MOVE.B  #4,(OutputType)
000017E4  6100 06F0                779      BSR     OUTPUT
000017E8                           780  
000017E8  43F9 00002318            781      LEA    beqout,A1
000017EE  13FC 0001 000022B9       782      MOVE.B  #1,(OutputType)       
000017F6  6100 06DE                783      BSR    OUTPUT
000017FA  6000 FABA                784      BRA return
000017FE                           785  
000017FE                           786  bra
000017FE  13FC 0004 000022B9       787      MOVE.B  #4,(OutputType)
00001806  6100 06CE                788      BSR     OUTPUT
0000180A                           789  
0000180A  43F9 00002326            790      LEA    braout,A1
00001810  13FC 0001 000022B9       791      MOVE.B  #1,(OutputType)       
00001818  6100 06BC                792      BSR    OUTPUT
0000181C  6000 FA98                793      BRA return
00001820                           794  
00001820                           795  data
00001820  13FC 0004 000022B9       796      MOVE.B  #4,(OutputType)
00001828  6100 06AC                797      BSR     OUTPUT
0000182C                           798  
0000182C  43F9 0000232A            799      LEA    dataout,A1
00001832  13FC 0001 000022B9       800      MOVE.B  #1,(OutputType)       
0000183A  6100 069A                801      BSR    OUTPUT
0000183E                           802      
0000183E  13FC 0003 000022B9       803      MOVE.B  #3,(OutputType)       
00001846  6100 068E                804      BSR    OUTPUT     
0000184A  6000 FA6A                805      BRA return
0000184E                           806  
0000184E                           807  
0000184E                           808  **********************************************************
0000184E                           809  *Subroutine: USERINPUT
0000184E                           810  *What it does: Takes in user input, rejects bad input
0000184E                           811  *Registers: Uses register A1, D0, D5
0000184E                           812  *A1: Stores messages and user input
0000184E                           813  *D0: Used for TRAP #15
0000184E                           814  *D5: Temporaraly stores user input to be masked then transfered
0000184E                           815  *Paramemeters: No parameters
0000184E                           816  **********************************************************
0000184E                           817  USERINPUT:
0000184E                           818  
0000184E                           819  welcomeExplanation
0000184E  43F9 0000202C            820      LEA     STARTMESSAGE,A1         
00001854  103C 000E                821      MOVE.B  #14,D0
00001858  4E4F                     822      TRAP    #15
0000185A                           823      
0000185A  5039 000022B8            824      ADD.B   #8,(LineCounter)
00001860                           825  
00001860                           826  firstInput
00001860  43F9 0000219E            827      LEA     INPUT1MESSAGE,A1        
00001866  103C 000E                828      MOVE.B  #14,D0                  
0000186A  4E4F                     829      TRAP    #15                     Asks user for first input
0000186C  5239 000022B8            830      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001872                           831      
00001872  43F9 00008008            832      LEA     userInputStored,A1
00001878  103C 0002                833      MOVE.B  #2,D0                   
0000187C  4E4F                     834      TRAP    #15                     User can input string for address
0000187E  5239 000022B8            835      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001884                           836  
00001884                           837      
00001884  6100 00BC                838      BSR     CONVERTATOH                 String converted to hex address
00001888                           839      
00001888  0C39 0000 000022B7       840      CMP.B   #0,(InputQuality)       Checks if bad input flag set
00001890  6700 0014                841      BEQ     throwInput1CharError
00001894                           842  
00001894                           843      
00001894  CABC 00FFFFFF            844      AND.L   #$00FFFFFF,D5
0000189A  23C5 00008000            845      MOVE.L  D5,input1               Moves result into input 1 memory location
000018A0  4285                     846      CLR.L   D5                      Clears D5 for future use
000018A2  6000 0020                847      BRA     secondInput
000018A6                           848      
000018A6                           849  throwInput1CharError
000018A6  43F9 000021EA            850      LEA     INPUTERRORBADCHAR,A1
000018AC  103C 000E                851      MOVE.B  #14,D0
000018B0  4E4F                     852      TRAP    #15                     Outputs bad character error message
000018B2  5639 000022B8            853      ADD.B   #3,(LineCounter)        Adds 2 to line counter
000018B8                           854      
000018B8  13FC 0001 000022B7       855      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
000018C0  4285                     856      CLR.L   D5                      Clears D5 for future use
000018C2                           857      
000018C2                           858      
000018C2                           859      
000018C2  609C                     860      BRA     firstInput              Tries again for input1
000018C4                           861  
000018C4                           862      
000018C4                           863  secondInput
000018C4  43F9 000021C4            864      LEA     INPUT2MESSAGE,A1        
000018CA  103C 000E                865      MOVE.B  #14,D0                  
000018CE  4E4F                     866      TRAP    #15                     Asks user for second input
000018D0  5239 000022B8            867      ADD.B   #1,(LineCounter)
000018D6                           868      
000018D6  43F9 00008008            869      LEA     userInputStored,A1
000018DC  103C 0002                870      MOVE.B  #2,D0                   
000018E0  4E4F                     871      TRAP    #15                     User can input string for address
000018E2  5239 000022B8            872      ADD.B   #1,(LineCounter)
000018E8                           873  
000018E8                           874      
000018E8  6100 0058                875      BSR     CONVERTATOH                 String converted to hex address
000018EC                           876  
000018EC  0C39 0000 000022B7       877      CMP.B   #0,(InputQuality)       
000018F4  6700 001C                878      BEQ     throwInput2CharError    Checks if bad input flag set
000018F8                           879      
000018F8  CABC 00FFFFFF            880      AND.L   #$00FFFFFF,D5
000018FE  BAB9 00008000            881      CMP.L   (input1),D5
00001904  6D00 0028                882      BLT     throwInput2LowerError
00001908                           883      
00001908                           884      
00001908                           885      
00001908  23C5 00008004            886      MOVE.L  D5,input2               Moves result into input 2 memory location
0000190E  4285                     887      CLR.L   D5                      Clears D5 for future use
00001910  4E75                     888      RTS    
00001912                           889      
00001912                           890  throwInput2CharError
00001912  43F9 000021EA            891      LEA     INPUTERRORBADCHAR,A1    
00001918  103C 000E                892      MOVE.B  #14,D0
0000191C  4E4F                     893      TRAP    #15                     Outputs bad character error message
0000191E                           894      
0000191E  5639 000022B7            895      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
00001924  4285                     896      CLR.L   D5                      Clears D5 for future use
00001926                           897      
00001926  5639 000022B8            898      ADD.B   #3,(LineCounter)
0000192C                           899      
0000192C  6096                     900      BRA     secondInput             Tries again for input2
0000192E                           901      
0000192E                           902  throwInput2LowerError
0000192E  43F9 00002208            903      LEA     INPUTERROR2SMALLER,A1
00001934  103C 000E                904      MOVE.B  #14,D0
00001938  4E4F                     905      TRAP    #15
0000193A                           906      
0000193A  5639 000022B8            907      ADD.B   #3,(LineCounter)
00001940                           908      
00001940  6082                     909      BRA     secondInput
00001942                           910  
00001942                           911  
00001942                           912  **********************************************************
00001942                           913  *Subroutine: CONVERTATOH
00001942                           914  *What it does: Converts user input to hex code
00001942                           915  *Registers: Uses register A1, D2, D5
00001942                           916  *Paramemeters: User input stored in (A1)
00001942                           917  ********************************************************** 
00001942                           918  CONVERTATOH:
00001942                           919      
00001942                           920  AtoH
00001942  1419                     921      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
00001944                           922      
00001944  B43C 0000                923      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
00001948  6700 004C                924      BEQ     Finish                  Moves to finish if they are equal (no more input)
0000194C                           925      
0000194C  E985                     926      ASL.L   #4,D5
0000194E                           927      
0000194E  B43C 0030                928      CMP.B   #$30,D2
00001952  6D00 0044                929      BLT     inputError
00001956                           930      
00001956  B43C 0039                931      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
0000195A  6E00 000A                932      BGT     upperCase               Branches if greater, may or may not be a letter in hex
0000195E                           933      
0000195E  0402 0030                934      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
00001962  DA02                     935      ADD.B   D2,D5
00001964                           936      
00001964  60DC                     937      BRA     AtoH
00001966                           938  
00001966                           939          
00001966                           940  upperCase   
00001966  B43C 0041                941      CMP.B   #$41,D2
0000196A  6D00 002C                942      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
0000196E                           943      
0000196E  B43C 0046                944      CMP.B   #$46,D2                 
00001972  6E00 000A                945      BGT     lowerCase               Greater than 46 may be hex code in lowercase
00001976                           946      
00001976  0402 0037                947      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
0000197A  DA02                     948      ADD.B   D2,D5
0000197C  60C4                     949      BRA     AtoH
0000197E                           950  
0000197E                           951  lowerCase
0000197E  B43C 0061                952      CMP.B   #$61,D2
00001982  6D00 0014                953      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001986                           954      
00001986  B43C 0066                955      CMP.B   #$66,D2
0000198A  6E00 000C                956      BGT     InputError              Greater than 66 is not part of hex code
0000198E                           957      
0000198E  0402 0057                958      SUBI.B  #$57,D2
00001992  DA02                     959      ADD.B   D2,D5
00001994  60AC                     960      BRA     AtoH
00001996                           961          
00001996                           962  Finish
00001996  4E75                     963      RTS                             Return from CONVERT
00001998                           964      
00001998                           965  inputError
00001998  13FC 0000 000022B7       966      MOVE.B  #0,(InputQuality)
000019A0  4E75                     967      RTS
000019A2                           968  
000019A2                           969  *********************************************************************
000019A2                           970  *Subroutine: EA
000019A2                           971  *What it does: Outputs parts of opword, moves to new screen if needed
000019A2                           972  *Registers: Uses register A1, D0,
000019A2                           973  *A1: Used to store messages and single char
000019A2                           974  *Paramemeters: A1
000019A2                           975  *A1: Stores what should be used
000019A2                           976  *********************************************************************  
000019A2  =0000003F                977  BITS0TO5_MASK   EQU %00111111
000019A2  =000000C0                978  BITS7TO8_MASK   EQU %11000000
000019A2  =00000E00                979  BITS9TO11_MASK  EQU %00000111000000000
000019A2                           980  
000019A2  1E3C 000A                981  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
000019A6  BC7C 0000                982                          CMP     #0,D6
000019AA  6700 0006                983                          BEQ     IMMEDIATE0
000019AE  6000 0004                984                          BRA     IMMEDIATE_END
000019B2  7C08                     985  IMMEDIATE0              MOVEQ   #8,D6
000019B4                           986  
000019B4  4E75                     987  IMMEDIATE_END           RTS
000019B6                           988  
000019B6  3212                     989  MOVE_MOVEA_EA   MOVE.W  (A2),D1
000019B8  0201 003F                990                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
000019BC  0001 00C0                991                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
000019C0  1C01                     992                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
000019C2  3212                     993                  MOVE.W  (A2),D1         
000019C4  3412                     994                  MOVE.W  (A2),D2 
000019C6  0241 0E00                995                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
000019CA  163C 0009                996                  MOVE.B  #9,D3                   * Prepare shift count
000019CE  E669                     997                  LSR.W   D3,D1                   * Move destination register bits right
000019D0  0242 01C0                998                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
000019D4  E64A                     999                  LSR.W   #3,D2                  * Move destination mode bits right
000019D6  8242                    1000                  OR.W    D2,D1
000019D8  1A01                    1001                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
000019DA  1206                    1002                  MOVE.B  D6,D1               * Pass source into subroutine
000019DC  4EB9 00001B9E           1003                  JSR     CHECK_VALID_EA
000019E2  1205                    1004                  MOVE.B  D5,D1               * Pass destination into subroutine
000019E4  4EB9 00001B9E           1005                  JSR     CHECK_VALID_EA
000019EA  6100 01F6               1006                  BSR print_EA
000019EE  6100 0496               1007                  BSR print_NEWLINE
000019F2                          1008                  
000019F2  4E75                    1009                  RTS
000019F4                          1010  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
000019F4  3212                    1011  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
000019F6  3412                    1012          MOVE.W  (A2),D2                 * Prepare to capture EA field
000019F8  0201 003F               1013          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
000019FC                          1014          
000019FC  0242 0E00               1015          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001A00  163C 0009               1016          MOVE.B  #9,D3                   * Prepare shift count
00001A04  E66A                    1017          LSR.W   D3,D2                   * Move register bits right
00001A06  0202 00C7               1018          ANDI.B  #%11000111,D2           * Set EA mode
00001A0A  3612                    1019          MOVE.W  (A2),D3
00001A0C  0803 0008               1020          BTST    #8,D3                   * Check opmode
00001A10  6700 000A               1021          BEQ     EA1_MODE_ZERO           * Check opmode
00001A14                          1022          
00001A14  3A01                    1023  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001A16  3C02                    1024                  MOVE.W  D2,D6           * Set register as source
00001A18  6000 0006               1025                  BRA EA1_END             * Complete subroutine
00001A1C                          1026          
00001A1C  3C01                    1027  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001A1E  3A02                    1028                  MOVE.W  D2,D5           * Set register as destination
00001A20                          1029  
00001A20  0006 00C0               1030  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001A24  1206                    1031                  MOVE.B  D6,D1               * Pass source into subroutine
00001A26  4EB9 00001B9E           1032                  JSR     CHECK_VALID_EA
00001A2C  1205                    1033                  MOVE.B  D5,D1               * Pass destination into subroutine
00001A2E  4EB9 00001B9E           1034                  JSR     CHECK_VALID_EA
00001A34  6100 01AC               1035                  BSR print_EA
00001A38  6100 044C               1036                  BSR print_NEWLINE
00001A3C                          1037  
00001A3C  4E75                    1038                  RTS
00001A3E                          1039  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001A3E  3C12                    1040  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001A40  0246 0E00               1041                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001A44  163C 0009               1042                  MOVE.B  #9,D3                   * Prepare shift count
00001A48  E66E                    1043                  LSR.W   D3,D6                   * Move register bits right
00001A4A  3612                    1044                  MOVE.W  (A2),D3
00001A4C  0803 0005               1045                  BTST    #5,D3           * Check whether shift count is immediate
00001A50  6700 000A               1046                  BEQ     EA2_IMMEDIATE
00001A54                          1047   
00001A54  0006 00C0               1048  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001A58  6000 000A               1049                  BRA     EA2_END         * Complete subroutine
00001A5C                          1050                  
00001A5C  1E3C 000A               1051  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001A60  4EB8 19A2               1052                  JSR     FORMAT_IMMEDIATE_DATA
00001A64                          1053                  
00001A64  3A12                    1054  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001A66  CA3C 0007               1055                  AND.B   #%00000111,D5
00001A6A  1206                    1056                  MOVE.B  D6,D1               * Pass source into subroutine
00001A6C  4EB9 00001B9E           1057                  JSR     CHECK_VALID_EA
00001A72  1205                    1058                  MOVE.B  D5,D1               * Pass destination into subroutine
00001A74  4EB9 00001B9E           1059                  JSR     CHECK_VALID_EA
00001A7A  6100 0166               1060                  BSR print_EA
00001A7E  6100 0406               1061                  BSR print_NEWLINE
00001A82  4E75                    1062                  RTS   
00001A84                          1063  
00001A84                          1064  
00001A84                          1065  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001A84  3C12                    1066  EA_GROUP3     MOVE.W  (A2),D6
00001A86  0206 003F               1067          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001A8A  0006 0080               1068          ORI.B   #%10000000,D6
00001A8E  1206                    1069          MOVE.B  D6,D1               * Pass source into subroutine
00001A90  4EB9 00001B9E           1070          JSR     CHECK_VALID_EA
00001A96  6100 014A               1071          BSR print_EA
00001A9A  6100 03EA               1072          BSR print_NEWLINE
00001A9E  4E75                    1073          RTS
00001AA0                          1074  
00001AA0                          1075  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001AA0  3212                    1076  EA_GROUP4     MOVE.W  (A2),D1         
00001AA2  0201 003F               1077          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001AA6  0001 00C0               1078          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001AAA  1C01                    1079          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001AAC  3212                    1080          MOVE.W  (A2),D1         
00001AAE                          1081          
00001AAE  0241 0E00               1082          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001AB2  143C 0009               1083          MOVE.B  #9,D2                   * Prepare shift count
00001AB6  E469                    1084          LSR.W   D2,D1                   * Move register bits right
00001AB8  0201 00CF               1085          ANDI.B  #%11001111,D1           * Set destination mode
00001ABC  0001 0008               1086          ORI.B   #%00001000,D1           * Set destination mode
00001AC0  1A01                    1087          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001AC2  1206                    1088          MOVE.B  D6,D1               * Pass source into subroutine
00001AC4  4EB9 00001B9E           1089          JSR     CHECK_VALID_EA
00001ACA  1205                    1090          MOVE.B  D5,D1               * Pass destination into subroutine
00001ACC  4EB9 00001B9E           1091          JSR     CHECK_VALID_EA
00001AD2  6100 010E               1092          BSR print_EA
00001AD6  6100 03AE               1093          BSR print_NEWLINE
00001ADA  4E75                    1094          RTS
00001ADC                          1095          
00001ADC  3C12                    1096  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001ADE  0246 0E00               1097          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001AE2  163C 0009               1098          MOVE.B  #9,D3                   * Prepare shift count
00001AE6  E66E                    1099          LSR.W   D3,D6                  * Move source data bits right            !---
00001AE8  3A12                    1100          MOVE.W  (A2),D5                 * Prepare destination bits
00001AEA  0205 003F               1101          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001AEE  4EB8 19A2               1102          JSR     FORMAT_IMMEDIATE_DATA
00001AF2  1206                    1103          MOVE.B  D6,D1               * Pass source into subroutine
00001AF4  4EB9 00001B9E           1104          JSR     CHECK_VALID_EA
00001AFA  1205                    1105          MOVE.B  D5,D1               * Pass destination into subroutine
00001AFC  4EB9 00001B9E           1106          JSR     CHECK_VALID_EA
00001B02  4E75                    1107          RTS                                    !---
00001B04                          1108          
00001B04  3C12                    1109  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001B06  CC7C 00FF               1110              AND.W   #$00FF,D6                                                   !---
00001B0A  3A12                    1111              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001B0C  0245 0E00               1112              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001B10  163C 0009               1113              MOVE.B  #9,D3                   * Prepare shift count
00001B14  E66D                    1114              LSR.W   D3,D5                   * Move destination register bits right
00001B16  1E3C 000A               1115              MOVE.B  #10,D7
00001B1A  1206                    1116              MOVE.B  D6,D1               * Pass source into subroutine
00001B1C  4EB9 00001B9E           1117              JSR     CHECK_VALID_EA
00001B22  1205                    1118              MOVE.B  D5,D1               * Pass destination into subroutine
00001B24  4EB9 00001B9E           1119              JSR     CHECK_VALID_EA
00001B2A  4E75                    1120              RTS                                 !---
00001B2C                          1121  
00001B2C                          1122  
00001B2C                          1123  
00001B2C                          1124  
00001B2C  3412                    1125  MOVEM_EA   MOVE.W (A2),D2
00001B2E  0802 000A               1126             BTST    #10, D2
00001B32  6700 003E               1127             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001B36                          1128            
00001B36                          1129             
00001B36                          1130                  
00001B36                          1131  *ELSE IT IS  memory-to-register transfers
00001B36                          1132  
00001B36                          1133  
00001B36                          1134  
00001B36                          1135  
00001B36                          1136     
00001B36  E68A                    1137  Memory_to_Register LSR.L #3, D2
00001B38  C43C 0007               1138                     AND.B #$07, D2
00001B3C  B43C 0002               1139                     CMP.B #$2,D2
00001B40  6700 0022               1140                     BEQ   MODE_010
00001B44  B43C 0003               1141                     CMP.B #$03, D2
00001B48  6700 001A               1142                     BEQ   MODE_010  
00001B4C  B43C 0007               1143                     CMP.B #$07,D2
00001B50  6700 0012               1144                     BEQ   MODE_010  
00001B54  4EF9 00001B5A           1145                     JMP   WRONG_INSTRUCTION    
00001B5A                          1146     
00001B5A  1E3C 0005               1147  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001B5E  2C4A                    1148                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001B60  3C12                    1149                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001B62  4E75                    1150                               RTS 
00001B64                          1151             
00001B64  3412                    1152  MODE_010  MOVE.W    (A2),D2
00001B66  C43C 003F               1153            AND.B     #$3F,D2
00001B6A  08C2 0007               1154            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001B6E  1C02                    1155            MOVE.B    D2,D6
00001B70  4E75                    1156            RTS
00001B72                          1157  
00001B72  3412                    1158  Register_to_memory MOVE.W (A2),D2
00001B74  E68A                    1159                     LSR.L #3, D2
00001B76  C43C 0007               1160                     AND.B #$07, D2
00001B7A  B43C 0002               1161                     CMP.B #$2,D2
00001B7E  6700 0016               1162                     BEQ   MODE_01_0
00001B82  B43C 0004               1163                     CMP.B #$04, D2
00001B86  6700 000E               1164                     BEQ   MODE_01_0 
00001B8A  B43C 0007               1165                     CMP.B #$07,D2
00001B8E  6700 0006               1166                     BEQ   MODE_01_0 
00001B92  4EF8 1B5A               1167                     JMP   WRONG_INSTRUCTION
00001B96                          1168                     
00001B96                          1169  
00001B96  3C12                    1170  MODE_01_0       MOVE.W  (A2),D6
00001B98  0206 003F               1171                  ANDI.B  #$3F,D6
00001B9C  4E75                    1172                  RTS
00001B9E                          1173           
00001B9E  1001                    1174  CHECK_VALID_EA  MOVE.B  D1,D0
00001BA0  0200 0038               1175                  ANDI.B  #%111000,D0
00001BA4  E648                    1176                  LSR     #3,D0
00001BA6  B03C 0005               1177                  CMP.B   #%00000101,D0
00001BAA  6700 002C               1178                  BEQ     INVALID_EA
00001BAE  B03C 0006               1179                  CMP.B   #%00000110,D0
00001BB2  6700 0024               1180                  BEQ     INVALID_EA
00001BB6  B03C 0007               1181                  CMP.B   #%00000111,D0
00001BBA  6700 0004               1182                  BEQ     VALID_EA_PC
00001BBE  4E75                    1183                  RTS
00001BC0                          1184                  
00001BC0                          1185                  
00001BC0  1001                    1186  VALID_EA_PC     MOVE.B  D1,D0
00001BC2  0200 0007               1187                  ANDI.B  #%000111,D0
00001BC6  B03C 0010               1188                  CMP.B   #%00010000,D0
00001BCA  6700 000C               1189                  BEQ     INVALID_EA
00001BCE  B03C 0018               1190                  CMP.B   #%00011000,D0
00001BD2  6700 0004               1191                  BEQ     INVALID_EA
00001BD6  4E75                    1192                  RTS
00001BD8                          1193                  
00001BD8  4EB8 1B5A               1194  INVALID_EA      JSR     WRONG_INSTRUCTION
00001BDC  3A7C 0005               1195                  MOVE.W  #5, A5
00001BE0  4E75                    1196                  RTS
00001BE2                          1197                  
00001BE2  48E7 FFDE               1198  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001BE6  163C 0038               1199                  MOVE.B  #$38,D3
00001BEA  C604                    1200                  AND.B   D4,D3
00001BEC  C83C 0007               1201                  AND.B   #$7, D4
00001BF0                          1202                  
00001BF0  B63C 0000               1203                  CMP.B   #$0, D3
00001BF4  6600 0014               1204                  BNE     CHECK_EA_AR
00001BF8  0604 00D0               1205                  ADD.B   #$D0, D4
00001BFC  4281                    1206                  CLR.L   D1
00001BFE  1204                    1207                  MOVE.B  D4, D1
00001C00  4EB9 00001DAC           1208                  JSR     PRINT_REGISTOR              * DATA REG
00001C06  6000 0114               1209                  BRA     PRINT_EA_RETURN
00001C0A                          1210  
00001C0A  B63C 0008               1211  CHECK_EA_AR         CMP.B   #$8, D3
00001C0E  6600 0014               1212                      BNE     CHECK_EA_INDIRECT
00001C12  0604 00A0               1213                      ADD.B   #$A0, D4
00001C16  4281                    1214                      CLR.L   D1
00001C18  1204                    1215                      MOVE.B  D4, D1
00001C1A  4EB9 00001DAC           1216                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001C20  6000 00FA               1217                      BRA     PRINT_EA_RETURN
00001C24                          1218                      
00001C24  B63C 0010               1219  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001C28  6600 0020               1220                          BNE     CHECK_EA_POST
00001C2C  4EB9 00001E00           1221                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001C32  0604 00A0               1222                          ADD.B   #$A0, D4
00001C36  4281                    1223                          CLR.L   D1
00001C38  1204                    1224                          MOVE.B  D4, D1
00001C3A  4EB9 00001DAC           1225                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001C40  4EB9 00001E14           1226                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001C46  6000 00D4               1227                          BRA     PRINT_EA_RETURN
00001C4A                          1228                          
00001C4A  B63C 0018               1229  CHECK_EA_POST   CMP.B   #$18,D3
00001C4E  6600 0026               1230                  BNE     CHECK_EA_PRE
00001C52  4EB9 00001E00           1231                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001C58  0604 00A0               1232                  ADD.B   #$A0, D4
00001C5C  4281                    1233                  CLR.L   D1
00001C5E  1204                    1234                  MOVE.B  D4, D1
00001C60  4EB9 00001DAC           1235                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001C66  4EB9 00001E14           1236                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001C6C  4EB9 00001E2C           1237                  JSR     PRINT_PLUS                  * +
00001C72  6000 00A8               1238                  BRA     PRINT_EA_RETURN
00001C76                          1239  
00001C76  B63C 0020               1240  CHECK_EA_PRE        CMP.B   #$20,D3
00001C7A  6600 0026               1241                      BNE     CHECK_EA_AB_W
00001C7E  4EB9 00001E40           1242                      JSR     PRINT_MINUS                 * -
00001C84  4EB9 00001E00           1243                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001C8A  0604 00A0               1244                      ADD.B   #$A0, D4
00001C8E  4281                    1245                      CLR.L   D1
00001C90  1204                    1246                      MOVE.B  D4, D1
00001C92  4EB9 00001DAC           1247                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001C98  4EB9 00001E14           1248                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001C9E  6000 007C               1249                      BRA     PRINT_EA_RETURN
00001CA2                          1250  
00001CA2  D604                    1251  CHECK_EA_AB_W           ADD.B   D4,D3
00001CA4  B63C 0038               1252                          CMP.B   #$38,D3     
00001CA8  6600 0018               1253                          BNE     CHECK_EA_AB_L
00001CAC  4EB9 00001EAE           1254                          JSR     PRINT_DOLLAR        * $
00001CB2  3A1A                    1255                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001CB4  163C 0002               1256                          MOVE.B  #2,D3
00001CB8  4EB9 00001D44           1257                          JSR     PRINT_HEX
00001CBE  6000 005C               1258                          BRA     PRINT_EA_RETURN
00001CC2                          1259                          
00001CC2  B63C 0039               1260  CHECK_EA_AB_L       CMP.B   #$39, D3
00001CC6  6600 0018               1261                      BNE     CHECK_EA_IMM
00001CCA  4EB9 00001EAE           1262                      JSR     PRINT_DOLLAR        * $
00001CD0  2A1A                    1263                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001CD2  163C 0004               1264                      MOVE.B  #4,D3
00001CD6  4EB9 00001D44           1265                      JSR     PRINT_HEX
00001CDC  6000 003E               1266                      BRA     PRINT_EA_RETURN
00001CE0                          1267                      
00001CE0  BE3C 0004               1268  CHECK_EA_IMM        CMP.B   #4,D7
00001CE4  6600 001E               1269                      BNE     READ_WORD_IMM
00001CE8  4EB9 00001E9A           1270                      JSR     PRINT_HASH_SIGN     * #
00001CEE  4EB9 00001EAE           1271                      JSR     PRINT_DOLLAR        * $
00001CF4  2A1A                    1272                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001CF6  163C 0004               1273                      MOVE.B  #4,D3
00001CFA  4EB9 00001D44           1274                      JSR     PRINT_HEX
00001D00  6000 001A               1275                      BRA     PRINT_EA_RETURN
00001D04                          1276                      
00001D04  4EB9 00001E9A           1277  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001D0A  4EB9 00001EAE           1278                      JSR     PRINT_DOLLAR        * $
00001D10  3A1A                    1279                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001D12  163C 0002               1280                      MOVE.B  #2,D3
00001D16  4EB9 00001D44           1281                      JSR     PRINT_HEX
00001D1C                          1282  
00001D1C  4CDF 7BFF               1283  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001D20  4E75                    1284                      RTS
00001D22                          1285  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001D22                          1286  PRINT_BUFFER    DS.B    10
00001D2C= 30 30 30 30 30 30 ...   1287  IPUT_BUFFER_EX  DC.B    '00000000'
00001D34                          1288  INPUT_BUFFER    DS.B    15                    
00001D44  48E7 FFFE               1289  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001D48  43F8 1D22               1290                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001D4C  D3FC 0000000A           1291                  ADD.L       #10,A1
00001D52  133C 0000               1292                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001D56  6000 000E               1293                  BRA         POPULATE_BUFFER
00001D5A                          1294                  
00001D5A  103C 000E               1295  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001D5E  4E4F                    1296                      TRAP        #15
00001D60  4CDF 7FFF               1297                      MOVEM.L     (SP)+,ALL_REG
00001D64  4E75                    1298                      RTS
00001D66                          1299                 
00001D66  B63C 0000               1300  POPULATE_BUFFER     CMP.B       #0,D3
00001D6A  67EE                    1301                      BEQ         PRINT_HEX_RETURN
00001D6C  183C 000F               1302                      MOVE.B      #$0F,D4
00001D70  C805                    1303                      AND.B       D5,D4
00001D72  E81D                    1304                      ROR.B       #4,D5
00001D74  4EB9 00001D90           1305                      JSR         HEX_TO_ASCII
00001D7A  1304                    1306                      MOVE.B      D4,-(A1)
00001D7C  1805                    1307                      MOVE.B      D5,D4
00001D7E  C83C 000F               1308                      AND.B       #$0F,D4
00001D82  4EB9 00001D90           1309                      JSR         HEX_TO_ASCII
00001D88  1304                    1310                      MOVE.B      D4,-(A1)
00001D8A  E08D                    1311                      LSR.L       #8,D5
00001D8C  5303                    1312                      SUB.B       #1,D3
00001D8E  60D6                    1313                      BRA         POPULATE_BUFFER
00001D90                          1314  
00001D90  48E7 E7FE               1315  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001D94  B83C 0009               1316                          CMP.B       #9,D4
00001D98  6F00 000C               1317                          BLE         NUMBER_TO_ASCII
00001D9C  0604 0037               1318                          ADD.B       #$37,D4
00001DA0  4CDF 7FE7               1319  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001DA4  4E75                    1320                          RTS
00001DA6                          1321                  
00001DA6  0604 0030               1322  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001DAA  60F4                    1323                      BRA     HEX_TO_ASCII_RETURN                    
00001DAC                          1324                      
00001DAC  48E7 FFFE               1325  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001DB0  3F3C 0000               1326                      MOVE.W      #00,-(SP)           *for printing purpose
00001DB4  343C 00F0               1327                      MOVE.W      #$f0,D2             *manipulating each digit
00001DB8  C441                    1328                      AND.W       D1,D2
00001DBA  E842                    1329                      ASR.W       #4,D2
00001DBC  4EB9 00001DE2           1330                      JSR         TO_STRING           * converts to the string ASCII val
00001DC2  E142                    1331                      ASL.W       #8,D2
00001DC4                          1332                      
00001DC4  C27C 000F               1333                      AND.W       #$F,D1              * the last digit
00001DC8  1401                    1334                      MOVE.B      D1,D2               
00001DCA  4EB9 00001DE2           1335                      JSR         TO_STRING
00001DD0  3F02                    1336                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001DD2                          1337                      
00001DD2  224F                    1338                      MOVE.L      SP,A1               * printing
00001DD4  103C 000E               1339                      MOVE.B      #14,D0
00001DD8  4E4F                    1340                      TRAP        #15
00001DDA  2A1F                    1341                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001DDC                          1342  
00001DDC  4CDF 7FFF               1343  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001DE0  4E75                    1344                                  RTS
00001DE2                          1345                                  
00001DE2  B43C 0009               1346  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001DE6  6E00 0008               1347              BGT     LETTERS     
00001DEA  0602 0030               1348              ADD.B   #$30,D2             * offseting digit
00001DEE  4E75                    1349              RTS
00001DF0  0602 0037               1350  LETTERS     ADD.B   #$37,D2             * offseting leter
00001DF4  4E75                    1351              RTS   
00001DF6                          1352  
00001DF6                          1353  *________________________________________________________________________________________
00001DF6                          1354  
00001DF6                          1355  
00001DF6                          1356  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001DF6                          1357          *PARAMENTER     NO PARAMETER NEEDED
00001DF6= 28 00                   1358  OPEN_PAR_TAG        DC.B    '(',0  
00001DF8= 29 00                   1359  CLOSED_PAR_TAG      DC.B    ')',0
00001DFA= 23 00                   1360  HASH_SIGN_TAG       DC.B    '#',0
00001DFC= 24 00                   1361  DOLLAR_TAG          DC.B    '$',0
00001DFE= 2F 00                   1362  FORWARD_SLASH_TAG   DC.B    '/',0      
00001E00  48E7 FFFE               1363  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001E04  43F8 1DF6               1364                          LEA         OPEN_PAR_TAG, A1
00001E08  103C 000E               1365                          MOVE.B      #14,D0
00001E0C  4E4F                    1366                          TRAP        #15
00001E0E  4CDF 7FFF               1367                          MOVEM.L     (SP)+,ALL_REG
00001E12  4E75                    1368                          RTS
00001E14                          1369  *_________________________________________________________________________________
00001E14                          1370  
00001E14                          1371  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001E14                          1372          *PARAMENTER     NO PARAMETER NEEDED
00001E14                          1373          
00001E14  48E7 FFFE               1374  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001E18  43F8 1DF8               1375                              LEA         CLOSED_PAR_TAG, A1
00001E1C  103C 000E               1376                              MOVE.B      #14,D0
00001E20  4E4F                    1377                              TRAP        #15
00001E22  4CDF 7FFF               1378                              MOVEM.L     (SP)+,ALL_REG
00001E26  4E75                    1379                              RTS
00001E28                          1380  *__________________________________________________________________________________
00001E28                          1381  
00001E28                          1382  *________________ PRINT PLUS SIGN _________________________________________________
00001E28                          1383          *PARAMENTER     NO PARAMETER NEEDED
00001E28= 2B 00                   1384  PLUS_TAG            DC.B    '+',0
00001E2A= 2D 00                   1385  MINUS_TAG           DC.B    '-',0        
00001E2C  48E7 FFFE               1386  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001E30  43F8 1E28               1387                  LEA         PLUS_TAG, A1
00001E34  103C 000E               1388                  MOVE.B      #14,D0
00001E38  4E4F                    1389                  TRAP        #15
00001E3A  4CDF 7FFF               1390                  MOVEM.L     (SP)+,ALL_REG
00001E3E  4E75                    1391                  RTS
00001E40                          1392  *_________________________________________________________________________________
00001E40                          1393  
00001E40                          1394  *________________ PRINT MINUS SIGN _______________________________________________
00001E40                          1395          *PARAMENTER     NO PARAMETER NEEDED
00001E40                          1396          
00001E40  48E7 FFFE               1397  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001E44  43F8 1E2A               1398                      LEA         MINUS_TAG, A1
00001E48  103C 000E               1399                      MOVE.B      #14,D0
00001E4C  4E4F                    1400                      TRAP        #15
00001E4E  4CDF 7FFF               1401                      MOVEM.L     (SP)+,ALL_REG
00001E52  4E75                    1402                      RTS
00001E54                          1403  *_________________________________________________________________________________
00001E54                          1404  
00001E54                          1405  *________________ PRINT COMMA ____________________________________________________
00001E54                          1406          *PARAMENTER     NO PARAMETER NEEDED
00001E54= 09 00                   1407  TAB_TAG         DC.B    $9,0
00001E56= 20 00                   1408  SPACE_TAG       DC.B    ' ',0
00001E58= 2C 00                   1409  COMMA_TAG       DC.B    ',',0        
00001E5A  48E7 FFFE               1410  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001E5E  43F8 1E58               1411                      LEA         COMMA_TAG, A1
00001E62  103C 000E               1412                      MOVE.B      #14,D0
00001E66  4E4F                    1413                      TRAP        #15
00001E68  4CDF 7FFF               1414                      MOVEM.L     (SP)+,ALL_REG
00001E6C  4E75                    1415                      RTS
00001E6E                          1416  *_________________________________________________________________________________
00001E6E                          1417  
00001E6E                          1418  *________________ PRINT TAB ______________________________________________________
00001E6E                          1419          *PARAMENTER     NO PARAMETER NEEDED
00001E6E                          1420          
00001E6E  48E7 FFFE               1421  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001E72  43F8 1E54               1422                  LEA         TAB_TAG, A1
00001E76  103C 000E               1423                  MOVE.B      #14,D0
00001E7A  4E4F                    1424                  TRAP        #15
00001E7C  4CDF 7FFF               1425                  MOVEM.L     (SP)+,ALL_REG
00001E80  4E75                    1426                  RTS
00001E82                          1427  *_________________________________________________________________________________
00001E82                          1428  
00001E82                          1429  
00001E82                          1430  *_______________    PRINT NEWLINE   ________________________________________________
00001E82                          1431          *PARAMETER NO PARAMETER NEEDED
00001E82= 0D 0A 00                1432  NEWLINE_TAG         DC.B    CR,LF,0        
00001E86  48E7 FFFE               1433  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001E8A  43F8 1E82               1434                      LEA         NEWLINE_TAG, A1
00001E8E  103C 000E               1435                      MOVE.B      #14,D0
00001E92  4E4F                    1436                      TRAP        #15
00001E94  4CDF 7FFF               1437                      MOVEM.L     (SP)+,ALL_REG
00001E98  4E75                    1438                      RTS
00001E9A                          1439  
00001E9A                          1440  *___________________________________________________________________________________
00001E9A                          1441  
00001E9A                          1442  
00001E9A                          1443  *_______________    PRINT HASH SIGN   ________________________________________________
00001E9A                          1444          *PARAMETER NO PARAMETER NEEDED
00001E9A                          1445          
00001E9A  48E7 FFFE               1446  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001E9E  43F8 1DFA               1447                      LEA         HASH_SIGN_TAG, A1
00001EA2  103C 000E               1448                      MOVE.B      #14,D0
00001EA6  4E4F                    1449                      TRAP        #15
00001EA8  4CDF 7FFF               1450                      MOVEM.L     (SP)+,ALL_REG
00001EAC  4E75                    1451                      RTS
00001EAE                          1452  
00001EAE                          1453  *___________________________________________________________________________________
00001EAE                          1454  
00001EAE                          1455  
00001EAE                          1456  
00001EAE                          1457  *_______________    PRINT DOLLAR   ________________________________________________
00001EAE                          1458          *PARAMETER NO PARAMETER NEEDED
00001EAE                          1459          
00001EAE  48E7 FFFE               1460  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001EB2  43F8 1DFC               1461                      LEA         DOLLAR_TAG, A1
00001EB6  103C 000E               1462                      MOVE.B      #14,D0
00001EBA  4E4F                    1463                      TRAP        #15
00001EBC  4CDF 7FFF               1464                      MOVEM.L     (SP)+,ALL_REG
00001EC0  4E75                    1465                      RTS
00001EC2                          1466  
00001EC2                          1467  *___________________________________________________________________________________
00001EC2                          1468  
00001EC2                          1469  
00001EC2                          1470  
00001EC2                          1471  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001EC2                          1472          *PARAMETER NO PARAMETER NEEDED
00001EC2                          1473          
00001EC2  48E7 FFFE               1474  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001EC6  43F8 1DFE               1475                          LEA         FORWARD_SLASH_TAG, A1
00001ECA  103C 000E               1476                          MOVE.B      #14,D0
00001ECE  4E4F                    1477                          TRAP        #15
00001ED0  4CDF 7FFF               1478                          MOVEM.L     (SP)+,ALL_REG
00001ED4  4E75                    1479                          RTS
00001ED6                          1480  
00001ED6                          1481  
00001ED6                          1482     
00001ED6                          1483  *********************************************************************
00001ED6                          1484  *Subroutine: OUTPUT
00001ED6                          1485  *What it does: Outputs parts of opword, moves to new screen if needed
00001ED6                          1486  *Registers: Uses register A1, D0,
00001ED6                          1487  *A1: Used to store messages and single char
00001ED6                          1488  *Paramemeters: A1, A2
00001ED6                          1489  *A1: Stores what should be used
00001ED6                          1490  *********************************************************************  
00001ED6                          1491  
00001ED6                          1492       OUTPUT:
00001ED6                          1493       
00001ED6  0C39 0001 000022B9      1494       CMP.B  #1,(OutputType)
00001EDE  6700 0026               1495       BEQ    outputOpcode
00001EE2  0C39 0002 000022B9      1496       CMP.B  #2,(OutputType)
00001EEA  6700 0066               1497       BEQ    OutputSize
00001EEE  0C39 0003 000022B9      1498       CMP.B  #3,(OutputType)
00001EF6  6700 0062               1499       BEQ    OutputData
00001EFA  0C39 0004 000022B9      1500       CMP.B  #4,(OutputType)
00001F02  6700 00AC               1501       BEQ    OutputAddress
00001F06                          1502       
00001F06                          1503  outputOpcode    
00001F06  0C39 001E 000022B8      1504       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001F0E  6C00 0010               1505       BGE    outputOpcodeNewScreen
00001F12                          1506       
00001F12  103C 000E               1507       MOVE.B #14,D0
00001F16  4E4F                    1508       TRAP   #15
00001F18                          1509       
00001F18  5239 000022B8           1510       ADD.B  #1,(LineCounter)
00001F1E                          1511       
00001F1E  4E75                    1512       RTS
00001F20                          1513       
00001F20                          1514       
00001F20                          1515  outputOpcodeNewScreen
00001F20  2F09                    1516       MOVE.L A1,-(SP)                Storing last message to be used later
00001F22                          1517       
00001F22  43F9 0000228E           1518       LEA    OUTPUTNEWSCREEN,A1         
00001F28  103C 000E               1519       MOVE.B #14,D0
00001F2C  4E4F                    1520       TRAP   #15
00001F2E                          1521       
00001F2E  43F9 00008008           1522       LEA    userInputStored,A1         Pauses program to show screen full of data
00001F34  103C 0002               1523       MOVE.B #2,D0
00001F38  4E4F                    1524       TRAP   #15
00001F3A                          1525       
00001F3A  13FC 0000 000022B8      1526       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001F42                          1527       
00001F42  225F                    1528       MOVE.L (SP)+,A1                Retriving message to be used
00001F44                          1529       
00001F44  103C 000E               1530       MOVE.B #14,D0                  Outputting decoded message
00001F48  4E4F                    1531       TRAP   #15
00001F4A                          1532       
00001F4A  5239 000022B8           1533       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001F50                          1534       
00001F50  4E75                    1535       RTS
00001F52                          1536       
00001F52                          1537  outputSize
00001F52  103C 000E               1538      MOVE.B  #14,D0
00001F56  4E4F                    1539      TRAP    #15
00001F58  4E75                    1540      RTS
00001F5A                          1541  outputData
00001F5A  267C 00000800           1542      MOVE.L   #$800,A3
00001F60  3692                    1543      MOVE.W  (A2),(A3)
00001F62  2F06                    1544      MOVE.L  D6,-(SP)
00001F64  103C 0000               1545      MOVE.B  #0,D0
00001F68  43F9 00009005           1546      LEA     addressOutput,A1
00001F6E                          1547  
00001F6E                          1548  outputDataLoop
00001F6E                          1549  *check if loop has run 4 times
00001F6E  B03C 0002               1550      CMP.B   #2,D0
00001F72  6700 001C               1551      BEQ     outputDataLoopEnd
00001F76                          1552      *Grab byte from address, dont increment
00001F76  1C13                    1553      MOVE.B  (A3),D6
00001F78                          1554      *LSR to isolate left bit
00001F78  E80E                    1555      LSR.B   #4,D6
00001F7A                          1556      *Call converthtoa
00001F7A  6100 008A               1557      BSR     CONVERTHTOA
00001F7E  12C6                    1558      MOVE.B  D6,(A1)+   
00001F80                          1559      *Grab bye from address, increment
00001F80  1C1B                    1560      MOVE.B  (A3)+,D6
00001F82                          1561      *AND Mask second digit
00001F82  CC3C 000F               1562      AND.B   #$0F,D6
00001F86  6100 007E               1563      BSR     CONVERTHTOA
00001F8A  12C6                    1564      MOVE.B  D6,(A1)+
00001F8C  5200                    1565      ADD.B   #1,D0
00001F8E  60DE                    1566      BRA     outputDataLoop
00001F90                          1567      
00001F90                          1568  outputDataLoopEnd
00001F90  12BC 0000               1569      MOVE.B  #$00,(A1)
00001F94  2C1F                    1570      MOVE.L  (SP)+,D6
00001F96  43F9 00009005           1571      LEA     addressOutput,A1
00001F9C  103C 000E               1572      MOVE.B  #14,D0
00001FA0  4E4F                    1573      TRAP    #15
00001FA2                          1574      
00001FA2  43F9 000022B1           1575      LEA     NEWLINE,A1
00001FA8  103C 000E               1576      MOVE.B  #14,D0
00001FAC  4E4F                    1577      TRAP    #15
00001FAE                          1578  
00001FAE  4E75                    1579      RTS
00001FB0                          1580   
00001FB0                          1581      
00001FB0                          1582  outputAddress
00001FB0  267C 00000800           1583      MOVE.L  #$800,A3
00001FB6  268A                    1584      MOVE.L  A2,(A3)
00001FB8  2F06                    1585      MOVE.L  D6,-(SP)
00001FBA  103C 0000               1586      MOVE.B  #0,D0
00001FBE  43F9 00009005           1587      LEA     addressOutput,A1
00001FC4                          1588  outputAddressLoop
00001FC4                          1589      *check if loop has run 4 times
00001FC4  B03C 0004               1590      CMP.B   #4,D0
00001FC8  6700 001C               1591      BEQ     outputAddressLoopEnd
00001FCC                          1592      *Grab byte from address, dont increment
00001FCC  1C13                    1593      MOVE.B  (A3),D6
00001FCE                          1594      *LSR to isolate left bit
00001FCE  E80E                    1595      LSR.B   #4,D6
00001FD0                          1596      *Call converthtoa
00001FD0  6100 0034               1597      BSR     CONVERTHTOA
00001FD4  12C6                    1598      MOVE.B  D6,(A1)+   
00001FD6                          1599      *Grab bye from address, increment
00001FD6  1C1B                    1600      MOVE.B  (A3)+,D6
00001FD8                          1601      *AND Mask second digit
00001FD8  CC3C 000F               1602      AND.B   #$0F,D6
00001FDC  6100 0028               1603      BSR     CONVERTHTOA
00001FE0  12C6                    1604      MOVE.B  D6,(A1)+
00001FE2  5200                    1605      ADD.B   #1,D0
00001FE4  60DE                    1606      BRA     outputAddressLoop
00001FE6                          1607      
00001FE6                          1608      
00001FE6                          1609  outputAddressLoopEnd
00001FE6  12BC 0000               1610      MOVE.B  #$00,(A1)
00001FEA  2C1F                    1611      MOVE.L  (SP)+,D6
00001FEC  43F9 00009005           1612      LEA     addressOutput,A1
00001FF2                          1613      
00001FF2  103C 000E               1614      MOVE.B  #14,D0
00001FF6  4E4F                    1615      TRAP    #15
00001FF8                          1616      
00001FF8  43F9 000022B4           1617      LEA     spaces,A1
00001FFE  103C 000E               1618      MOVE.B  #14,D0
00002002  4E4F                    1619      TRAP    #15
00002004                          1620  
00002004                          1621  
00002004  4E75                    1622      RTS
00002006                          1623  
00002006                          1624  *********************************************************************
00002006                          1625  *Subroutine: CONVERTHTOA
00002006                          1626  *What it does: Converts HEX to ASCII
00002006                          1627  *Registers: Uses register D6,D0
00002006                          1628  *D6: Stores hex character to be converted
00002006                          1629  *Paramemeters: D6
00002006                          1630  *D6: Stores hex characcter to be converted
00002006                          1631  *********************************************************************
00002006                          1632      CONVERTHTOA:
00002006                          1633      
00002006  BC3C 0009               1634      CMP.B   #9,D6
0000200A  6F00 0006               1635      BLE     zerotonine
0000200E  6000 000A               1636      BRA     AtoF
00002012                          1637      
00002012                          1638  zerotonine    
00002012  0686 00000030           1639      ADD.L   #$30,D6
00002018  4E75                    1640      RTS
0000201A                          1641  AtoF
0000201A  0686 00000037           1642      ADD.L   #$37,D6
00002020  4E75                    1643      RTS
00002022                          1644      
00002022                          1645  END_SIMULATION:
00002022                          1646          
00002022  103C 0009               1647      MOVE.B  #9,D0
00002026  4E4F                    1648      TRAP    #15
00002028                          1649  
00002028  FFFF FFFF               1650      SIMHALT             ; halt simulator
0000202C                          1651  
0000202C                          1652  * Put variables and constants here
0000202C= 57 65 6C 63 6F 6D ...   1653  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
00002052= 53 6F 6D 65 20 71 ...   1654                  DC.B    'Some quick rules:',CR,LF
00002065= 31 29 20 4F 6E 6C ...   1655                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
000020A1= 32 29 20 54 68 65 ...   1656                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
000020EC= 33 29 20 41 6E 79 ...   1657                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
00002130= 20 20 20 77 69 6C ...   1658                  DC.B    '   will be rejected',CR,LF
00002145= 34 29 20 54 68 65 ...   1659                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
00002188= 20 20 20 77 69 6C ...   1660                  DC.B    '   will be rejected',CR,LF,0      
0000219E= 50 6C 65 61 73 65 ...   1661  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
000021C4= 50 6C 65 61 73 65 ...   1662  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
000021EA                          1663  
000021EA= 0D 0A 54 68 69 73 ...   1664  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
00002208= 0D 0A 49 6E 70 75 ...   1665  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
00002244                          1666  
00002244= 54 6F 20 72 65 70 ...   1667  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
0000228E                          1668  
0000228E= 50 6C 65 61 73 65 ...   1669  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
000022B1                          1670  
000022B1= 0D 0A 00                1671  NEWLINE     DC.B    CR,LF,0
000022B4= 20 20 00                1672  SPACES      DC.B    '  ',0
000022B7                          1673  
000022B7= 01                      1674  InputQuality    DC.B    1       Set to 1 for default good
000022B8= 00                      1675  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
000022B9= 00                      1676  OutputType      DC.B    0      To track what type is being output
000022BA                          1677  
000022BA= 4E 4F 50 0D 0A 00       1678  nopout  DC.B    'NOP',CR,LF,0
000022C0= 4D 4F 56 45 00          1679  moveout  DC.B    'MOVE',0
000022C5= 4D 4F 56 45 41 00       1680  moveaout DC.B      'MOVEA',0
000022CB= 4D 4F 56 45 51 00       1681  moveqout DC.B   'MOVEQ',0
000022D1= 4D 4F 56 45 4D 00       1682  movemout DC.B   'MOVEM',0
000022D7                          1683  
000022D7= 53 55 42 00             1684  subout    DC.B  'SUB',0
000022DB= 41 44 44 00             1685  addout    DC.B 'ADD',0
000022DF= 41 44 44 41 00          1686  addaout    DC.B 'ADDA',0
000022E4= 41 44 44 51 00          1687  addqout    DC.B 'ADDQ',0
000022E9                          1688  
000022E9= 4C 45 41 00             1689  leaout    DC.B  'LEA',0
000022ED                          1690  
000022ED= 4E 4F 54 00             1691  notout    DC.B  'NOT',0
000022F1= 4F 52 00                1692  orout DC.B     'OR',0
000022F4= 41 4E 44 00             1693  andout DC.B     'AND',0
000022F8                          1694  
000022F8                          1695  
000022F8= 4C 53 4C 00             1696  lslout    DC.B  'LSL',0
000022FC= 4C 53 52 00             1697  lsrout    DC.B  'LSR',0
00002300= 41 53 4C 00             1698  aslout    DC.B  'ASL',0
00002304= 41 53 52 00             1699  asrout    DC.B  'ASR',0
00002308                          1700  
00002308= 52 4F 4C 00             1701  rolout    DC.B  'ROL',0
0000230C= 52 4F 52 00             1702  rorout    DC.B  'ROR',0
00002310                          1703  
00002310= 42 47 54 00             1704  bgtout DC.B     'BGT',0
00002314= 42 4C 45 00             1705  bleout DC.B     'BLE',0
00002318= 42 45 51 00             1706  beqout DC.B     'BEQ',0
0000231C                          1707  
0000231C= 4A 53 52 00             1708  jsrout DC.B     'JSR',0
00002320= 52 54 53 0D 0A 00       1709  rtsout DC.B     'RTS',CR,LF,0
00002326= 42 52 41 00             1710  braout DC.B     'BRA',0
0000232A                          1711  
0000232A= 44 41 54 41 20 20 ...   1712  dataout DC.B    'DATA   ',0
00002332                          1713  
00002332                          1714  
00002332                          1715  
00002332= 2E 42 20 20 20 20 00    1716  byteout  DC.B    '.B    ',0
00002339= 2E 57 20 20 20 20 00    1717  wordout  DC.B    '.W    ',0
00002340= 2E 4C 20 20 20 20 00    1718  longout  DC.B    '.L    ',0
00002347                          1719  
00002347= 0D 0A 00                1720  empty    DC.B    '',CR,LF,0
0000234A                          1721  
0000234A  =0000000D               1722  CR  EQU $0D
0000234A  =0000000A               1723  LF  EQU $0A
0000234A                          1724  
0000234A                          1725  
0000234A                          1726      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1466
ADDA                14A4
ADDAOUT             22DF
ADDOUT              22DB
ADDQ                1428
ADDQOUT             22E4
ADDQ_EA             1ADC
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 1734
ANDOUT              22F4
ASL                 15DC
ASLOUT              2300
ASR                 161A
ASROUT              2304
ATOF                201A
ATOH                1942
BCC                 1772
BEQ                 17DC
BEQOUT              2318
BGT                 1798
BGTOUT              2310
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 17BA
BLEOUT              2314
BRA                 17FE
BRAOUT              2326
BYTE                12B8
BYTEOUT             2332
CHECK_EA_AB_L       1CC2
CHECK_EA_AB_W       1CA2
CHECK_EA_AR         1C0A
CHECK_EA_IMM        1CE0
CHECK_EA_INDIRECT   1C24
CHECK_EA_POST       1C4A
CHECK_EA_PRE        1C76
CHECK_VALID_EA      1B9E
CLOSED_PAR_TAG      1DF8
COMMA_TAG           1E58
CONVERTATOH         1942
CONVERTHTOA         2006
CR                  D
DATA                1820
DATAOUT             232A
DOLLAR_TAG          1DFC
EA1_END             1A20
EA1_MODE_ONE        1A14
EA1_MODE_ZERO       1A1C
EA2_END             1A64
EA2_IMMEDIATE       1A5C
EA2_REGISTER        1A54
EA_GROUP1           19F4
EA_GROUP2           1A3E
EA_GROUP3           1A84
EA_GROUP4           1AA0
EMPTY               2347
END_SIMULATION      2022
FINISH              1996
FIRSTINPUT          1860
FORMAT_IMMEDIATE_DATA  19A2
FORWARD_SLASH_TAG   1DFE
HASH_SIGN_TAG       1DFA
HERE                1020
HEX_TO_ASCII        1D90
HEX_TO_ASCII_RETURN  1DA0
IMMEDIATE0          19B2
IMMEDIATE_END       19B4
INPUT1              8000
INPUT1MESSAGE       219E
INPUT2              8004
INPUT2MESSAGE       21C4
INPUTERROR          1998
INPUTERROR2SMALLER  2208
INPUTERRORBADCHAR   21EA
INPUTQUALITY        22B7
INPUTREPEAT         2244
INPUT_BUFFER        1D34
INVALID_EA          1BD8
IPUT_BUFFER_EX      1D2C
JSR                 1500
JSROUT              231C
LEA                 16D4
LEAOUT              22E9
LETSGO              1058
LETTERS             1DF0
LF                  A
LINECOUNTER         22B8
LONG                12E0
LONGOUT             2340
LOWERCASE           197E
LSL                 1560
LSLOUT              22F8
LSR                 159E
LSROUT              22FC
MEMORY_TO_REGISTER  1B36
MINUS_TAG           1E2A
MODE_010            1B64
MODE_01_0           1B96
MOVE                1314
MOVEA               135C
MOVEAOUT            22C5
MOVEM               13B4
MOVEMOUT            22D1
MOVEM_EA            1B2C
MOVEOUT             22C0
MOVEQ               1392
MOVEQOUT            22CB
MOVEQ_EA            1B04
MOVE_MOVEA_EA       19B6
NEWLINE             22B1
NEWLINE_TAG         1E82
NOP                 12F4
NOPOUT              22BA
NOT                 1522
NOTOUT              22ED
NUMBER_TO_ASCII     1DA6
OPCODE              11B2
OPEN_PAR_TAG        1DF6
OR                  16F6
OROUT               22F1
OUTPUT              1ED6
OUTPUTADDRESS       1FB0
OUTPUTADDRESSLOOP   1FC4
OUTPUTADDRESSLOOPEND  1FE6
OUTPUTDATA          1F5A
OUTPUTDATALOOP      1F6E
OUTPUTDATALOOPEND   1F90
OUTPUTNEWSCREEN     228E
OUTPUTOPCODE        1F06
OUTPUTOPCODENEWSCREEN  1F20
OUTPUTSIZE          1F52
OUTPUTTYPE          22B9
PLUS_TAG            1E28
POPULATE_BUFFER     1D66
PRINT_BUFFER        1D22
PRINT_CLOSED_PARENTHESIS  1E14
PRINT_COMMA         1E5A
PRINT_DOLLAR        1EAE
PRINT_EA            1BE2
PRINT_EA_RETURN     1D1C
PRINT_FORWARD_SLASH  1EC2
PRINT_HASH_SIGN     1E9A
PRINT_HEX           1D44
PRINT_HEX_RETURN    1D5A
PRINT_MINUS         1E40
PRINT_NEWLINE       1E86
PRINT_OPEN_PARENTHESIS  1E00
PRINT_PLUS          1E2C
PRINT_REGISTOR      1DAC
PRINT_REGISTOR_RETURN  1DDC
PRINT_TAB           1E6E
READ_WORD_IMM       1D04
REGISTER_TO_MEMORY  1B72
RETURN              12B6
ROL                 1658
ROLOUT              2308
ROR                 1696
ROROUT              230C
RTS                 14DE
RTSOUT              2320
SECONDINPUT         18C4
SPACES              22B4
SPACE_TAG           1E56
START               1000
STARTMESSAGE        202C
SUB                 13EA
SUBOUT              22D7
TAB_TAG             1E54
THERE               1186
THROWINPUT1CHARERROR  18A6
THROWINPUT2CHARERROR  1912
THROWINPUT2LOWERERROR  192E
TO_STRING           1DE2
UPPERCASE           1966
USERINPUT           184E
USERINPUTREPEAT     1188
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1BC0
WELCOMEEXPLANATION  184E
WORD                12CC
WORDOUT             2339
WRONG_INSTRUCTION   1B5A
ZEROTONINE          2012
