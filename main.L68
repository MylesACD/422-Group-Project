00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 5:16:48 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 00002336        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 088C                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 00001186             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048  6E00 000E                 42      BGT letsgo
0000104C  B67C 0004                 43      CMP #4,D3 
00001050  6700 0006                 44      BEQ letsgo
00001054  6F00 0002                 45      BLE letsgo
00001058                            46     
00001058                            47  letsgo
00001058                            48      
00001058                            49  * calls-------------------------------------------------------
00001058  347C 100C                 50      MOVE.W #$100C, A2
0000105C  6100 0154                 51      BSR     OPCODE * test MOVE.B
00001060                            52  
00001060  347C 1010                 53      MOVE.W #$1010, A2
00001064  6100 014C                 54      BSR     OPCODE * test MOVEA.W
00001068                            55      
00001068  347C 1014                 56      MOVE.W #$1014, A2
0000106C  6100 0144                 57      BSR     OPCODE * test MOVEQ
00001070                            58     
00001070  347C 1016                 59      MOVE.W #$1016, A2
00001074  6100 013C                 60      BSR     OPCODE *test MOVEA.L
00001078                            61      
00001078  347C 1018                 62      MOVE.W #$1018, A2
0000107C  6100 0134                 63      BSR     OPCODE *test DATA
00001080                            64      
00001080                            65      
00001080  347C 101A                 66      MOVE.W #$101A, A2
00001084  6100 012C                 67      BSR     OPCODE *test SUB.L
00001088                            68      
00001088  347C 101C                 69      MOVE.W #$101C, A2
0000108C  6100 0124                 70      BSR     OPCODE *test BRA
00001090                            71      
00001090  347C 1020                 72      MOVE.W #$1020, A2
00001094  6100 011C                 73      BSR     OPCODE *test JSR
00001098                            74      
00001098                            75      
00001098  43F9 000023C6             76      LEA empty,A1
0000109E  13FC 0001 00002337        77      MOVE.B  #1,(OutputType)       
000010A6  6100 0EAC                 78      BSR    OUTPUT
000010AA                            79  
000010AA                            80      
000010AA  347C 1026                 81      MOVE.W #$1026, A2
000010AE  6100 0102                 82      BSR     OPCODE *test NOT
000010B2                            83      
000010B2  347C 1028                 84      MOVE.W #$1028, A2
000010B6  6100 00FA                 85      BSR     OPCODE *test LEA
000010BA                            86      
000010BA  347C 102A                 87      MOVE.W #$102A, A2
000010BE  6100 00F2                 88      BSR     OPCODE *test OR
000010C2                            89      
000010C2  43F9 000023C6             90       LEA empty,A1
000010C8  13FC 0001 00002337        91      MOVE.B  #1,(OutputType)       
000010D0  6100 0E82                 92      BSR    OUTPUT
000010D4                            93  
000010D4                            94      
000010D4  347C 1030                 95      MOVE.W #$1030, A2
000010D8  6100 00D8                 96      BSR     OPCODE *test MOVEM
000010DC                            97  
000010DC  347C 1034                 98      MOVE.W #$1034, A2
000010E0  6100 00D0                 99      BSR     OPCODE *test AND
000010E4                           100      
000010E4  347C 1036                101      MOVE.W #$1036, A2
000010E8  6100 00C8                102      BSR     OPCODE *test ADD
000010EC                           103      
000010EC  43F9 000023C6            104      LEA empty,A1
000010F2  13FC 0001 00002337       105      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0E58                106      BSR    OUTPUT
000010FE                           107  
000010FE  347C 1038                108      MOVE.W #$1038, A2
00001102  6100 00AE                109      BSR     OPCODE *test ADDA
00001106                           110      
00001106  347C 103A                111      MOVE.W #$103A, A2
0000110A  6100 00A6                112      BSR     OPCODE *test ADDQ
0000110E                           113      
0000110E  347C 103C                114      MOVE.W #$103C, A2
00001112  6100 009E                115      BSR     OPCODE *test LSL
00001116                           116  
00001116  347C 103E                117      MOVE.W #$103E, A2
0000111A  6100 0096                118      BSR     OPCODE *test LSR
0000111E                           119      
0000111E  347C 1040                120      MOVE.W #$1040, A2
00001122  6100 008E                121      BSR     OPCODE *test ASL
00001126                           122      
00001126  43F9 000023C6            123      LEA empty,A1
0000112C  13FC 0001 00002337       124      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0E1E                125      BSR    OUTPUT
00001138                           126  
00001138                           127  
00001138  347C 1042                128      MOVE.W #$1042, A2
0000113C  6100 0074                129      BSR     OPCODE *test ASR
00001140                           130      
00001140                           131      
00001140  347C 1044                132      MOVE.W #$1044, A2
00001144  6100 006C                133      BSR     OPCODE *test ROL
00001148                           134  
00001148  347C 1046                135      MOVE.W #$1046, A2
0000114C  6100 0064                136      BSR     OPCODE *test ROR
00001150                           137      
00001150  43F9 000023C6            138      LEA empty,A1
00001156  13FC 0001 00002337       139      MOVE.B  #1,(OutputType) * new line  
0000115E  6100 0DF4                140      BSR    OUTPUT
00001162                           141  
00001162  347C 1048                142      MOVE.W #$1048, A2
00001166  6100 004A                143      BSR     OPCODE *test BGT
0000116A                           144  
0000116A  347C 1050                145      MOVE.W #$1050, A2
0000116E  6100 0042                146      BSR     OPCODE *test BLE
00001172                           147      
00001172  347C 1054                148      MOVE.W #$1054, A2
00001176  6100 003A                149      BSR     OPCODE *test BEQ
0000117A                           150      
0000117A                           151  
0000117A                           152    
0000117A  347C 1186                153      MOVE.W #$1186, A2
0000117E  6100 0032                154      BSR     OPCODE *test RTS
00001182                           155  
00001182                           156  
00001182                           157  * calls---------------------------------------------------------    
00001182  6000 0004                158      BRA userInputRepeat
00001186                           159  there    
00001186  4E75                     160      RTS
00001188                           161  * end testing--------------------------------------------------------------
00001188                           162   
00001188                           163  
00001188                           164       
00001188                           165    
00001188                           166  
00001188                           167      
00001188                           168  userInputRepeat
00001188  43F9 000022C2            169      LEA     INPUTREPEAT,A1
0000118E  103C 000E                170      MOVE.B  #14,D0
00001192  4E4F                     171      TRAP    #15
00001194  5239 00002336            172      ADD.B   #1,(LineCounter)
0000119A                           173      
0000119A  43F9 00008008            174      LEA     userInputStored,A1
000011A0  103C 0005                175      MOVE.B  #5,D0
000011A4  4E4F                     176      TRAP    #15
000011A6                           177      
000011A6  B23C 000D                178      CMP.B   #$0D,D1
000011AA  6700 FE5C                179      BEQ     userInputStart
000011AE                           180   
000011AE  FFFF FFFF                181      SIMHALT
000011B2                           182  
000011B2                           183  **********************************************************
000011B2                           184  *Subroutine: OPCODE
000011B2                           185  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B2                           186  *Registers: 
000011B2                           187  *A1: printing
000011B2                           188  *A2: parameter with instruction address
000011B2                           189  *D0: printing
000011B2                           190  *D3: used for determing the instruction, mostly shifts
000011B2                           191  *D2: used for determing the size
000011B2                           192  *Paramemeters: A2 the memory address to decode from
000011B2                           193  **********************************************************
000011B2                           194  OPCODE:
000011B2  4243                     195      CLR D3
000011B4                           196      
000011B4  0C52 4E75                197      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011B8  6700 033C                198      BEQ rts
000011BC                           199      
000011BC  0C52 4E71                200      CMP #$4E71, (A2) *NOP compare
000011C0  6700 0132                201      BEQ nop
000011C4                           202      
000011C4  3612                     203      Move.W (A2), D3 
000011C6  E04B                     204      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011C8  E84B                     205      LSR #4,D3
000011CA                           206      
000011CA                           207      
000011CA  B67C 0008                208      CMP #%1000, D3 * OR compare
000011CE  6700 0566                209      BEQ or
000011D2                           210      
000011D2                           211      
000011D2  B67C 0003                212      CMP #%0011, D3 *MOVE and MOVEA compare
000011D6  6F00 013C                213      BLE move
000011DA                           214      
000011DA  B67C 0007                215      CMP #%0111, D3 *MOVEQ compare
000011DE  6700 01B2                216      BEQ moveq
000011E2                           217      
000011E2  B67C 0009                218      CMP #%1001, D3 *SUB compare
000011E6  6700 020A                219      BEQ sub
000011EA                           220      
000011EA  B67C 000C                221      CMP #%1100, D3 *AND compare
000011EE  6700 0588                222      BEQ and
000011F2                           223      
000011F2  B67C 0005                224      CMP #%0101, D3 *ADDQ compare
000011F6  6700 023C                225      BEQ addq
000011FA                           226      
000011FA  B67C 0006                227      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
000011FE  6700 05BA                228      BEQ bcc
00001202                           229      
00001202                           230  
00001202  3612                     231      Move.W (A2), D3 * reset D3
00001204  0243 F118                232      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
00001208  B67C E108                233      CMP #%1110000100001000,D3 * LSL compare
0000120C  6700 0376                234      BEQ lsl
00001210                           235  
00001210  3612                     236      Move.W (A2), D3 * reset D3
00001212  0243 F118                237      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
00001216  B67C E008                238      CMP #%1110000000001000,D3 * LSR compare
0000121A  6700 03AA                239      BEQ lsr
0000121E                           240      
0000121E                           241      
0000121E  3612                     242      Move.W (A2), D3 * reset D3
00001220  0243 F118                243      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001224  B67C E100                244      CMP #%1110000100000000,D3 * ASL compare
00001228  6700 03DE                245      BEQ asl
0000122C                           246  
0000122C  3612                     247      Move.W (A2), D3 * reset D3
0000122E  0243 F118                248      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001232  B67C E000                249      CMP #%1110000000000000,D3 * ASR compare
00001236  6700 0412                250      BEQ asr
0000123A                           251  
0000123A  3612                     252      Move.W (A2), D3 * reset D3
0000123C  0243 F118                253      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001240  B67C E118                254      CMP #%1110000100011000,D3 * ROL compare
00001244  6700 0446                255      BEQ rol
00001248                           256  
00001248  3612                     257      Move.W (A2), D3 * reset D3
0000124A  0243 F118                258      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000124E  B67C E018                259      CMP #%1110000000011000,D3 * ROR compare
00001252  6700 047A                260      BEQ ror
00001256                           261  
00001256                           262      
00001256                           263      
00001256  3612                     264      Move.W (A2), D3 * reset D3
00001258  0243 F0C0                265      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000125C  B67C D0C0                266      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001260  6700 0256                267      BEQ adda
00001264                           268      
00001264  3612                     269      Move.W (A2), D3 
00001266  E04B                     270      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001268  E84B                     271      LSR #4,D3
0000126A  B67C 000D                272      CMP #%1101, D3 *ADD compare
0000126E  6700 0206                273      BEQ add
00001272                           274  
00001272                           275    
00001272  3612                     276      Move.W (A2), D3 * reset D3
00001274  0243 FB80                277      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001278  B67C 4880                278      CMP #%0100100010000000,D3 * MOVEM compare
0000127C  6700 013A                279      BEQ movem
00001280                           280  
00001280                           281      
00001280                           282      
00001280  3612                     283      Move.W (A2), D3 * reset D3
00001282  EC4B                     284      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001284  B67C 013A                285      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001288  6700 0292                286      BEQ jsr
0000128C                           287  
0000128C  3612                     288      Move.W (A2), D3 * reset D3
0000128E  E04B                     289      LSR #8,D3 * make D3 only contain the first 8 bits
00001290  B67C 0046                290      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001294  6700 02AC                291      BEQ not
00001298                           292      
00001298  3612                     293      Move.W (A2), D3 * reset D3
0000129A  0243 F1C0                294      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000129E  B67C 41C0                295      CMP #%0100000111000000,D3 *LEA compare
000012A2  6700 046C                296      BEQ lea
000012A6                           297      
000012A6                           298      
000012A6                           299      
000012A6                           300      
000012A6                           301      
000012A6                           302  
000012A6                           303  
000012A6                           304     
000012A6  3612                     305      Move.W (A2), D3 * reset D3
000012A8  E04B                     306      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012AA  B67C 0060                307      CMP #%01100000, D3 *BRA compare
000012AE  6700 0596                308      BEQ bra
000012B2                           309      
000012B2                           310      
000012B2  6000 05B4                311      BRA data
000012B6                           312      
000012B6                           313  return
000012B6  4E75                     314      RTS
000012B8                           315  byte
000012B8  43F9 000023B1            316      LEA    byteout,A1        
000012BE  13FC 0002 00002337       317      MOVE.B  #2,(OutputType)
000012C6  6100 0C8C                318      BSR     OUTPUT 
000012CA  60EA                     319      BRA return
000012CC                           320  word
000012CC  43F9 000023B8            321      LEA    wordout,A1        
000012D2  13FC 0002 00002337       322      MOVE.B  #2,(OutputType)
000012DA  6100 0C78                323      BSR     OUTPUT
000012DE  60D6                     324      BRA return
000012E0                           325  long
000012E0  43F9 000023BF            326      LEA    longout,A1        
000012E6  13FC 0002 00002337       327      MOVE.B  #2,(OutputType)
000012EE  6100 0C64                328      BSR     OUTPUT 
000012F2  60C2                     329      BRA return
000012F4                           330      
000012F4                           331  nop 
000012F4  13FC 0004 00002337       332      MOVE.B  #4,(OutputType)
000012FC  6100 0C56                333      BSR     OUTPUT
00001300  43F9 00002339            334      LEA    nopout,A1        
00001306  13FC 0001 00002337       335      MOVE.B  #1,(OutputType)
0000130E  6100 0C44                336      BSR     OUTPUT
00001312  60A2                     337      BRA return
00001314                           338      
00001314                           339  move
00001314                           340      * put the size of the instruction into D2 to use later
00001314                           341      * since the first two bits of D3 are 00 for move moving the entire word works
00001314  3403                     342      Move.W D3, D2
00001316                           343  
00001316                           344  
00001316                           345      * determine if MOVE or MOVEA
00001316                           346      * if bits 8,7,6 = 001 its MOVEA
00001316  3612                     347      MOVE.W (A2),D3
00001318  0243 01C0                348      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
0000131C                           349      
0000131C  B67C 0040                350      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001320  6700 003A                351      BEQ movea
00001324                           352      
00001324  13FC 0004 00002337       353      MOVE.B  #4,(OutputType)
0000132C  6100 0C26                354      BSR     OUTPUT
00001330                           355  
00001330  43F9 0000233F            356      LEA    moveout,A1     *print the type
00001336  13FC 0001 00002337       357      MOVE.B  #1,(OutputType)   
0000133E  6100 0C14                358      BSR    OUTPUT
00001342                           359      
00001342                           360      *now to print size  
00001342  B47C 0002                361      cmp #2,D2 *if the size is 2 branch to long
00001346  6798                     362      BEQ long
00001348  B47C 0003                363      cmp #3,D2 *if the size is 3 branch to word
0000134C  6700 FF7E                364      BEQ word
00001350  6100 FF66                365      BSR byte *otherwise branch to byte
00001354                           366    
00001354  6100 06DE                367      BSR MOVE_MOVEA_EA
00001358                           368      
00001358  6000 FF5C                369      BRA return
0000135C                           370      
0000135C                           371      
0000135C                           372  movea
0000135C  13FC 0004 00002337       373      MOVE.B  #4,(OutputType)
00001364  6100 0BEE                374      BSR     OUTPUT
00001368                           375  
00001368  43F9 00002344            376      LEA    moveaout,A1
0000136E  13FC 0001 00002337       377      MOVE.B  #1,(OutputType)       
00001376  6100 0BDC                378      BSR    OUTPUT
0000137A                           379      
0000137A                           380      *now to print size  
0000137A  B47C 0002                381      cmp #2,D2 *if the size is 2 branch to long
0000137E  6700 FF60                382      BEQ long
00001382  B47C 0003                383      cmp #3,D2 *if the size is 3 branch to word
00001386  6100 FF44                384      BSR word
0000138A                           385      
0000138A  6100 06A8                386      BSR MOVE_MOVEA_EA
0000138E                           387      
0000138E  6000 FF26                388      BRA return
00001392                           389      
00001392                           390  moveq
00001392  13FC 0004 00002337       391      MOVE.B  #4,(OutputType)
0000139A  6100 0BB8                392      BSR     OUTPUT
0000139E                           393  
0000139E  43F9 0000234A            394      LEA    moveqout,A1
000013A4  13FC 0001 00002337       395      MOVE.B  #1,(OutputType)       
000013AC  6100 0BA6                396      BSR    OUTPUT
000013B0  6100 07D0                397      BSR MOVEQ_EA
000013B4  6000 FF00                398      BRA return
000013B8                           399  
000013B8                           400      
000013B8                           401  movem
000013B8  13FC 0004 00002337       402      MOVE.B  #4,(OutputType)
000013C0  6100 0B92                403      BSR     OUTPUT
000013C4                           404      
000013C4  43F9 00002350            405      LEA    movemout,A1
000013CA  13FC 0001 00002337       406      MOVE.B  #1,(OutputType)       
000013D2  6100 0B80                407      BSR    OUTPUT
000013D6                           408      
000013D6  3412                     409      MOVE.W (A2),D2
000013D8  0242 0040                410      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013DC  EC4A                     411      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013DE  B47C 0001                412      CMP #1, D2 * if the size is 1 branch to long
000013E2  6700 FEFC                413      BEQ long
000013E6  6100 FEE4                414      BSR word * otherwise branch to word
000013EA  6100 07BE                415      BSR MOVEM_EA
000013EE                           416      
000013EE  6000 FEC6                417      BRA return
000013F2                           418  sub 
000013F2  13FC 0004 00002337       419      MOVE.B  #4,(OutputType)
000013FA  6100 0B58                420      BSR     OUTPUT
000013FE                           421     
000013FE  43F9 00002356            422      LEA    subout,A1
00001404  13FC 0001 00002337       423      MOVE.B  #1,(OutputType)       
0000140C  6100 0B46                424      BSR    OUTPUT
00001410                           425      
00001410  3412                     426      MOVE.W (A2),D2
00001412  0242 00C0                427      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001416  EC4A                     428      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001418                           429  
00001418                           430  
00001418                           431      
00001418                           432      *now to print size  
00001418  B47C 0002                433      cmp #2,D2 *if the size is 2 branch to long
0000141C  6700 FEC2                434      BEQ long
00001420  B47C 0001                435      cmp #1,D2 *if the size is 1 branch to word
00001424  6700 FEA6                436      BEQ word
00001428  6100 FE8E                437      BSR byte *otherwise branch to byte
0000142C  6100 0644                438      BSR EA_GROUP1
00001430  6000 FE84                439      BRA return
00001434                           440      
00001434                           441  addq 
00001434  13FC 0004 00002337       442      MOVE.B  #4,(OutputType)
0000143C  6100 0B16                443      BSR     OUTPUT
00001440                           444     
00001440  43F9 00002363            445      LEA    addqout,A1
00001446  13FC 0001 00002337       446      MOVE.B  #1,(OutputType)       
0000144E  6100 0B04                447      BSR    OUTPUT
00001452                           448      
00001452  3412                     449      MOVE.W (A2),D2
00001454  0242 00C0                450      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001458  EC4A                     451      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000145A                           452  
0000145A                           453  
0000145A                           454      
0000145A                           455      *now to print size  
0000145A  B47C 0002                456      cmp #2,D2 *if the size is 2 branch to long
0000145E  6700 FE80                457      BEQ long
00001462  B47C 0001                458      cmp #1,D2 *if the size is 1 branch to word
00001466  6700 FE64                459      BEQ word
0000146A  6100 FE4C                460      BSR byte *otherwise branch to byte
0000146E  6100 06EA                461          BSR ADDQ_EA
00001472                           462  
00001472  6000 FE42                463      BRA return    
00001476                           464      
00001476                           465      
00001476                           466  add
00001476  13FC 0004 00002337       467      MOVE.B  #4,(OutputType)
0000147E  6100 0AD4                468      BSR     OUTPUT
00001482                           469  
00001482  43F9 0000235A            470      LEA    addout,A1
00001488  13FC 0001 00002337       471      MOVE.B  #1,(OutputType)       
00001490  6100 0AC2                472      BSR    OUTPUT
00001494                           473      
00001494  3412                     474      MOVE.W (A2),D2
00001496  0242 00C0                475      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000149A  EC4A                     476      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000149C                           477  
0000149C                           478  
0000149C                           479      
0000149C                           480      *now to print size  
0000149C  B47C 0002                481      cmp #2,D2 *if the size is 2 branch to long
000014A0  6700 FE3E                482      BEQ long
000014A4  B47C 0001                483      cmp #1,D2 *if the size is 1 branch to word
000014A8  6700 FE22                484      BEQ word
000014AC  6100 FE0A                485      BSR byte *otherwise branch to byte
000014B0  6100 05C0                486          BSR EA_GROUP1
000014B4                           487  
000014B4  6000 FE00                488      BRA return
000014B8                           489  
000014B8                           490  adda
000014B8                           491  
000014B8  13FC 0004 00002337       492      MOVE.B  #4,(OutputType)
000014C0  6100 0A92                493      BSR     OUTPUT
000014C4                           494  
000014C4  43F9 0000235E            495      LEA    addaout,A1
000014CA  13FC 0001 00002337       496      MOVE.B  #1,(OutputType)       
000014D2  6100 0A80                497      BSR    OUTPUT
000014D6                           498      
000014D6  3412                     499      MOVE.W (A2),D2
000014D8  0242 0100                500      ANDI.W #%0000000100000000, D2 * set to only the size bit
000014DC  E04A                     501      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
000014DE                           502  
000014DE                           503  
000014DE                           504      
000014DE                           505      *now to print size  
000014DE  B47C 0001                506      cmp #1,D2 *if the size is 1 branch to long
000014E2  6700 FDFC                507      BEQ long
000014E6  B47C 0000                508      cmp #0,D2 *if the size is 0 branch to word
000014EA  6700 FDE0                509      BEQ word
000014EE  6100 062E                510          BSR EA_GROUP4
000014F2                           511     
000014F2  6000 FDC2                512      BRA return
000014F6                           513  
000014F6                           514      
000014F6                           515  rts
000014F6  13FC 0004 00002337       516      MOVE.B  #4,(OutputType)
000014FE  6100 0A54                517      BSR     OUTPUT
00001502                           518  
00001502  43F9 0000239F            519      LEA    rtsout,A1
00001508  13FC 0001 00002337       520      MOVE.B  #1,(OutputType)       
00001510  6100 0A42                521      BSR    OUTPUT
00001514  6100 05A6                522          BSR EA_GROUP2
00001518                           523  
00001518  6000 FD9C                524      BRA return
0000151C                           525      
0000151C                           526      
0000151C                           527  jsr 
0000151C  13FC 0004 00002337       528      MOVE.B  #4,(OutputType)
00001524  6100 0A2E                529      BSR     OUTPUT
00001528                           530     
00001528  43F9 0000239B            531      LEA    jsrout,A1
0000152E  13FC 0001 00002337       532      MOVE.B  #1,(OutputType)       
00001536  6100 0A1C                533      BSR    OUTPUT
0000153A  6100 0580                534          BSR EA_GROUP2
0000153E                           535  
0000153E  6000 FD76                536      BRA return
00001542                           537      
00001542                           538      
00001542                           539  not 
00001542  13FC 0004 00002337       540      MOVE.B  #4,(OutputType)
0000154A  6100 0A08                541      BSR     OUTPUT
0000154E                           542    
0000154E  43F9 0000236C            543      LEA    notout,A1
00001554  13FC 0001 00002337       544      MOVE.B  #1,(OutputType)       
0000155C  6100 09F6                545      BSR    OUTPUT
00001560                           546      
00001560  3412                     547      MOVE.W (A2),D2
00001562  0242 00C0                548      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001566  EC4A                     549      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001568                           550  
00001568                           551      *now to print size  
00001568  B47C 0002                552      cmp #2,D2 *if the size is 2 branch to long
0000156C  6700 FD72                553      BEQ long
00001570  B47C 0001                554      cmp #1,D2 *if the size is 1 branch to word
00001574  6700 FD56                555      BEQ word
00001578  6100 FD3E                556      BSR byte *otherwise branch to byte
0000157C                           557      
0000157C  6100 0584                558      BSR EA_GROUP3
00001580                           559      
00001580  6000 FD34                560      BRA return
00001584                           561  
00001584                           562  lsl
00001584  13FC 0004 00002337       563      MOVE.B  #4,(OutputType)
0000158C  6100 09C6                564      BSR     OUTPUT
00001590                           565  
00001590  43F9 00002377            566      LEA    lslout,A1
00001596  13FC 0001 00002337       567      MOVE.B  #1,(OutputType)       
0000159E  6100 09B4                568      BSR    OUTPUT
000015A2                           569      
000015A2  3412                     570      MOVE.W (A2),D2
000015A4  0242 00C0                571      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015A8  EC4A                     572      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015AA                           573  
000015AA                           574  
000015AA                           575      
000015AA                           576      *now to print size  
000015AA  B47C 0002                577      cmp #2,D2 *if the size is 2 branch to long
000015AE  6700 FD30                578      BEQ long
000015B2  B47C 0001                579      cmp #1,D2 *if the size is 1 branch to word
000015B6  6700 FD14                580      BEQ word
000015BA  6100 FCFC                581      BSR byte *otherwise branch to byte
000015BE  6100 04FC                582          BSR EA_GROUP2
000015C2                           583  
000015C2  6000 FCF2                584      BRA return
000015C6                           585  
000015C6                           586  lsr
000015C6  13FC 0004 00002337       587      MOVE.B  #4,(OutputType)
000015CE  6100 0984                588      BSR     OUTPUT
000015D2                           589  
000015D2  43F9 0000237B            590      LEA    lsrout,A1
000015D8  13FC 0001 00002337       591      MOVE.B  #1,(OutputType)       
000015E0  6100 0972                592      BSR    OUTPUT
000015E4                           593      
000015E4  3412                     594      MOVE.W (A2),D2
000015E6  0242 00C0                595      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015EA  EC4A                     596      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015EC                           597  
000015EC                           598  
000015EC                           599      
000015EC                           600      *now to print size  
000015EC  B47C 0002                601      cmp #2,D2 *if the size is 2 branch to long
000015F0  6700 FCEE                602      BEQ long
000015F4  B47C 0001                603      cmp #1,D2 *if the size is 1 branch to word
000015F8  6700 FCD2                604      BEQ word
000015FC  6100 FCBA                605      BSR byte *otherwise branch to byte
00001600  6100 04BA                606          BSR EA_GROUP2
00001604                           607  
00001604  6000 FCB0                608      BRA return
00001608                           609  asl
00001608  13FC 0004 00002337       610      MOVE.B  #4,(OutputType)
00001610  6100 0942                611      BSR     OUTPUT
00001614                           612  
00001614  43F9 0000237F            613      LEA    aslout,A1
0000161A  13FC 0001 00002337       614      MOVE.B  #1,(OutputType)       
00001622  6100 0930                615      BSR    OUTPUT
00001626                           616      
00001626  3412                     617      MOVE.W (A2),D2
00001628  0242 00C0                618      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000162C  EC4A                     619      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000162E                           620  
0000162E                           621  
0000162E                           622      
0000162E                           623      *now to print size  
0000162E  B47C 0002                624      cmp #2,D2 *if the size is 2 branch to long
00001632  6700 FCAC                625      BEQ long
00001636  B47C 0001                626      cmp #1,D2 *if the size is 1 branch to word
0000163A  6700 FC90                627      BEQ word
0000163E  6100 FC78                628      BSR byte *otherwise branch to byte
00001642  6100 0478                629          BSR EA_GROUP2
00001646                           630  
00001646  6000 FC6E                631      BRA return
0000164A                           632  
0000164A                           633  asr
0000164A  13FC 0004 00002337       634      MOVE.B  #4,(OutputType)
00001652  6100 0900                635      BSR     OUTPUT
00001656                           636  
00001656  43F9 00002383            637      LEA    asrout,A1
0000165C  13FC 0001 00002337       638      MOVE.B  #1,(OutputType)       
00001664  6100 08EE                639      BSR    OUTPUT
00001668                           640      
00001668  3412                     641      MOVE.W (A2),D2
0000166A  0242 00C0                642      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000166E  EC4A                     643      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001670                           644  
00001670                           645  
00001670                           646      
00001670                           647      *now to print size  
00001670  B47C 0002                648      cmp #2,D2 *if the size is 2 branch to long
00001674  6700 FC6A                649      BEQ long
00001678  B47C 0001                650      cmp #1,D2 *if the size is 1 branch to word
0000167C  6700 FC4E                651      BEQ word
00001680  6100 FC36                652      BSR byte *otherwise branch to byte
00001684  6100 0436                653          BSR EA_GROUP2
00001688                           654  
00001688  6000 FC2C                655      BRA return
0000168C                           656      
0000168C                           657  rol
0000168C  13FC 0004 00002337       658      MOVE.B  #4,(OutputType)
00001694  6100 08BE                659      BSR     OUTPUT
00001698                           660  
00001698  43F9 00002387            661      LEA    rolout,A1
0000169E  13FC 0001 00002337       662      MOVE.B  #1,(OutputType)       
000016A6  6100 08AC                663      BSR    OUTPUT
000016AA                           664      
000016AA  3412                     665      MOVE.W (A2),D2
000016AC  0242 00C0                666      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016B0  EC4A                     667      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016B2                           668  
000016B2                           669  
000016B2                           670      
000016B2                           671      *now to print size  
000016B2  B47C 0002                672      cmp #2,D2 *if the size is 2 branch to long
000016B6  6700 FC28                673      BEQ long
000016BA  B47C 0001                674      cmp #1,D2 *if the size is 1 branch to word
000016BE  6700 FC0C                675      BEQ word
000016C2  6100 FBF4                676      BSR byte *otherwise branch to byte
000016C6  6100 03F4                677          BSR EA_GROUP2
000016CA                           678  
000016CA  6000 FBEA                679      BRA return
000016CE                           680  
000016CE                           681  ror
000016CE  13FC 0004 00002337       682      MOVE.B  #4,(OutputType)
000016D6  6100 087C                683      BSR     OUTPUT
000016DA                           684  
000016DA  43F9 0000238B            685      LEA    rorout,A1
000016E0  13FC 0001 00002337       686      MOVE.B  #1,(OutputType)       
000016E8  6100 086A                687      BSR    OUTPUT
000016EC                           688      
000016EC  3412                     689      MOVE.W (A2),D2
000016EE  0242 00C0                690      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016F2  EC4A                     691      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016F4                           692  
000016F4                           693  
000016F4                           694      
000016F4                           695      *now to print size  
000016F4  B47C 0002                696      cmp #2,D2 *if the size is 2 branch to long
000016F8  6700 FBE6                697      BEQ long
000016FC  B47C 0001                698      cmp #1,D2 *if the size is 1 branch to word
00001700  6700 FBCA                699      BEQ word
00001704  6100 FBB2                700      BSR byte *otherwise branch to byte
00001708  6100 03B2                701          BSR EA_GROUP2
0000170C                           702  
0000170C  6000 FBA8                703      BRA return
00001710                           704      
00001710                           705      
00001710                           706  
00001710                           707  lea
00001710  13FC 0004 00002337       708      MOVE.B  #4,(OutputType)
00001718  6100 083A                709      BSR     OUTPUT
0000171C                           710  
0000171C  43F9 00002368            711      LEA    leaout,A1
00001722  13FC 0001 00002337       712      MOVE.B  #1,(OutputType)       
0000172A  6100 0828                713      BSR    OUTPUT
0000172E  6100 03EE                714          BSR EA_GROUP4
00001732                           715  
00001732  6000 FB82                716      BRA return
00001736                           717      
00001736                           718  or
00001736  13FC 0004 00002337       719      MOVE.B  #4,(OutputType)
0000173E  6100 0814                720      BSR     OUTPUT
00001742                           721  
00001742  43F9 00002370            722      LEA    orout,A1
00001748  13FC 0001 00002337       723      MOVE.B  #1,(OutputType)       
00001750  6100 0802                724      BSR    OUTPUT
00001754                           725      
00001754                           726          
00001754  3412                     727      MOVE.W (A2),D2
00001756  0242 00C0                728      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000175A  EC4A                     729      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000175C                           730  
0000175C                           731      *now to print size  
0000175C  B47C 0002                732      cmp #2,D2 *if the size is 2 branch to long
00001760  6700 FB7E                733      BEQ long
00001764  B47C 0001                734      cmp #1,D2 *if the size is 1 branch to word
00001768  6700 FB62                735      BEQ word
0000176C  6100 FB4A                736      BSR byte *otherwise branch to byte
00001770  6100 0300                737      BSR EA_GROUP1
00001774  6000 FB40                738      BRA return
00001778                           739      
00001778                           740  and
00001778  13FC 0004 00002337       741      MOVE.B  #4,(OutputType)
00001780  6100 07D2                742      BSR     OUTPUT
00001784                           743  
00001784  43F9 00002373            744      LEA    andout,A1
0000178A  13FC 0001 00002337       745      MOVE.B  #1,(OutputType)       
00001792  6100 07C0                746      BSR    OUTPUT
00001796                           747      
00001796                           748          
00001796  3412                     749      MOVE.W (A2),D2
00001798  0242 00C0                750      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000179C  EC4A                     751      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000179E                           752  
0000179E                           753      *now to print size  
0000179E  B47C 0002                754      cmp #2,D2 *if the size is 2 branch to long
000017A2  6700 FB3C                755      BEQ long
000017A6  B47C 0001                756      cmp #1,D2 *if the size is 1 branch to word
000017AA  6700 FB20                757      BEQ word
000017AE  6100 FB08                758      BSR byte *otherwise branch to byte
000017B2  6100 02BE                759      BSR EA_GROUP1
000017B6  6000 FAFE                760      BRA return    
000017BA                           761  
000017BA                           762  bcc
000017BA  4243                     763      CLR D3
000017BC  3612                     764      MOVE.W (A2), D3
000017BE                           765      
000017BE  0243 0F00                766      ANDI.W #%0000111100000000,D3 * bits [11-8]
000017C2  E04B                     767      LSR.W #8,D3
000017C4  B67C 000E                768      CMP #%1110, D3 * BGT compare
000017C8  6700 0016                769      BEQ bgt
000017CC  B67C 000F                770      CMP #%1111, D3 * BLE compare
000017D0  6700 0030                771      BEQ ble
000017D4  B67C 0007                772      CMP #%0111, D3 * BEQ compare
000017D8  6700 004A                773      BEQ beq
000017DC  6000 008A                774      BRA data * goto data if doesn't work
000017E0                           775  
000017E0                           776  bgt
000017E0  13FC 0004 00002337       777      MOVE.B  #4,(OutputType)
000017E8  6100 076A                778      BSR     OUTPUT
000017EC                           779  
000017EC  43F9 0000238F            780      LEA    bgtout,A1
000017F2  13FC 0001 00002337       781      MOVE.B  #1,(OutputType)       
000017FA  6100 0758                782      BSR    OUTPUT
000017FE  6000 FAB6                783      BRA return
00001802                           784  
00001802                           785  ble
00001802  13FC 0004 00002337       786      MOVE.B  #4,(OutputType)
0000180A  6100 0748                787      BSR     OUTPUT
0000180E                           788  
0000180E  43F9 00002393            789      LEA    bleout,A1
00001814  13FC 0001 00002337       790      MOVE.B  #1,(OutputType)       
0000181C  6100 0736                791      BSR    OUTPUT
00001820  6000 FA94                792      BRA return
00001824                           793  beq
00001824  13FC 0004 00002337       794      MOVE.B  #4,(OutputType)
0000182C  6100 0726                795      BSR     OUTPUT
00001830                           796  
00001830  43F9 00002397            797      LEA    beqout,A1
00001836  13FC 0001 00002337       798      MOVE.B  #1,(OutputType)       
0000183E  6100 0714                799      BSR    OUTPUT
00001842  6000 FA72                800      BRA return
00001846                           801  
00001846                           802  bra
00001846  13FC 0004 00002337       803      MOVE.B  #4,(OutputType)
0000184E  6100 0704                804      BSR     OUTPUT
00001852                           805  
00001852  43F9 000023A5            806      LEA    braout,A1
00001858  13FC 0001 00002337       807      MOVE.B  #1,(OutputType)       
00001860  6100 06F2                808      BSR    OUTPUT
00001864  6000 FA50                809      BRA return
00001868                           810  
00001868                           811  data
00001868  13FC 0004 00002337       812      MOVE.B  #4,(OutputType)
00001870  6100 06E2                813      BSR     OUTPUT
00001874                           814  
00001874  43F9 000023A9            815      LEA    dataout,A1
0000187A  13FC 0001 00002337       816      MOVE.B  #1,(OutputType)       
00001882  6100 06D0                817      BSR    OUTPUT
00001886                           818      
00001886  13FC 0003 00002337       819      MOVE.B  #3,(OutputType)       
0000188E  6100 06C4                820      BSR    OUTPUT     
00001892  6000 FA22                821      BRA return
00001896                           822  
00001896                           823  
00001896                           824  **********************************************************
00001896                           825  *Subroutine: USERINPUT
00001896                           826  *What it does: Takes in user input, rejects bad input
00001896                           827  *Registers: Uses register A1, D0, D5
00001896                           828  *A1: Stores messages and user input
00001896                           829  *D0: Used for TRAP #15
00001896                           830  *D5: Temporaraly stores user input to be masked then transfered
00001896                           831  *Paramemeters: No parameters
00001896                           832  **********************************************************
00001896                           833  USERINPUT:
00001896  4281                     834      CLR.L   D1
00001898  4282                     835      CLR.L   D2
0000189A  4283                     836      CLR.L   D3
0000189C  4284                     837      CLR.L   D4
0000189E  4285                     838      CLR.L   D5
000018A0  0C39 0000 00002338       839      CMP.B   #0,(RepeatFlag)
000018A8  6700 001A                840      BEQ     welcomeExplanation
000018AC  6000 0030                841      BRA     firstInput
000018B0  02B9 00000000 00008000   842      AND.L   #$00000000,(Input1)
000018BA  02B9 00000000 00008004   843      AND.L   #$00000000,(Input2)
000018C4                           844      
000018C4                           845  welcomeExplanation
000018C4  43F9 000020AA            846      LEA     STARTMESSAGE,A1         
000018CA  103C 000E                847      MOVE.B  #14,D0
000018CE  4E4F                     848      TRAP    #15
000018D0                           849      
000018D0  5039 00002336            850      ADD.B   #8,(LineCounter)
000018D6  13FC 0001 00002338       851      MOVE.B  #1,(RepeatFlag)
000018DE                           852  
000018DE                           853  firstInput
000018DE  43F9 0000221C            854      LEA     INPUT1MESSAGE,A1        
000018E4  103C 000E                855      MOVE.B  #14,D0                  
000018E8  4E4F                     856      TRAP    #15                     Asks user for first input
000018EA  5239 00002336            857      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000018F0                           858      
000018F0  43F9 00008008            859      LEA     userInputStored,A1
000018F6  103C 0002                860      MOVE.B  #2,D0                   
000018FA  4E4F                     861      TRAP    #15                     User can input string for address
000018FC  5239 00002336            862      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001902                           863  
00001902                           864      
00001902  6100 00BC                865      BSR     CONVERTATOH                 String converted to hex address
00001906                           866      
00001906  0C39 0000 00002335       867      CMP.B   #0,(InputQuality)       Checks if bad input flag set
0000190E  6700 0014                868      BEQ     throwInput1CharError
00001912                           869  
00001912                           870      
00001912  CABC 00FFFFFF            871      AND.L   #$00FFFFFF,D5
00001918  23C5 00008000            872      MOVE.L  D5,input1               Moves result into input 1 memory location
0000191E  4285                     873      CLR.L   D5                      Clears D5 for future use
00001920  6000 0020                874      BRA     secondInput
00001924                           875      
00001924                           876  throwInput1CharError
00001924  43F9 00002268            877      LEA     INPUTERRORBADCHAR,A1
0000192A  103C 000E                878      MOVE.B  #14,D0
0000192E  4E4F                     879      TRAP    #15                     Outputs bad character error message
00001930  5639 00002336            880      ADD.B   #3,(LineCounter)        Adds 2 to line counter
00001936                           881      
00001936  13FC 0001 00002335       882      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
0000193E  4285                     883      CLR.L   D5                      Clears D5 for future use
00001940                           884      
00001940                           885      
00001940                           886      
00001940  609C                     887      BRA     firstInput              Tries again for input1
00001942                           888  
00001942                           889      
00001942                           890  secondInput
00001942  43F9 00002242            891      LEA     INPUT2MESSAGE,A1        
00001948  103C 000E                892      MOVE.B  #14,D0                  
0000194C  4E4F                     893      TRAP    #15                     Asks user for second input
0000194E  5239 00002336            894      ADD.B   #1,(LineCounter)
00001954                           895      
00001954  43F9 00008008            896      LEA     userInputStored,A1
0000195A  103C 0002                897      MOVE.B  #2,D0                   
0000195E  4E4F                     898      TRAP    #15                     User can input string for address
00001960  5239 00002336            899      ADD.B   #1,(LineCounter)
00001966                           900  
00001966                           901      
00001966  6100 0058                902      BSR     CONVERTATOH                 String converted to hex address
0000196A                           903  
0000196A  0C39 0000 00002335       904      CMP.B   #0,(InputQuality)       
00001972  6700 001C                905      BEQ     throwInput2CharError    Checks if bad input flag set
00001976                           906      
00001976  CABC 00FFFFFF            907      AND.L   #$00FFFFFF,D5
0000197C  BAB9 00008000            908      CMP.L   (input1),D5
00001982  6D00 0028                909      BLT     throwInput2LowerError
00001986                           910      
00001986                           911      
00001986                           912      
00001986  23C5 00008004            913      MOVE.L  D5,input2               Moves result into input 2 memory location
0000198C  4285                     914      CLR.L   D5                      Clears D5 for future use
0000198E  4E75                     915      RTS    
00001990                           916      
00001990                           917  throwInput2CharError
00001990  43F9 00002268            918      LEA     INPUTERRORBADCHAR,A1    
00001996  103C 000E                919      MOVE.B  #14,D0
0000199A  4E4F                     920      TRAP    #15                     Outputs bad character error message
0000199C                           921      
0000199C  5639 00002335            922      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
000019A2  4285                     923      CLR.L   D5                      Clears D5 for future use
000019A4                           924      
000019A4  5639 00002336            925      ADD.B   #3,(LineCounter)
000019AA                           926      
000019AA  6096                     927      BRA     secondInput             Tries again for input2
000019AC                           928      
000019AC                           929  throwInput2LowerError
000019AC  43F9 00002286            930      LEA     INPUTERROR2SMALLER,A1
000019B2  103C 000E                931      MOVE.B  #14,D0
000019B6  4E4F                     932      TRAP    #15
000019B8                           933      
000019B8  5639 00002336            934      ADD.B   #3,(LineCounter)
000019BE                           935      
000019BE  6082                     936      BRA     secondInput
000019C0                           937  
000019C0                           938  
000019C0                           939  **********************************************************
000019C0                           940  *Subroutine: CONVERTATOH
000019C0                           941  *What it does: Converts user input to hex code
000019C0                           942  *Registers: Uses register A1, D2, D5
000019C0                           943  *Paramemeters: User input stored in (A1)
000019C0                           944  ********************************************************** 
000019C0                           945  CONVERTATOH:
000019C0                           946      
000019C0                           947  AtoH
000019C0  1419                     948      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
000019C2                           949      
000019C2  B43C 0000                950      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
000019C6  6700 004C                951      BEQ     Finish                  Moves to finish if they are equal (no more input)
000019CA                           952      
000019CA  E985                     953      ASL.L   #4,D5
000019CC                           954      
000019CC  B43C 0030                955      CMP.B   #$30,D2
000019D0  6D00 0044                956      BLT     inputError
000019D4                           957      
000019D4  B43C 0039                958      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
000019D8  6E00 000A                959      BGT     upperCase               Branches if greater, may or may not be a letter in hex
000019DC                           960      
000019DC  0402 0030                961      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
000019E0  DA02                     962      ADD.B   D2,D5
000019E2                           963      
000019E2  60DC                     964      BRA     AtoH
000019E4                           965  
000019E4                           966          
000019E4                           967  upperCase   
000019E4  B43C 0041                968      CMP.B   #$41,D2
000019E8  6D00 002C                969      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
000019EC                           970      
000019EC  B43C 0046                971      CMP.B   #$46,D2                 
000019F0  6E00 000A                972      BGT     lowerCase               Greater than 46 may be hex code in lowercase
000019F4                           973      
000019F4  0402 0037                974      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
000019F8  DA02                     975      ADD.B   D2,D5
000019FA  60C4                     976      BRA     AtoH
000019FC                           977  
000019FC                           978  lowerCase
000019FC  B43C 0061                979      CMP.B   #$61,D2
00001A00  6D00 0014                980      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001A04                           981      
00001A04  B43C 0066                982      CMP.B   #$66,D2
00001A08  6E00 000C                983      BGT     InputError              Greater than 66 is not part of hex code
00001A0C                           984      
00001A0C  0402 0057                985      SUBI.B  #$57,D2
00001A10  DA02                     986      ADD.B   D2,D5
00001A12  60AC                     987      BRA     AtoH
00001A14                           988          
00001A14                           989  Finish
00001A14  4E75                     990      RTS                             Return from CONVERT
00001A16                           991      
00001A16                           992  inputError
00001A16  13FC 0000 00002335       993      MOVE.B  #0,(InputQuality)
00001A1E  4E75                     994      RTS
00001A20                           995  
00001A20                           996  *********************************************************************
00001A20                           997  *Subroutine: EA
00001A20                           998  *What it does: Outputs parts of opword, moves to new screen if needed
00001A20                           999  *Registers: Uses register A1, D0,
00001A20                          1000  *A1: Used to store messages and single char
00001A20                          1001  *Paramemeters: A1
00001A20                          1002  *A1: Stores what should be used
00001A20                          1003  *********************************************************************  
00001A20  =0000003F               1004  BITS0TO5_MASK   EQU %00111111
00001A20  =000000C0               1005  BITS7TO8_MASK   EQU %11000000
00001A20  =00000E00               1006  BITS9TO11_MASK  EQU %00000111000000000
00001A20                          1007  
00001A20  1E3C 000A               1008  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001A24  BC7C 0000               1009                          CMP     #0,D6
00001A28  6700 0006               1010                          BEQ     IMMEDIATE0
00001A2C  6000 0004               1011                          BRA     IMMEDIATE_END
00001A30  7C08                    1012  IMMEDIATE0              MOVEQ   #8,D6
00001A32                          1013  
00001A32  4E75                    1014  IMMEDIATE_END           RTS
00001A34                          1015  
00001A34  3212                    1016  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001A36  0201 003F               1017                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001A3A  0001 00C0               1018                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
00001A3E  1C01                    1019                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001A40  3212                    1020                  MOVE.W  (A2),D1         
00001A42  3412                    1021                  MOVE.W  (A2),D2 
00001A44  0241 0E00               1022                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001A48  163C 0009               1023                  MOVE.B  #9,D3                   * Prepare shift count
00001A4C  E669                    1024                  LSR.W   D3,D1                   * Move destination register bits right
00001A4E  0242 01C0               1025                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001A52  E64A                    1026                  LSR.W   #3,D2                  * Move destination mode bits right
00001A54  8242                    1027                  OR.W    D2,D1
00001A56  1A01                    1028                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001A58  1206                    1029                  MOVE.B  D6,D1               * Pass source into subroutine
00001A5A  4EB9 00001C1C           1030                  JSR     CHECK_VALID_EA
00001A60  1205                    1031                  MOVE.B  D5,D1               * Pass destination into subroutine
00001A62  4EB9 00001C1C           1032                  JSR     CHECK_VALID_EA
00001A68  6100 01F6               1033                  BSR print_EA
00001A6C  6100 0496               1034                  BSR print_NEWLINE
00001A70                          1035                  
00001A70  4E75                    1036                  RTS
00001A72                          1037  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001A72  3212                    1038  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001A74  3412                    1039          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001A76  0201 003F               1040          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001A7A                          1041          
00001A7A  0242 0E00               1042          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001A7E  163C 0009               1043          MOVE.B  #9,D3                   * Prepare shift count
00001A82  E66A                    1044          LSR.W   D3,D2                   * Move register bits right
00001A84  0202 00C7               1045          ANDI.B  #%11000111,D2           * Set EA mode
00001A88  3612                    1046          MOVE.W  (A2),D3
00001A8A  0803 0008               1047          BTST    #8,D3                   * Check opmode
00001A8E  6700 000A               1048          BEQ     EA1_MODE_ZERO           * Check opmode
00001A92                          1049          
00001A92  3A01                    1050  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001A94  3C02                    1051                  MOVE.W  D2,D6           * Set register as source
00001A96  6000 0006               1052                  BRA EA1_END             * Complete subroutine
00001A9A                          1053          
00001A9A  3C01                    1054  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001A9C  3A02                    1055                  MOVE.W  D2,D5           * Set register as destination
00001A9E                          1056  
00001A9E  0006 00C0               1057  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001AA2  1206                    1058                  MOVE.B  D6,D1               * Pass source into subroutine
00001AA4  4EB9 00001C1C           1059                  JSR     CHECK_VALID_EA
00001AAA  1205                    1060                  MOVE.B  D5,D1               * Pass destination into subroutine
00001AAC  4EB9 00001C1C           1061                  JSR     CHECK_VALID_EA
00001AB2  6100 01AC               1062                  BSR print_EA
00001AB6  6100 044C               1063                  BSR print_NEWLINE
00001ABA                          1064  
00001ABA  4E75                    1065                  RTS
00001ABC                          1066  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001ABC  3C12                    1067  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001ABE  0246 0E00               1068                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001AC2  163C 0009               1069                  MOVE.B  #9,D3                   * Prepare shift count
00001AC6  E66E                    1070                  LSR.W   D3,D6                   * Move register bits right
00001AC8  3612                    1071                  MOVE.W  (A2),D3
00001ACA  0803 0005               1072                  BTST    #5,D3           * Check whether shift count is immediate
00001ACE  6700 000A               1073                  BEQ     EA2_IMMEDIATE
00001AD2                          1074   
00001AD2  0006 00C0               1075  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001AD6  6000 000A               1076                  BRA     EA2_END         * Complete subroutine
00001ADA                          1077                  
00001ADA  1E3C 000A               1078  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001ADE  4EB8 1A20               1079                  JSR     FORMAT_IMMEDIATE_DATA
00001AE2                          1080                  
00001AE2  3A12                    1081  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001AE4  CA3C 0007               1082                  AND.B   #%00000111,D5
00001AE8  1206                    1083                  MOVE.B  D6,D1               * Pass source into subroutine
00001AEA  4EB9 00001C1C           1084                  JSR     CHECK_VALID_EA
00001AF0  1205                    1085                  MOVE.B  D5,D1               * Pass destination into subroutine
00001AF2  4EB9 00001C1C           1086                  JSR     CHECK_VALID_EA
00001AF8  6100 0166               1087                  BSR print_EA
00001AFC  6100 0406               1088                  BSR print_NEWLINE
00001B00  4E75                    1089                  RTS   
00001B02                          1090  
00001B02                          1091  
00001B02                          1092  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001B02  3C12                    1093  EA_GROUP3     MOVE.W  (A2),D6
00001B04  0206 003F               1094          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001B08  0006 0080               1095          ORI.B   #%10000000,D6
00001B0C  1206                    1096          MOVE.B  D6,D1               * Pass source into subroutine
00001B0E  4EB9 00001C1C           1097          JSR     CHECK_VALID_EA
00001B14  6100 014A               1098          BSR print_EA
00001B18  6100 03EA               1099          BSR print_NEWLINE
00001B1C  4E75                    1100          RTS
00001B1E                          1101  
00001B1E                          1102  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001B1E  3212                    1103  EA_GROUP4     MOVE.W  (A2),D1         
00001B20  0201 003F               1104          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001B24  0001 00C0               1105          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001B28  1C01                    1106          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001B2A  3212                    1107          MOVE.W  (A2),D1         
00001B2C                          1108          
00001B2C  0241 0E00               1109          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001B30  143C 0009               1110          MOVE.B  #9,D2                   * Prepare shift count
00001B34  E469                    1111          LSR.W   D2,D1                   * Move register bits right
00001B36  0201 00CF               1112          ANDI.B  #%11001111,D1           * Set destination mode
00001B3A  0001 0008               1113          ORI.B   #%00001000,D1           * Set destination mode
00001B3E  1A01                    1114          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001B40  1206                    1115          MOVE.B  D6,D1               * Pass source into subroutine
00001B42  4EB9 00001C1C           1116          JSR     CHECK_VALID_EA
00001B48  1205                    1117          MOVE.B  D5,D1               * Pass destination into subroutine
00001B4A  4EB9 00001C1C           1118          JSR     CHECK_VALID_EA
00001B50  6100 010E               1119          BSR print_EA
00001B54  6100 03AE               1120          BSR print_NEWLINE
00001B58  4E75                    1121          RTS
00001B5A                          1122          
00001B5A  3C12                    1123  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001B5C  0246 0E00               1124          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001B60  163C 0009               1125          MOVE.B  #9,D3                   * Prepare shift count
00001B64  E66E                    1126          LSR.W   D3,D6                  * Move source data bits right            !---
00001B66  3A12                    1127          MOVE.W  (A2),D5                 * Prepare destination bits
00001B68  0205 003F               1128          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001B6C  4EB8 1A20               1129          JSR     FORMAT_IMMEDIATE_DATA
00001B70  1206                    1130          MOVE.B  D6,D1               * Pass source into subroutine
00001B72  4EB9 00001C1C           1131          JSR     CHECK_VALID_EA
00001B78  1205                    1132          MOVE.B  D5,D1               * Pass destination into subroutine
00001B7A  4EB9 00001C1C           1133          JSR     CHECK_VALID_EA
00001B80  4E75                    1134          RTS                                    !---
00001B82                          1135          
00001B82  3C12                    1136  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001B84  CC7C 00FF               1137              AND.W   #$00FF,D6                                                   !---
00001B88  3A12                    1138              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001B8A  0245 0E00               1139              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001B8E  163C 0009               1140              MOVE.B  #9,D3                   * Prepare shift count
00001B92  E66D                    1141              LSR.W   D3,D5                   * Move destination register bits right
00001B94  1E3C 000A               1142              MOVE.B  #10,D7
00001B98  1206                    1143              MOVE.B  D6,D1               * Pass source into subroutine
00001B9A  4EB9 00001C1C           1144              JSR     CHECK_VALID_EA
00001BA0  1205                    1145              MOVE.B  D5,D1               * Pass destination into subroutine
00001BA2  4EB9 00001C1C           1146              JSR     CHECK_VALID_EA
00001BA8  4E75                    1147              RTS                                 !---
00001BAA                          1148  
00001BAA                          1149  
00001BAA                          1150  
00001BAA                          1151  
00001BAA  3412                    1152  MOVEM_EA   MOVE.W (A2),D2
00001BAC  0802 000A               1153             BTST    #10, D2
00001BB0  6700 003E               1154             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001BB4                          1155            
00001BB4                          1156             
00001BB4                          1157                  
00001BB4                          1158  *ELSE IT IS  memory-to-register transfers
00001BB4                          1159  
00001BB4                          1160  
00001BB4                          1161  
00001BB4                          1162  
00001BB4                          1163     
00001BB4  E68A                    1164  Memory_to_Register LSR.L #3, D2
00001BB6  C43C 0007               1165                     AND.B #$07, D2
00001BBA  B43C 0002               1166                     CMP.B #$2,D2
00001BBE  6700 0022               1167                     BEQ   MODE_010
00001BC2  B43C 0003               1168                     CMP.B #$03, D2
00001BC6  6700 001A               1169                     BEQ   MODE_010  
00001BCA  B43C 0007               1170                     CMP.B #$07,D2
00001BCE  6700 0012               1171                     BEQ   MODE_010  
00001BD2  4EF9 00001BD8           1172                     JMP   WRONG_INSTRUCTION    
00001BD8                          1173     
00001BD8  1E3C 0005               1174  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001BDC  2C4A                    1175                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001BDE  3C12                    1176                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001BE0  4E75                    1177                               RTS 
00001BE2                          1178             
00001BE2  3412                    1179  MODE_010  MOVE.W    (A2),D2
00001BE4  C43C 003F               1180            AND.B     #$3F,D2
00001BE8  08C2 0007               1181            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001BEC  1C02                    1182            MOVE.B    D2,D6
00001BEE  4E75                    1183            RTS
00001BF0                          1184  
00001BF0  3412                    1185  Register_to_memory MOVE.W (A2),D2
00001BF2  E68A                    1186                     LSR.L #3, D2
00001BF4  C43C 0007               1187                     AND.B #$07, D2
00001BF8  B43C 0002               1188                     CMP.B #$2,D2
00001BFC  6700 0016               1189                     BEQ   MODE_01_0
00001C00  B43C 0004               1190                     CMP.B #$04, D2
00001C04  6700 000E               1191                     BEQ   MODE_01_0 
00001C08  B43C 0007               1192                     CMP.B #$07,D2
00001C0C  6700 0006               1193                     BEQ   MODE_01_0 
00001C10  4EF8 1BD8               1194                     JMP   WRONG_INSTRUCTION
00001C14                          1195                     
00001C14                          1196  
00001C14  3C12                    1197  MODE_01_0       MOVE.W  (A2),D6
00001C16  0206 003F               1198                  ANDI.B  #$3F,D6
00001C1A  4E75                    1199                  RTS
00001C1C                          1200           
00001C1C  1001                    1201  CHECK_VALID_EA  MOVE.B  D1,D0
00001C1E  0200 0038               1202                  ANDI.B  #%111000,D0
00001C22  E648                    1203                  LSR     #3,D0
00001C24  B03C 0005               1204                  CMP.B   #%00000101,D0
00001C28  6700 002C               1205                  BEQ     INVALID_EA
00001C2C  B03C 0006               1206                  CMP.B   #%00000110,D0
00001C30  6700 0024               1207                  BEQ     INVALID_EA
00001C34  B03C 0007               1208                  CMP.B   #%00000111,D0
00001C38  6700 0004               1209                  BEQ     VALID_EA_PC
00001C3C  4E75                    1210                  RTS
00001C3E                          1211                  
00001C3E                          1212                  
00001C3E  1001                    1213  VALID_EA_PC     MOVE.B  D1,D0
00001C40  0200 0007               1214                  ANDI.B  #%000111,D0
00001C44  B03C 0010               1215                  CMP.B   #%00010000,D0
00001C48  6700 000C               1216                  BEQ     INVALID_EA
00001C4C  B03C 0018               1217                  CMP.B   #%00011000,D0
00001C50  6700 0004               1218                  BEQ     INVALID_EA
00001C54  4E75                    1219                  RTS
00001C56                          1220                  
00001C56  4EB8 1BD8               1221  INVALID_EA      JSR     WRONG_INSTRUCTION
00001C5A  3A7C 0005               1222                  MOVE.W  #5, A5
00001C5E  4E75                    1223                  RTS
00001C60                          1224                  
00001C60  48E7 FFDE               1225  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001C64  163C 0038               1226                  MOVE.B  #$38,D3
00001C68  C604                    1227                  AND.B   D4,D3
00001C6A  C83C 0007               1228                  AND.B   #$7, D4
00001C6E                          1229                  
00001C6E  B63C 0000               1230                  CMP.B   #$0, D3
00001C72  6600 0014               1231                  BNE     CHECK_EA_AR
00001C76  0604 00D0               1232                  ADD.B   #$D0, D4
00001C7A  4281                    1233                  CLR.L   D1
00001C7C  1204                    1234                  MOVE.B  D4, D1
00001C7E  4EB9 00001E2A           1235                  JSR     PRINT_REGISTOR              * DATA REG
00001C84  6000 0114               1236                  BRA     PRINT_EA_RETURN
00001C88                          1237  
00001C88  B63C 0008               1238  CHECK_EA_AR         CMP.B   #$8, D3
00001C8C  6600 0014               1239                      BNE     CHECK_EA_INDIRECT
00001C90  0604 00A0               1240                      ADD.B   #$A0, D4
00001C94  4281                    1241                      CLR.L   D1
00001C96  1204                    1242                      MOVE.B  D4, D1
00001C98  4EB9 00001E2A           1243                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001C9E  6000 00FA               1244                      BRA     PRINT_EA_RETURN
00001CA2                          1245                      
00001CA2  B63C 0010               1246  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001CA6  6600 0020               1247                          BNE     CHECK_EA_POST
00001CAA  4EB9 00001E7E           1248                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001CB0  0604 00A0               1249                          ADD.B   #$A0, D4
00001CB4  4281                    1250                          CLR.L   D1
00001CB6  1204                    1251                          MOVE.B  D4, D1
00001CB8  4EB9 00001E2A           1252                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001CBE  4EB9 00001E92           1253                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001CC4  6000 00D4               1254                          BRA     PRINT_EA_RETURN
00001CC8                          1255                          
00001CC8  B63C 0018               1256  CHECK_EA_POST   CMP.B   #$18,D3
00001CCC  6600 0026               1257                  BNE     CHECK_EA_PRE
00001CD0  4EB9 00001E7E           1258                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001CD6  0604 00A0               1259                  ADD.B   #$A0, D4
00001CDA  4281                    1260                  CLR.L   D1
00001CDC  1204                    1261                  MOVE.B  D4, D1
00001CDE  4EB9 00001E2A           1262                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001CE4  4EB9 00001E92           1263                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001CEA  4EB9 00001EAA           1264                  JSR     PRINT_PLUS                  * +
00001CF0  6000 00A8               1265                  BRA     PRINT_EA_RETURN
00001CF4                          1266  
00001CF4  B63C 0020               1267  CHECK_EA_PRE        CMP.B   #$20,D3
00001CF8  6600 0026               1268                      BNE     CHECK_EA_AB_W
00001CFC  4EB9 00001EBE           1269                      JSR     PRINT_MINUS                 * -
00001D02  4EB9 00001E7E           1270                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001D08  0604 00A0               1271                      ADD.B   #$A0, D4
00001D0C  4281                    1272                      CLR.L   D1
00001D0E  1204                    1273                      MOVE.B  D4, D1
00001D10  4EB9 00001E2A           1274                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001D16  4EB9 00001E92           1275                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001D1C  6000 007C               1276                      BRA     PRINT_EA_RETURN
00001D20                          1277  
00001D20  D604                    1278  CHECK_EA_AB_W           ADD.B   D4,D3
00001D22  B63C 0038               1279                          CMP.B   #$38,D3     
00001D26  6600 0018               1280                          BNE     CHECK_EA_AB_L
00001D2A  4EB9 00001F2C           1281                          JSR     PRINT_DOLLAR        * $
00001D30  3A1A                    1282                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001D32  163C 0002               1283                          MOVE.B  #2,D3
00001D36  4EB9 00001DC2           1284                          JSR     PRINT_HEX
00001D3C  6000 005C               1285                          BRA     PRINT_EA_RETURN
00001D40                          1286                          
00001D40  B63C 0039               1287  CHECK_EA_AB_L       CMP.B   #$39, D3
00001D44  6600 0018               1288                      BNE     CHECK_EA_IMM
00001D48  4EB9 00001F2C           1289                      JSR     PRINT_DOLLAR        * $
00001D4E  2A1A                    1290                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001D50  163C 0004               1291                      MOVE.B  #4,D3
00001D54  4EB9 00001DC2           1292                      JSR     PRINT_HEX
00001D5A  6000 003E               1293                      BRA     PRINT_EA_RETURN
00001D5E                          1294                      
00001D5E  BE3C 0004               1295  CHECK_EA_IMM        CMP.B   #4,D7
00001D62  6600 001E               1296                      BNE     READ_WORD_IMM
00001D66  4EB9 00001F18           1297                      JSR     PRINT_HASH_SIGN     * #
00001D6C  4EB9 00001F2C           1298                      JSR     PRINT_DOLLAR        * $
00001D72  2A1A                    1299                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001D74  163C 0004               1300                      MOVE.B  #4,D3
00001D78  4EB9 00001DC2           1301                      JSR     PRINT_HEX
00001D7E  6000 001A               1302                      BRA     PRINT_EA_RETURN
00001D82                          1303                      
00001D82  4EB9 00001F18           1304  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001D88  4EB9 00001F2C           1305                      JSR     PRINT_DOLLAR        * $
00001D8E  3A1A                    1306                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001D90  163C 0002               1307                      MOVE.B  #2,D3
00001D94  4EB9 00001DC2           1308                      JSR     PRINT_HEX
00001D9A                          1309  
00001D9A  4CDF 7BFF               1310  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001D9E  4E75                    1311                      RTS
00001DA0                          1312  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001DA0                          1313  PRINT_BUFFER    DS.B    10
00001DAA= 30 30 30 30 30 30 ...   1314  IPUT_BUFFER_EX  DC.B    '00000000'
00001DB2                          1315  INPUT_BUFFER    DS.B    15                    
00001DC2  48E7 FFFE               1316  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001DC6  43F8 1DA0               1317                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001DCA  D3FC 0000000A           1318                  ADD.L       #10,A1
00001DD0  133C 0000               1319                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001DD4  6000 000E               1320                  BRA         POPULATE_BUFFER
00001DD8                          1321                  
00001DD8  103C 000E               1322  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001DDC  4E4F                    1323                      TRAP        #15
00001DDE  4CDF 7FFF               1324                      MOVEM.L     (SP)+,ALL_REG
00001DE2  4E75                    1325                      RTS
00001DE4                          1326                 
00001DE4  B63C 0000               1327  POPULATE_BUFFER     CMP.B       #0,D3
00001DE8  67EE                    1328                      BEQ         PRINT_HEX_RETURN
00001DEA  183C 000F               1329                      MOVE.B      #$0F,D4
00001DEE  C805                    1330                      AND.B       D5,D4
00001DF0  E81D                    1331                      ROR.B       #4,D5
00001DF2  4EB9 00001E0E           1332                      JSR         HEX_TO_ASCII
00001DF8  1304                    1333                      MOVE.B      D4,-(A1)
00001DFA  1805                    1334                      MOVE.B      D5,D4
00001DFC  C83C 000F               1335                      AND.B       #$0F,D4
00001E00  4EB9 00001E0E           1336                      JSR         HEX_TO_ASCII
00001E06  1304                    1337                      MOVE.B      D4,-(A1)
00001E08  E08D                    1338                      LSR.L       #8,D5
00001E0A  5303                    1339                      SUB.B       #1,D3
00001E0C  60D6                    1340                      BRA         POPULATE_BUFFER
00001E0E                          1341  
00001E0E  48E7 E7FE               1342  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001E12  B83C 0009               1343                          CMP.B       #9,D4
00001E16  6F00 000C               1344                          BLE         NUMBER_TO_ASCII
00001E1A  0604 0037               1345                          ADD.B       #$37,D4
00001E1E  4CDF 7FE7               1346  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001E22  4E75                    1347                          RTS
00001E24                          1348                  
00001E24  0604 0030               1349  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001E28  60F4                    1350                      BRA     HEX_TO_ASCII_RETURN                    
00001E2A                          1351                      
00001E2A  48E7 FFFE               1352  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001E2E  3F3C 0000               1353                      MOVE.W      #00,-(SP)           *for printing purpose
00001E32  343C 00F0               1354                      MOVE.W      #$f0,D2             *manipulating each digit
00001E36  C441                    1355                      AND.W       D1,D2
00001E38  E842                    1356                      ASR.W       #4,D2
00001E3A  4EB9 00001E60           1357                      JSR         TO_STRING           * converts to the string ASCII val
00001E40  E142                    1358                      ASL.W       #8,D2
00001E42                          1359                      
00001E42  C27C 000F               1360                      AND.W       #$F,D1              * the last digit
00001E46  1401                    1361                      MOVE.B      D1,D2               
00001E48  4EB9 00001E60           1362                      JSR         TO_STRING
00001E4E  3F02                    1363                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001E50                          1364                      
00001E50  224F                    1365                      MOVE.L      SP,A1               * printing
00001E52  103C 000E               1366                      MOVE.B      #14,D0
00001E56  4E4F                    1367                      TRAP        #15
00001E58  2A1F                    1368                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001E5A                          1369  
00001E5A  4CDF 7FFF               1370  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001E5E  4E75                    1371                                  RTS
00001E60                          1372                                  
00001E60  B43C 0009               1373  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001E64  6E00 0008               1374              BGT     LETTERS     
00001E68  0602 0030               1375              ADD.B   #$30,D2             * offseting digit
00001E6C  4E75                    1376              RTS
00001E6E  0602 0037               1377  LETTERS     ADD.B   #$37,D2             * offseting leter
00001E72  4E75                    1378              RTS   
00001E74                          1379  
00001E74                          1380  *________________________________________________________________________________________
00001E74                          1381  
00001E74                          1382  
00001E74                          1383  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001E74                          1384          *PARAMENTER     NO PARAMETER NEEDED
00001E74= 28 00                   1385  OPEN_PAR_TAG        DC.B    '(',0  
00001E76= 29 00                   1386  CLOSED_PAR_TAG      DC.B    ')',0
00001E78= 23 00                   1387  HASH_SIGN_TAG       DC.B    '#',0
00001E7A= 24 00                   1388  DOLLAR_TAG          DC.B    '$',0
00001E7C= 2F 00                   1389  FORWARD_SLASH_TAG   DC.B    '/',0      
00001E7E  48E7 FFFE               1390  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001E82  43F8 1E74               1391                          LEA         OPEN_PAR_TAG, A1
00001E86  103C 000E               1392                          MOVE.B      #14,D0
00001E8A  4E4F                    1393                          TRAP        #15
00001E8C  4CDF 7FFF               1394                          MOVEM.L     (SP)+,ALL_REG
00001E90  4E75                    1395                          RTS
00001E92                          1396  *_________________________________________________________________________________
00001E92                          1397  
00001E92                          1398  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001E92                          1399          *PARAMENTER     NO PARAMETER NEEDED
00001E92                          1400          
00001E92  48E7 FFFE               1401  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001E96  43F8 1E76               1402                              LEA         CLOSED_PAR_TAG, A1
00001E9A  103C 000E               1403                              MOVE.B      #14,D0
00001E9E  4E4F                    1404                              TRAP        #15
00001EA0  4CDF 7FFF               1405                              MOVEM.L     (SP)+,ALL_REG
00001EA4  4E75                    1406                              RTS
00001EA6                          1407  *__________________________________________________________________________________
00001EA6                          1408  
00001EA6                          1409  *________________ PRINT PLUS SIGN _________________________________________________
00001EA6                          1410          *PARAMENTER     NO PARAMETER NEEDED
00001EA6= 2B 00                   1411  PLUS_TAG            DC.B    '+',0
00001EA8= 2D 00                   1412  MINUS_TAG           DC.B    '-',0        
00001EAA  48E7 FFFE               1413  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001EAE  43F8 1EA6               1414                  LEA         PLUS_TAG, A1
00001EB2  103C 000E               1415                  MOVE.B      #14,D0
00001EB6  4E4F                    1416                  TRAP        #15
00001EB8  4CDF 7FFF               1417                  MOVEM.L     (SP)+,ALL_REG
00001EBC  4E75                    1418                  RTS
00001EBE                          1419  *_________________________________________________________________________________
00001EBE                          1420  
00001EBE                          1421  *________________ PRINT MINUS SIGN _______________________________________________
00001EBE                          1422          *PARAMENTER     NO PARAMETER NEEDED
00001EBE                          1423          
00001EBE  48E7 FFFE               1424  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001EC2  43F8 1EA8               1425                      LEA         MINUS_TAG, A1
00001EC6  103C 000E               1426                      MOVE.B      #14,D0
00001ECA  4E4F                    1427                      TRAP        #15
00001ECC  4CDF 7FFF               1428                      MOVEM.L     (SP)+,ALL_REG
00001ED0  4E75                    1429                      RTS
00001ED2                          1430  *_________________________________________________________________________________
00001ED2                          1431  
00001ED2                          1432  *________________ PRINT COMMA ____________________________________________________
00001ED2                          1433          *PARAMENTER     NO PARAMETER NEEDED
00001ED2= 09 00                   1434  TAB_TAG         DC.B    $9,0
00001ED4= 20 00                   1435  SPACE_TAG       DC.B    ' ',0
00001ED6= 2C 00                   1436  COMMA_TAG       DC.B    ',',0        
00001ED8  48E7 FFFE               1437  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001EDC  43F8 1ED6               1438                      LEA         COMMA_TAG, A1
00001EE0  103C 000E               1439                      MOVE.B      #14,D0
00001EE4  4E4F                    1440                      TRAP        #15
00001EE6  4CDF 7FFF               1441                      MOVEM.L     (SP)+,ALL_REG
00001EEA  4E75                    1442                      RTS
00001EEC                          1443  *_________________________________________________________________________________
00001EEC                          1444  
00001EEC                          1445  *________________ PRINT TAB ______________________________________________________
00001EEC                          1446          *PARAMENTER     NO PARAMETER NEEDED
00001EEC                          1447          
00001EEC  48E7 FFFE               1448  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001EF0  43F8 1ED2               1449                  LEA         TAB_TAG, A1
00001EF4  103C 000E               1450                  MOVE.B      #14,D0
00001EF8  4E4F                    1451                  TRAP        #15
00001EFA  4CDF 7FFF               1452                  MOVEM.L     (SP)+,ALL_REG
00001EFE  4E75                    1453                  RTS
00001F00                          1454  *_________________________________________________________________________________
00001F00                          1455  
00001F00                          1456  
00001F00                          1457  *_______________    PRINT NEWLINE   ________________________________________________
00001F00                          1458          *PARAMETER NO PARAMETER NEEDED
00001F00= 0D 0A 00                1459  NEWLINE_TAG         DC.B    CR,LF,0        
00001F04  48E7 FFFE               1460  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001F08  43F8 1F00               1461                      LEA         NEWLINE_TAG, A1
00001F0C  103C 000E               1462                      MOVE.B      #14,D0
00001F10  4E4F                    1463                      TRAP        #15
00001F12  4CDF 7FFF               1464                      MOVEM.L     (SP)+,ALL_REG
00001F16  4E75                    1465                      RTS
00001F18                          1466  
00001F18                          1467  *___________________________________________________________________________________
00001F18                          1468  
00001F18                          1469  
00001F18                          1470  *_______________    PRINT HASH SIGN   ________________________________________________
00001F18                          1471          *PARAMETER NO PARAMETER NEEDED
00001F18                          1472          
00001F18  48E7 FFFE               1473  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001F1C  43F8 1E78               1474                      LEA         HASH_SIGN_TAG, A1
00001F20  103C 000E               1475                      MOVE.B      #14,D0
00001F24  4E4F                    1476                      TRAP        #15
00001F26  4CDF 7FFF               1477                      MOVEM.L     (SP)+,ALL_REG
00001F2A  4E75                    1478                      RTS
00001F2C                          1479  
00001F2C                          1480  *___________________________________________________________________________________
00001F2C                          1481  
00001F2C                          1482  
00001F2C                          1483  
00001F2C                          1484  *_______________    PRINT DOLLAR   ________________________________________________
00001F2C                          1485          *PARAMETER NO PARAMETER NEEDED
00001F2C                          1486          
00001F2C  48E7 FFFE               1487  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001F30  43F8 1E7A               1488                      LEA         DOLLAR_TAG, A1
00001F34  103C 000E               1489                      MOVE.B      #14,D0
00001F38  4E4F                    1490                      TRAP        #15
00001F3A  4CDF 7FFF               1491                      MOVEM.L     (SP)+,ALL_REG
00001F3E  4E75                    1492                      RTS
00001F40                          1493  
00001F40                          1494  *___________________________________________________________________________________
00001F40                          1495  
00001F40                          1496  
00001F40                          1497  
00001F40                          1498  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001F40                          1499          *PARAMETER NO PARAMETER NEEDED
00001F40                          1500          
00001F40  48E7 FFFE               1501  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001F44  43F8 1E7C               1502                          LEA         FORWARD_SLASH_TAG, A1
00001F48  103C 000E               1503                          MOVE.B      #14,D0
00001F4C  4E4F                    1504                          TRAP        #15
00001F4E  4CDF 7FFF               1505                          MOVEM.L     (SP)+,ALL_REG
00001F52  4E75                    1506                          RTS
00001F54                          1507  
00001F54                          1508  
00001F54                          1509     
00001F54                          1510  *********************************************************************
00001F54                          1511  *Subroutine: OUTPUT
00001F54                          1512  *What it does: Outputs parts of opword, moves to new screen if needed
00001F54                          1513  *Registers: Uses register A1, D0,
00001F54                          1514  *A1: Used to store messages and single char
00001F54                          1515  *Paramemeters: A1, A2
00001F54                          1516  *A1: Stores what should be used
00001F54                          1517  *********************************************************************  
00001F54                          1518  
00001F54                          1519       OUTPUT:
00001F54                          1520       
00001F54  0C39 0001 00002337      1521       CMP.B  #1,(OutputType)
00001F5C  6700 0026               1522       BEQ    outputOpcode
00001F60  0C39 0002 00002337      1523       CMP.B  #2,(OutputType)
00001F68  6700 0066               1524       BEQ    OutputSize
00001F6C  0C39 0003 00002337      1525       CMP.B  #3,(OutputType)
00001F74  6700 0062               1526       BEQ    OutputData
00001F78  0C39 0004 00002337      1527       CMP.B  #4,(OutputType)
00001F80  6700 00AC               1528       BEQ    OutputAddress
00001F84                          1529       
00001F84                          1530  outputOpcode    
00001F84  0C39 001E 00002336      1531       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001F8C  6C00 0010               1532       BGE    outputOpcodeNewScreen
00001F90                          1533       
00001F90  103C 000E               1534       MOVE.B #14,D0
00001F94  4E4F                    1535       TRAP   #15
00001F96                          1536       
00001F96  5239 00002336           1537       ADD.B  #1,(LineCounter)
00001F9C                          1538       
00001F9C  4E75                    1539       RTS
00001F9E                          1540       
00001F9E                          1541       
00001F9E                          1542  outputOpcodeNewScreen
00001F9E  2F09                    1543       MOVE.L A1,-(SP)                Storing last message to be used later
00001FA0                          1544       
00001FA0  43F9 0000230C           1545       LEA    OUTPUTNEWSCREEN,A1         
00001FA6  103C 000E               1546       MOVE.B #14,D0
00001FAA  4E4F                    1547       TRAP   #15
00001FAC                          1548       
00001FAC  43F9 00008008           1549       LEA    userInputStored,A1         Pauses program to show screen full of data
00001FB2  103C 0002               1550       MOVE.B #2,D0
00001FB6  4E4F                    1551       TRAP   #15
00001FB8                          1552       
00001FB8  13FC 0000 00002336      1553       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001FC0                          1554       
00001FC0  225F                    1555       MOVE.L (SP)+,A1                Retriving message to be used
00001FC2                          1556       
00001FC2  103C 000E               1557       MOVE.B #14,D0                  Outputting decoded message
00001FC6  4E4F                    1558       TRAP   #15
00001FC8                          1559       
00001FC8  5239 00002336           1560       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001FCE                          1561       
00001FCE  4E75                    1562       RTS
00001FD0                          1563       
00001FD0                          1564  outputSize
00001FD0  103C 000E               1565      MOVE.B  #14,D0
00001FD4  4E4F                    1566      TRAP    #15
00001FD6  4E75                    1567      RTS
00001FD8                          1568  outputData
00001FD8  267C 00000800           1569      MOVE.L   #$800,A3
00001FDE  3692                    1570      MOVE.W  (A2),(A3)
00001FE0  2F06                    1571      MOVE.L  D6,-(SP)
00001FE2  103C 0000               1572      MOVE.B  #0,D0
00001FE6  43F9 00009005           1573      LEA     addressOutput,A1
00001FEC                          1574  
00001FEC                          1575  outputDataLoop
00001FEC                          1576  *check if loop has run 4 times
00001FEC  B03C 0002               1577      CMP.B   #2,D0
00001FF0  6700 001C               1578      BEQ     outputDataLoopEnd
00001FF4                          1579      *Grab byte from address, dont increment
00001FF4  1C13                    1580      MOVE.B  (A3),D6
00001FF6                          1581      *LSR to isolate left bit
00001FF6  E80E                    1582      LSR.B   #4,D6
00001FF8                          1583      *Call converthtoa
00001FF8  6100 008A               1584      BSR     CONVERTHTOA
00001FFC  12C6                    1585      MOVE.B  D6,(A1)+   
00001FFE                          1586      *Grab bye from address, increment
00001FFE  1C1B                    1587      MOVE.B  (A3)+,D6
00002000                          1588      *AND Mask second digit
00002000  CC3C 000F               1589      AND.B   #$0F,D6
00002004  6100 007E               1590      BSR     CONVERTHTOA
00002008  12C6                    1591      MOVE.B  D6,(A1)+
0000200A  5200                    1592      ADD.B   #1,D0
0000200C  60DE                    1593      BRA     outputDataLoop
0000200E                          1594      
0000200E                          1595  outputDataLoopEnd
0000200E  12BC 0000               1596      MOVE.B  #$00,(A1)
00002012  2C1F                    1597      MOVE.L  (SP)+,D6
00002014  43F9 00009005           1598      LEA     addressOutput,A1
0000201A  103C 000E               1599      MOVE.B  #14,D0
0000201E  4E4F                    1600      TRAP    #15
00002020                          1601      
00002020  43F9 0000232F           1602      LEA     NEWLINE,A1
00002026  103C 000E               1603      MOVE.B  #14,D0
0000202A  4E4F                    1604      TRAP    #15
0000202C                          1605  
0000202C  4E75                    1606      RTS
0000202E                          1607   
0000202E                          1608      
0000202E                          1609  outputAddress
0000202E  267C 00000800           1610      MOVE.L  #$800,A3
00002034  268A                    1611      MOVE.L  A2,(A3)
00002036  2F06                    1612      MOVE.L  D6,-(SP)
00002038  103C 0000               1613      MOVE.B  #0,D0
0000203C  43F9 00009005           1614      LEA     addressOutput,A1
00002042                          1615  outputAddressLoop
00002042                          1616      *check if loop has run 4 times
00002042  B03C 0004               1617      CMP.B   #4,D0
00002046  6700 001C               1618      BEQ     outputAddressLoopEnd
0000204A                          1619      *Grab byte from address, dont increment
0000204A  1C13                    1620      MOVE.B  (A3),D6
0000204C                          1621      *LSR to isolate left bit
0000204C  E80E                    1622      LSR.B   #4,D6
0000204E                          1623      *Call converthtoa
0000204E  6100 0034               1624      BSR     CONVERTHTOA
00002052  12C6                    1625      MOVE.B  D6,(A1)+   
00002054                          1626      *Grab bye from address, increment
00002054  1C1B                    1627      MOVE.B  (A3)+,D6
00002056                          1628      *AND Mask second digit
00002056  CC3C 000F               1629      AND.B   #$0F,D6
0000205A  6100 0028               1630      BSR     CONVERTHTOA
0000205E  12C6                    1631      MOVE.B  D6,(A1)+
00002060  5200                    1632      ADD.B   #1,D0
00002062  60DE                    1633      BRA     outputAddressLoop
00002064                          1634      
00002064                          1635      
00002064                          1636  outputAddressLoopEnd
00002064  12BC 0000               1637      MOVE.B  #$00,(A1)
00002068  2C1F                    1638      MOVE.L  (SP)+,D6
0000206A  43F9 00009005           1639      LEA     addressOutput,A1
00002070                          1640      
00002070  103C 000E               1641      MOVE.B  #14,D0
00002074  4E4F                    1642      TRAP    #15
00002076                          1643      
00002076  43F9 00002332           1644      LEA     spaces,A1
0000207C  103C 000E               1645      MOVE.B  #14,D0
00002080  4E4F                    1646      TRAP    #15
00002082                          1647  
00002082                          1648  
00002082  4E75                    1649      RTS
00002084                          1650  
00002084                          1651  *********************************************************************
00002084                          1652  *Subroutine: CONVERTHTOA
00002084                          1653  *What it does: Converts HEX to ASCII
00002084                          1654  *Registers: Uses register D6,D0
00002084                          1655  *D6: Stores hex character to be converted
00002084                          1656  *Paramemeters: D6
00002084                          1657  *D6: Stores hex characcter to be converted
00002084                          1658  *********************************************************************
00002084                          1659      CONVERTHTOA:
00002084                          1660      
00002084  BC3C 0009               1661      CMP.B   #9,D6
00002088  6F00 0006               1662      BLE     zerotonine
0000208C  6000 000A               1663      BRA     AtoF
00002090                          1664      
00002090                          1665  zerotonine    
00002090  0686 00000030           1666      ADD.L   #$30,D6
00002096  4E75                    1667      RTS
00002098                          1668  AtoF
00002098  0686 00000037           1669      ADD.L   #$37,D6
0000209E  4E75                    1670      RTS
000020A0                          1671      
000020A0                          1672  END_SIMULATION:
000020A0                          1673          
000020A0  103C 0009               1674      MOVE.B  #9,D0
000020A4  4E4F                    1675      TRAP    #15
000020A6                          1676  
000020A6  FFFF FFFF               1677      SIMHALT             ; halt simulator
000020AA                          1678  
000020AA                          1679  * Put variables and constants here
000020AA= 57 65 6C 63 6F 6D ...   1680  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
000020D0= 53 6F 6D 65 20 71 ...   1681                  DC.B    'Some quick rules:',CR,LF
000020E3= 31 29 20 4F 6E 6C ...   1682                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
0000211F= 32 29 20 54 68 65 ...   1683                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
0000216A= 33 29 20 41 6E 79 ...   1684                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
000021AE= 20 20 20 77 69 6C ...   1685                  DC.B    '   will be rejected',CR,LF
000021C3= 34 29 20 54 68 65 ...   1686                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
00002206= 20 20 20 77 69 6C ...   1687                  DC.B    '   will be rejected',CR,LF,0      
0000221C= 50 6C 65 61 73 65 ...   1688  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
00002242= 50 6C 65 61 73 65 ...   1689  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
00002268                          1690  
00002268= 0D 0A 54 68 69 73 ...   1691  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
00002286= 0D 0A 49 6E 70 75 ...   1692  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
000022C2                          1693  
000022C2= 54 6F 20 72 65 70 ...   1694  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
0000230C                          1695  
0000230C= 50 6C 65 61 73 65 ...   1696  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
0000232F                          1697  
0000232F= 0D 0A 00                1698  NEWLINE     DC.B    CR,LF,0
00002332= 20 20 00                1699  SPACES      DC.B    '  ',0
00002335                          1700  
00002335= 01                      1701  InputQuality    DC.B    1       Set to 1 for default good
00002336= 00                      1702  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
00002337= 00                      1703  OutputType      DC.B    0      To track what type is being output
00002338= 00                      1704  RepeatFlag      DC.B    0
00002339                          1705  
00002339= 4E 4F 50 0D 0A 00       1706  nopout  DC.B    'NOP',CR,LF,0
0000233F= 4D 4F 56 45 00          1707  moveout  DC.B    'MOVE',0
00002344= 4D 4F 56 45 41 00       1708  moveaout DC.B      'MOVEA',0
0000234A= 4D 4F 56 45 51 00       1709  moveqout DC.B   'MOVEQ',0
00002350= 4D 4F 56 45 4D 00       1710  movemout DC.B   'MOVEM',0
00002356                          1711  
00002356= 53 55 42 00             1712  subout    DC.B  'SUB',0
0000235A= 41 44 44 00             1713  addout    DC.B 'ADD',0
0000235E= 41 44 44 41 00          1714  addaout    DC.B 'ADDA',0
00002363= 41 44 44 51 00          1715  addqout    DC.B 'ADDQ',0
00002368                          1716  
00002368= 4C 45 41 00             1717  leaout    DC.B  'LEA',0
0000236C                          1718  
0000236C= 4E 4F 54 00             1719  notout    DC.B  'NOT',0
00002370= 4F 52 00                1720  orout DC.B     'OR',0
00002373= 41 4E 44 00             1721  andout DC.B     'AND',0
00002377                          1722  
00002377                          1723  
00002377= 4C 53 4C 00             1724  lslout    DC.B  'LSL',0
0000237B= 4C 53 52 00             1725  lsrout    DC.B  'LSR',0
0000237F= 41 53 4C 00             1726  aslout    DC.B  'ASL',0
00002383= 41 53 52 00             1727  asrout    DC.B  'ASR',0
00002387                          1728  
00002387= 52 4F 4C 00             1729  rolout    DC.B  'ROL',0
0000238B= 52 4F 52 00             1730  rorout    DC.B  'ROR',0
0000238F                          1731  
0000238F= 42 47 54 00             1732  bgtout DC.B     'BGT',0
00002393= 42 4C 45 00             1733  bleout DC.B     'BLE',0
00002397= 42 45 51 00             1734  beqout DC.B     'BEQ',0
0000239B                          1735  
0000239B= 4A 53 52 00             1736  jsrout DC.B     'JSR',0
0000239F= 52 54 53 0D 0A 00       1737  rtsout DC.B     'RTS',CR,LF,0
000023A5= 42 52 41 00             1738  braout DC.B     'BRA',0
000023A9                          1739  
000023A9= 44 41 54 41 20 20 ...   1740  dataout DC.B    'DATA   ',0
000023B1                          1741  
000023B1                          1742  
000023B1                          1743  
000023B1= 2E 42 20 20 20 20 00    1744  byteout  DC.B    '.B    ',0
000023B8= 2E 57 20 20 20 20 00    1745  wordout  DC.B    '.W    ',0
000023BF= 2E 4C 20 20 20 20 00    1746  longout  DC.B    '.L    ',0
000023C6                          1747  
000023C6= 0D 0A 00                1748  empty    DC.B    '',CR,LF,0
000023C9                          1749  
000023C9  =0000000D               1750  CR  EQU $0D
000023C9  =0000000A               1751  LF  EQU $0A
000023C9                          1752  
000023C9                          1753  
000023C9                          1754      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1476
ADDA                14B8
ADDAOUT             235E
ADDOUT              235A
ADDQ                1434
ADDQOUT             2363
ADDQ_EA             1B5A
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 1778
ANDOUT              2373
ASL                 1608
ASLOUT              237F
ASR                 164A
ASROUT              2383
ATOF                2098
ATOH                19C0
BCC                 17BA
BEQ                 1824
BEQOUT              2397
BGT                 17E0
BGTOUT              238F
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 1802
BLEOUT              2393
BRA                 1846
BRAOUT              23A5
BYTE                12B8
BYTEOUT             23B1
CHECK_EA_AB_L       1D40
CHECK_EA_AB_W       1D20
CHECK_EA_AR         1C88
CHECK_EA_IMM        1D5E
CHECK_EA_INDIRECT   1CA2
CHECK_EA_POST       1CC8
CHECK_EA_PRE        1CF4
CHECK_VALID_EA      1C1C
CLOSED_PAR_TAG      1E76
COMMA_TAG           1ED6
CONVERTATOH         19C0
CONVERTHTOA         2084
CR                  D
DATA                1868
DATAOUT             23A9
DOLLAR_TAG          1E7A
EA1_END             1A9E
EA1_MODE_ONE        1A92
EA1_MODE_ZERO       1A9A
EA2_END             1AE2
EA2_IMMEDIATE       1ADA
EA2_REGISTER        1AD2
EA_GROUP1           1A72
EA_GROUP2           1ABC
EA_GROUP3           1B02
EA_GROUP4           1B1E
EMPTY               23C6
END_SIMULATION      20A0
FINISH              1A14
FIRSTINPUT          18DE
FORMAT_IMMEDIATE_DATA  1A20
FORWARD_SLASH_TAG   1E7C
HASH_SIGN_TAG       1E78
HERE                1020
HEX_TO_ASCII        1E0E
HEX_TO_ASCII_RETURN  1E1E
IMMEDIATE0          1A30
IMMEDIATE_END       1A32
INPUT1              8000
INPUT1MESSAGE       221C
INPUT2              8004
INPUT2MESSAGE       2242
INPUTERROR          1A16
INPUTERROR2SMALLER  2286
INPUTERRORBADCHAR   2268
INPUTQUALITY        2335
INPUTREPEAT         22C2
INPUT_BUFFER        1DB2
INVALID_EA          1C56
IPUT_BUFFER_EX      1DAA
JSR                 151C
JSROUT              239B
LEA                 1710
LEAOUT              2368
LETSGO              1058
LETTERS             1E6E
LF                  A
LINECOUNTER         2336
LONG                12E0
LONGOUT             23BF
LOWERCASE           19FC
LSL                 1584
LSLOUT              2377
LSR                 15C6
LSROUT              237B
MEMORY_TO_REGISTER  1BB4
MINUS_TAG           1EA8
MODE_010            1BE2
MODE_01_0           1C14
MOVE                1314
MOVEA               135C
MOVEAOUT            2344
MOVEM               13B8
MOVEMOUT            2350
MOVEM_EA            1BAA
MOVEOUT             233F
MOVEQ               1392
MOVEQOUT            234A
MOVEQ_EA            1B82
MOVE_MOVEA_EA       1A34
NEWLINE             232F
NEWLINE_TAG         1F00
NOP                 12F4
NOPOUT              2339
NOT                 1542
NOTOUT              236C
NUMBER_TO_ASCII     1E24
OPCODE              11B2
OPEN_PAR_TAG        1E74
OR                  1736
OROUT               2370
OUTPUT              1F54
OUTPUTADDRESS       202E
OUTPUTADDRESSLOOP   2042
OUTPUTADDRESSLOOPEND  2064
OUTPUTDATA          1FD8
OUTPUTDATALOOP      1FEC
OUTPUTDATALOOPEND   200E
OUTPUTNEWSCREEN     230C
OUTPUTOPCODE        1F84
OUTPUTOPCODENEWSCREEN  1F9E
OUTPUTSIZE          1FD0
OUTPUTTYPE          2337
PLUS_TAG            1EA6
POPULATE_BUFFER     1DE4
PRINT_BUFFER        1DA0
PRINT_CLOSED_PARENTHESIS  1E92
PRINT_COMMA         1ED8
PRINT_DOLLAR        1F2C
PRINT_EA            1C60
PRINT_EA_RETURN     1D9A
PRINT_FORWARD_SLASH  1F40
PRINT_HASH_SIGN     1F18
PRINT_HEX           1DC2
PRINT_HEX_RETURN    1DD8
PRINT_MINUS         1EBE
PRINT_NEWLINE       1F04
PRINT_OPEN_PARENTHESIS  1E7E
PRINT_PLUS          1EAA
PRINT_REGISTOR      1E2A
PRINT_REGISTOR_RETURN  1E5A
PRINT_TAB           1EEC
READ_WORD_IMM       1D82
REGISTER_TO_MEMORY  1BF0
REPEATFLAG          2338
RETURN              12B6
ROL                 168C
ROLOUT              2387
ROR                 16CE
ROROUT              238B
RTS                 14F6
RTSOUT              239F
SECONDINPUT         1942
SPACES              2332
SPACE_TAG           1ED4
START               1000
STARTMESSAGE        20AA
SUB                 13F2
SUBOUT              2356
TAB_TAG             1ED2
THERE               1186
THROWINPUT1CHARERROR  1924
THROWINPUT2CHARERROR  1990
THROWINPUT2LOWERERROR  19AC
TO_STRING           1E60
UPPERCASE           19E4
USERINPUT           1896
USERINPUTREPEAT     1188
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1C3E
WELCOMEEXPLANATION  18C4
WORD                12CC
WORDOUT             23B8
WRONG_INSTRUCTION   1BD8
ZEROTONINE          2090
