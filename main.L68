00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 12:39:36 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 00002212        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 079E                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 00001174             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048  6E00 000E                 42      BGT letsgo
0000104C  B67C 0004                 43      CMP #4,D3 
00001050  6700 0006                 44      BEQ letsgo
00001054  6F00 0002                 45      BLE letsgo
00001058                            46     
00001058                            47  letsgo
00001058                            48      
00001058                            49  * calls-------------------------------------------------------
00001058  347C 100C                 50      MOVE.W #$100C, A2
0000105C  6100 0142                 51      BSR     OPCODE * test MOVE.B
00001060                            52  
00001060  347C 1010                 53      MOVE.W #$1010, A2
00001064  6100 013A                 54      BSR     OPCODE * test MOVEA.W
00001068                            55      
00001068  347C 1014                 56      MOVE.W #$1014, A2
0000106C  6100 0132                 57      BSR     OPCODE * test MOVEQ
00001070                            58     
00001070  347C 1016                 59      MOVE.W #$1016, A2
00001074  6100 012A                 60      BSR     OPCODE *test MOVEA.L
00001078                            61      
00001078  347C 1018                 62      MOVE.W #$1018, A2
0000107C  6100 0122                 63      BSR     OPCODE *test DATA
00001080                            64      
00001080                            65      
00001080  347C 101A                 66      MOVE.W #$101A, A2
00001084  6100 011A                 67      BSR     OPCODE *test SUB.L
00001088                            68      
00001088  347C 101C                 69      MOVE.W #$101C, A2
0000108C  6100 0112                 70      BSR     OPCODE *test BRA
00001090                            71      
00001090  347C 1020                 72      MOVE.W #$1020, A2
00001094  6100 010A                 73      BSR     OPCODE *test JSR
00001098                            74      
00001098                            75      
00001098  43F9 00002295             76      LEA empty,A1
0000109E  13FC 0001 00002213        77      MOVE.B  #1,(OutputType)       
000010A6  6100 0D88                 78      BSR    OUTPUT
000010AA                            79  
000010AA                            80      
000010AA  347C 1026                 81      MOVE.W #$1026, A2
000010AE  6100 00F0                 82      BSR     OPCODE *test NOT
000010B2                            83      
000010B2  347C 1028                 84      MOVE.W #$1028, A2
000010B6  6100 00E8                 85      BSR     OPCODE *test LEA
000010BA                            86      
000010BA  347C 102A                 87      MOVE.W #$102A, A2
000010BE  6100 00E0                 88      BSR     OPCODE *test OR
000010C2                            89      
000010C2  43F9 00002295             90       LEA empty,A1
000010C8  13FC 0001 00002213        91      MOVE.B  #1,(OutputType)       
000010D0  6100 0D5E                 92      BSR    OUTPUT
000010D4                            93  
000010D4                            94      
000010D4  347C 1030                 95      MOVE.W #$1030, A2
000010D8  6100 00C6                 96      BSR     OPCODE *test MOVEM
000010DC                            97  
000010DC  347C 1034                 98      MOVE.W #$1034, A2
000010E0  6100 00BE                 99      BSR     OPCODE *test AND
000010E4                           100      
000010E4  347C 1036                101      MOVE.W #$1036, A2
000010E8  6100 00B6                102      BSR     OPCODE *test ADD
000010EC                           103      
000010EC  43F9 00002295            104      LEA empty,A1
000010F2  13FC 0001 00002213       105      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0D34                106      BSR    OUTPUT
000010FE                           107  
000010FE  347C 1038                108      MOVE.W #$1038, A2
00001102  6100 009C                109      BSR     OPCODE *test ADDA
00001106                           110      
00001106  347C 103A                111      MOVE.W #$103A, A2
0000110A  6100 0094                112      BSR     OPCODE *test ADDQ
0000110E                           113      
0000110E  347C 103C                114      MOVE.W #$103C, A2
00001112  6100 008C                115      BSR     OPCODE *test LSL
00001116                           116  
00001116  347C 103E                117      MOVE.W #$103E, A2
0000111A  6100 0084                118      BSR     OPCODE *test LSR
0000111E                           119      
0000111E  347C 1040                120      MOVE.W #$1040, A2
00001122  6100 007C                121      BSR     OPCODE *test ASL
00001126                           122      
00001126  43F9 00002295            123      LEA empty,A1
0000112C  13FC 0001 00002213       124      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0CFA                125      BSR    OUTPUT
00001138                           126  
00001138                           127  
00001138  347C 1042                128      MOVE.W #$1042, A2
0000113C  6100 0062                129      BSR     OPCODE *test ASR
00001140                           130      
00001140                           131      
00001140  347C 1044                132      MOVE.W #$1044, A2
00001144  6100 005A                133      BSR     OPCODE *test ROL
00001148                           134  
00001148  347C 1046                135      MOVE.W #$1046, A2
0000114C  6100 0052                136      BSR     OPCODE *test ROR
00001150                           137      
00001150                           138  
00001150  347C 1048                139      MOVE.W #$1048, A2
00001154  6100 004A                140      BSR     OPCODE *test BGT
00001158                           141  
00001158  347C 1050                142      MOVE.W #$1050, A2
0000115C  6100 0042                143      BSR     OPCODE *test BLE
00001160                           144      
00001160  347C 1054                145      MOVE.W #$1054, A2
00001164  6100 003A                146      BSR     OPCODE *test BEQ
00001168                           147      
00001168                           148  
00001168                           149    
00001168  347C 10B4                150      MOVE.W #$10B4, A2
0000116C  6100 0032                151      BSR     OPCODE *test RTS
00001170                           152  
00001170                           153  
00001170                           154  * calls---------------------------------------------------------    
00001170  6000 0004                155      BRA userInputRepeat
00001174                           156  there    
00001174  4E75                     157      RTS
00001176                           158  * end testing--------------------------------------------------------------
00001176                           159   
00001176                           160  
00001176                           161       
00001176                           162    
00001176                           163  
00001176                           164      
00001176                           165  userInputRepeat
00001176  43F9 0000219E            166      LEA     INPUTREPEAT,A1
0000117C  103C 000E                167      MOVE.B  #14,D0
00001180  4E4F                     168      TRAP    #15
00001182  5239 00002212            169      ADD.B   #1,(LineCounter)
00001188                           170      
00001188  43F9 00008008            171      LEA     userInputStored,A1
0000118E  103C 0005                172      MOVE.B  #5,D0
00001192  4E4F                     173      TRAP    #15
00001194                           174      
00001194  0C11 0000                175      CMP.B   #$00,(A1)
00001198  6700 FE6E                176      BEQ     userInputStart
0000119C                           177   
0000119C  FFFF FFFF                178      SIMHALT
000011A0                           179  
000011A0                           180  **********************************************************
000011A0                           181  *Subroutine: OPCODE
000011A0                           182  *What it does: Looks at the word pointed to by A2 and determines opcode
000011A0                           183  *Registers: 
000011A0                           184  *A1: printing
000011A0                           185  *A2: parameter with instruction address
000011A0                           186  *D0: printing
000011A0                           187  *D3: used for determing the instruction, mostly shifts
000011A0                           188  *D2: used for determing the size
000011A0                           189  *Paramemeters: A2 the memory address to decode from
000011A0                           190  **********************************************************
000011A0                           191  OPCODE:
000011A0  4243                     192      CLR D3
000011A2                           193      
000011A2  0C52 4E75                194      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011A6  6700 031C                195      BEQ rts
000011AA                           196      
000011AA  0C52 4E71                197      CMP #$4E71, (A2) *NOP compare
000011AE  6700 012A                198      BEQ nop
000011B2                           199      
000011B2  3612                     200      Move.W (A2), D3 
000011B4  E04B                     201      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011B6  E84B                     202      LSR #4,D3
000011B8                           203      
000011B8                           204      
000011B8  B67C 0008                205      CMP #%1000, D3 * OR compare
000011BC  6700 051E                206      BEQ or
000011C0                           207      
000011C0                           208      
000011C0  B67C 0003                209      CMP #%0011, D3 *MOVE and MOVEA compare
000011C4  6F00 0134                210      BLE move
000011C8                           211      
000011C8  B67C 0007                212      CMP #%0111, D3 *MOVEQ compare
000011CC  6700 01AA                213      BEQ moveq
000011D0                           214      
000011D0  B67C 0009                215      CMP #%1001, D3 *SUB compare
000011D4  6700 01FA                216      BEQ sub
000011D8                           217      
000011D8  B67C 000C                218      CMP #%1100, D3 *AND compare
000011DC  6700 053C                219      BEQ and
000011E0                           220      
000011E0  B67C 0005                221      CMP #%0101, D3 *ADDQ compare
000011E4  6700 0228                222      BEQ addq
000011E8                           223  
000011E8  3612                     224      Move.W (A2), D3 * reset D3
000011EA  0243 F118                225      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
000011EE  B67C E108                226      CMP #%1110000100001000,D3 * LSL compare
000011F2  6700 0352                227      BEQ lsl
000011F6                           228  
000011F6  3612                     229      Move.W (A2), D3 * reset D3
000011F8  0243 F118                230      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
000011FC  B67C E008                231      CMP #%1110000000001000,D3 * LSR compare
00001200  6700 0382                232      BEQ lsr
00001204                           233      
00001204                           234      
00001204  3612                     235      Move.W (A2), D3 * reset D3
00001206  0243 F118                236      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
0000120A  B67C E100                237      CMP #%1110000100000000,D3 * ASL compare
0000120E  6700 03B2                238      BEQ asl
00001212                           239  
00001212  3612                     240      Move.W (A2), D3 * reset D3
00001214  0243 F118                241      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001218  B67C E000                242      CMP #%1110000000000000,D3 * ASR compare
0000121C  6700 03E2                243      BEQ asr
00001220                           244  
00001220  3612                     245      Move.W (A2), D3 * reset D3
00001222  0243 F118                246      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001226  B67C E118                247      CMP #%1110000100011000,D3 * ROL compare
0000122A  6700 0412                248      BEQ rol
0000122E                           249  
0000122E  3612                     250      Move.W (A2), D3 * reset D3
00001230  0243 F118                251      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001234  B67C E018                252      CMP #%1110000000011000,D3 * ROR compare
00001238  6700 0442                253      BEQ ror
0000123C                           254  
0000123C                           255      
0000123C                           256      
0000123C  3612                     257      Move.W (A2), D3 * reset D3
0000123E  0243 F0C0                258      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
00001242  B67C D0C0                259      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001246  6700 0242                260      BEQ adda
0000124A                           261      
0000124A  3612                     262      Move.W (A2), D3 
0000124C  E04B                     263      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
0000124E  E84B                     264      LSR #4,D3
00001250  B67C 000D                265      CMP #%1101, D3 *ADD compare
00001254  6700 01F6                266      BEQ add
00001258                           267  
00001258                           268    
00001258  3612                     269      Move.W (A2), D3 * reset D3
0000125A  0243 FB80                270      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
0000125E  B67C 4880                271      CMP #%0100100010000000,D3 * MOVEM compare
00001262  6700 0136                272      BEQ movem
00001266                           273  
00001266                           274      
00001266                           275      
00001266  3612                     276      Move.W (A2), D3 * reset D3
00001268  EC4B                     277      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
0000126A  B67C 013A                278      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
0000126E  6700 0276                279      BEQ jsr
00001272                           280  
00001272  3612                     281      Move.W (A2), D3 * reset D3
00001274  E04B                     282      LSR #8,D3 * make D3 only contain the first 8 bits
00001276  B67C 0046                283      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
0000127A  6700 028C                284      BEQ not
0000127E                           285      
0000127E  3612                     286      Move.W (A2), D3 * reset D3
00001280  0243 F1C0                287      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
00001284  B67C 41C0                288      CMP #%0100000111000000,D3 *LEA compare
00001288  6700 0430                289      BEQ lea
0000128C                           290  
0000128C                           291     
0000128C  3612                     292      Move.W (A2), D3 * reset D3
0000128E  E04B                     293      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
00001290                           294   
00001290  B67C 0060                295      CMP #%01100000, D3 *BRA compare
00001294  6700 04C2                296      BEQ bra
00001298                           297      
00001298                           298      
00001298  6000 04E0                299      BRA data
0000129C                           300      
0000129C                           301  return
0000129C  4E75                     302      RTS
0000129E                           303  byte
0000129E  43F9 00002280            304      LEA    byteout,A1        
000012A4  13FC 0002 00002213       305      MOVE.B  #2,(OutputType)
000012AC  6100 0B82                306      BSR     OUTPUT 
000012B0  60EA                     307      BRA return
000012B2                           308  word
000012B2  43F9 00002287            309      LEA    wordout,A1        
000012B8  13FC 0002 00002213       310      MOVE.B  #2,(OutputType)
000012C0  6100 0B6E                311      BSR     OUTPUT
000012C4  60D6                     312      BRA return
000012C6                           313  long
000012C6  43F9 0000228E            314      LEA    longout,A1        
000012CC  13FC 0002 00002213       315      MOVE.B  #2,(OutputType)
000012D4  6100 0B5A                316      BSR     OUTPUT 
000012D8  60C2                     317      BRA return
000012DA                           318      
000012DA                           319  nop 
000012DA  13FC 0004 00002213       320      MOVE.B  #4,(OutputType)
000012E2  6100 0B4C                321      BSR     OUTPUT
000012E6  43F9 00002214            322      LEA    nopout,A1        
000012EC  13FC 0001 00002213       323      MOVE.B  #1,(OutputType)
000012F4  6100 0B3A                324      BSR     OUTPUT
000012F8  60A2                     325      BRA return
000012FA                           326      
000012FA                           327  move
000012FA                           328      * put the size of the instruction into D2 to use later
000012FA                           329      * since the first two bits of D3 are 00 for move moving the entire word works
000012FA  3403                     330      Move.W D3, D2
000012FC                           331  
000012FC                           332  
000012FC                           333      * determine if MOVE or MOVEA
000012FC                           334      * if bits 8,7,6 = 001 its MOVEA
000012FC  3612                     335      MOVE.W (A2),D3
000012FE  0243 01C0                336      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
00001302                           337      
00001302  B67C 0040                338      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001306  6700 003A                339      BEQ movea
0000130A                           340      
0000130A  13FC 0004 00002213       341      MOVE.B  #4,(OutputType)
00001312  6100 0B1C                342      BSR     OUTPUT
00001316                           343  
00001316  43F9 0000221A            344      LEA    moveout,A1     *print the type
0000131C  13FC 0001 00002213       345      MOVE.B  #1,(OutputType)   
00001324  6100 0B0A                346      BSR    OUTPUT
00001328                           347      
00001328                           348      *now to print size  
00001328  B47C 0002                349      cmp #2,D2 *if the size is 2 branch to long
0000132C  6798                     350      BEQ long
0000132E  B47C 0003                351      cmp #3,D2 *if the size is 3 branch to word
00001332  6700 FF7E                352      BEQ word
00001336  6100 FF66                353      BSR byte *otherwise branch to byte
0000133A                           354    
0000133A  6100 05D4                355      BSR MOVE_MOVEA_EA
0000133E                           356      
0000133E  6000 FF5C                357      BRA return
00001342                           358      
00001342                           359      
00001342                           360  movea
00001342  13FC 0004 00002213       361      MOVE.B  #4,(OutputType)
0000134A  6100 0AE4                362      BSR     OUTPUT
0000134E                           363  
0000134E  43F9 0000221F            364      LEA    moveaout,A1
00001354  13FC 0001 00002213       365      MOVE.B  #1,(OutputType)       
0000135C  6100 0AD2                366      BSR    OUTPUT
00001360                           367      
00001360                           368      *now to print size  
00001360  B47C 0002                369      cmp #2,D2 *if the size is 2 branch to long
00001364  6700 FF60                370      BEQ long
00001368  B47C 0003                371      cmp #3,D2 *if the size is 3 branch to word
0000136C  6100 FF44                372      BSR word
00001370                           373      
00001370  6100 059E                374      BSR MOVE_MOVEA_EA
00001374                           375      
00001374  6000 FF26                376      BRA return
00001378                           377      
00001378                           378  moveq
00001378  13FC 0004 00002213       379      MOVE.B  #4,(OutputType)
00001380  6100 0AAE                380      BSR     OUTPUT
00001384                           381  
00001384  43F9 00002225            382      LEA    moveqout,A1
0000138A  13FC 0001 00002213       383      MOVE.B  #1,(OutputType)       
00001392  6100 0A9C                384      BSR    OUTPUT
00001396  6000 FF04                385      BRA return
0000139A                           386  
0000139A                           387      
0000139A                           388  movem
0000139A  13FC 0004 00002213       389      MOVE.B  #4,(OutputType)
000013A2  6100 0A8C                390      BSR     OUTPUT
000013A6                           391      
000013A6  43F9 0000222B            392      LEA    movemout,A1
000013AC  13FC 0001 00002213       393      MOVE.B  #1,(OutputType)       
000013B4  6100 0A7A                394      BSR    OUTPUT
000013B8                           395      
000013B8  3412                     396      MOVE.W (A2),D2
000013BA  0242 0040                397      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013BE  EC4A                     398      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013C0  B47C 0001                399      CMP #1, D2 * if the size is 1 branch to long
000013C4  6700 FF00                400      BEQ long
000013C8  6100 FEE8                401      BSR word * otherwise branch to word
000013CC                           402  
000013CC                           403      
000013CC  6000 FECE                404      BRA return
000013D0                           405  sub 
000013D0  13FC 0004 00002213       406      MOVE.B  #4,(OutputType)
000013D8  6100 0A56                407      BSR     OUTPUT
000013DC                           408     
000013DC  43F9 00002231            409      LEA    subout,A1
000013E2  13FC 0001 00002213       410      MOVE.B  #1,(OutputType)       
000013EA  6100 0A44                411      BSR    OUTPUT
000013EE                           412      
000013EE  3412                     413      MOVE.W (A2),D2
000013F0  0242 00C0                414      ANDI.W #%0000000011000000, D2 * set to only the size bits
000013F4  EC4A                     415      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013F6                           416  
000013F6                           417  
000013F6                           418      
000013F6                           419      *now to print size  
000013F6  B47C 0002                420      cmp #2,D2 *if the size is 2 branch to long
000013FA  6700 FECA                421      BEQ long
000013FE  B47C 0001                422      cmp #1,D2 *if the size is 1 branch to word
00001402  6700 FEAE                423      BEQ word
00001406  6100 FE96                424      BSR byte *otherwise branch to byte
0000140A                           425      
0000140A  6000 FE90                426      BRA return
0000140E                           427      
0000140E                           428  addq 
0000140E  13FC 0004 00002213       429      MOVE.B  #4,(OutputType)
00001416  6100 0A18                430      BSR     OUTPUT
0000141A                           431     
0000141A  43F9 0000223E            432      LEA    addqout,A1
00001420  13FC 0001 00002213       433      MOVE.B  #1,(OutputType)       
00001428  6100 0A06                434      BSR    OUTPUT
0000142C                           435      
0000142C  3412                     436      MOVE.W (A2),D2
0000142E  0242 00C0                437      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001432  EC4A                     438      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001434                           439  
00001434                           440  
00001434                           441      
00001434                           442      *now to print size  
00001434  B47C 0002                443      cmp #2,D2 *if the size is 2 branch to long
00001438  6700 FE8C                444      BEQ long
0000143C  B47C 0001                445      cmp #1,D2 *if the size is 1 branch to word
00001440  6700 FE70                446      BEQ word
00001444  6100 FE58                447      BSR byte *otherwise branch to byte
00001448                           448      
00001448  6000 FE52                449      BRA return    
0000144C                           450      
0000144C                           451      
0000144C                           452  add
0000144C  13FC 0004 00002213       453      MOVE.B  #4,(OutputType)
00001454  6100 09DA                454      BSR     OUTPUT
00001458                           455  
00001458  43F9 00002235            456      LEA    addout,A1
0000145E  13FC 0001 00002213       457      MOVE.B  #1,(OutputType)       
00001466  6100 09C8                458      BSR    OUTPUT
0000146A                           459      
0000146A  3412                     460      MOVE.W (A2),D2
0000146C  0242 00C0                461      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001470  EC4A                     462      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001472                           463  
00001472                           464  
00001472                           465      
00001472                           466      *now to print size  
00001472  B47C 0002                467      cmp #2,D2 *if the size is 2 branch to long
00001476  6700 FE4E                468      BEQ long
0000147A  B47C 0001                469      cmp #1,D2 *if the size is 1 branch to word
0000147E  6700 FE32                470      BEQ word
00001482  6100 FE1A                471      BSR byte *otherwise branch to byte
00001486                           472      
00001486  6000 FE14                473      BRA return
0000148A                           474  
0000148A                           475  adda
0000148A                           476  
0000148A  13FC 0004 00002213       477      MOVE.B  #4,(OutputType)
00001492  6100 099C                478      BSR     OUTPUT
00001496                           479  
00001496  43F9 00002239            480      LEA    addaout,A1
0000149C  13FC 0001 00002213       481      MOVE.B  #1,(OutputType)       
000014A4  6100 098A                482      BSR    OUTPUT
000014A8                           483      
000014A8  3412                     484      MOVE.W (A2),D2
000014AA  0242 0100                485      ANDI.W #%0000000100000000, D2 * set to only the size bit
000014AE  E04A                     486      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
000014B0                           487  
000014B0                           488  
000014B0                           489      
000014B0                           490      *now to print size  
000014B0  B47C 0001                491      cmp #1,D2 *if the size is 1 branch to long
000014B4  6700 FE10                492      BEQ long
000014B8  B47C 0000                493      cmp #0,D2 *if the size is 0 branch to word
000014BC  6700 FDF4                494      BEQ word
000014C0                           495         
000014C0  6000 FDDA                496      BRA return
000014C4                           497  
000014C4                           498      
000014C4                           499  rts
000014C4  13FC 0004 00002213       500      MOVE.B  #4,(OutputType)
000014CC  6100 0962                501      BSR     OUTPUT
000014D0                           502  
000014D0  43F9 0000226E            503      LEA    rtsout,A1
000014D6  13FC 0001 00002213       504      MOVE.B  #1,(OutputType)       
000014DE  6100 0950                505      BSR    OUTPUT
000014E2  6000 FDB8                506      BRA return
000014E6                           507      
000014E6                           508      
000014E6                           509  jsr 
000014E6  13FC 0004 00002213       510      MOVE.B  #4,(OutputType)
000014EE  6100 0940                511      BSR     OUTPUT
000014F2                           512     
000014F2  43F9 0000226A            513      LEA    jsrout,A1
000014F8  13FC 0001 00002213       514      MOVE.B  #1,(OutputType)       
00001500  6100 092E                515      BSR    OUTPUT
00001504  6000 FD96                516      BRA return
00001508                           517      
00001508                           518      
00001508                           519  not 
00001508  13FC 0004 00002213       520      MOVE.B  #4,(OutputType)
00001510  6100 091E                521      BSR     OUTPUT
00001514                           522    
00001514  43F9 00002247            523      LEA    notout,A1
0000151A  13FC 0001 00002213       524      MOVE.B  #1,(OutputType)       
00001522  6100 090C                525      BSR    OUTPUT
00001526                           526      
00001526  3412                     527      MOVE.W (A2),D2
00001528  0242 00C0                528      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000152C  EC4A                     529      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000152E                           530  
0000152E                           531      *now to print size  
0000152E  B47C 0002                532      cmp #2,D2 *if the size is 2 branch to long
00001532  6700 FD92                533      BEQ long
00001536  B47C 0001                534      cmp #1,D2 *if the size is 1 branch to word
0000153A  6700 FD76                535      BEQ word
0000153E  6100 FD5E                536      BSR byte *otherwise branch to byte
00001542                           537      
00001542                           538  
00001542                           539      
00001542  6000 FD58                540      BRA return
00001546                           541  
00001546                           542  lsl
00001546  13FC 0004 00002213       543      MOVE.B  #4,(OutputType)
0000154E  6100 08E0                544      BSR     OUTPUT
00001552                           545  
00001552  43F9 00002252            546      LEA    lslout,A1
00001558  13FC 0001 00002213       547      MOVE.B  #1,(OutputType)       
00001560  6100 08CE                548      BSR    OUTPUT
00001564                           549      
00001564  3412                     550      MOVE.W (A2),D2
00001566  0242 00C0                551      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000156A  EC4A                     552      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000156C                           553  
0000156C                           554  
0000156C                           555      
0000156C                           556      *now to print size  
0000156C  B47C 0002                557      cmp #2,D2 *if the size is 2 branch to long
00001570  6700 FD54                558      BEQ long
00001574  B47C 0001                559      cmp #1,D2 *if the size is 1 branch to word
00001578  6700 FD38                560      BEQ word
0000157C  6100 FD20                561      BSR byte *otherwise branch to byte
00001580                           562      
00001580  6000 FD1A                563      BRA return
00001584                           564  
00001584                           565  lsr
00001584  13FC 0004 00002213       566      MOVE.B  #4,(OutputType)
0000158C  6100 08A2                567      BSR     OUTPUT
00001590                           568  
00001590  43F9 00002256            569      LEA    lsrout,A1
00001596  13FC 0001 00002213       570      MOVE.B  #1,(OutputType)       
0000159E  6100 0890                571      BSR    OUTPUT
000015A2                           572      
000015A2  3412                     573      MOVE.W (A2),D2
000015A4  0242 00C0                574      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015A8  EC4A                     575      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015AA                           576  
000015AA                           577  
000015AA                           578      
000015AA                           579      *now to print size  
000015AA  B47C 0002                580      cmp #2,D2 *if the size is 2 branch to long
000015AE  6700 FD16                581      BEQ long
000015B2  B47C 0001                582      cmp #1,D2 *if the size is 1 branch to word
000015B6  6700 FCFA                583      BEQ word
000015BA  6100 FCE2                584      BSR byte *otherwise branch to byte
000015BE                           585      
000015BE  6000 FCDC                586      BRA return
000015C2                           587  asl
000015C2  13FC 0004 00002213       588      MOVE.B  #4,(OutputType)
000015CA  6100 0864                589      BSR     OUTPUT
000015CE                           590  
000015CE  43F9 0000225A            591      LEA    aslout,A1
000015D4  13FC 0001 00002213       592      MOVE.B  #1,(OutputType)       
000015DC  6100 0852                593      BSR    OUTPUT
000015E0                           594      
000015E0  3412                     595      MOVE.W (A2),D2
000015E2  0242 00C0                596      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015E6  EC4A                     597      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015E8                           598  
000015E8                           599  
000015E8                           600      
000015E8                           601      *now to print size  
000015E8  B47C 0002                602      cmp #2,D2 *if the size is 2 branch to long
000015EC  6700 FCD8                603      BEQ long
000015F0  B47C 0001                604      cmp #1,D2 *if the size is 1 branch to word
000015F4  6700 FCBC                605      BEQ word
000015F8  6100 FCA4                606      BSR byte *otherwise branch to byte
000015FC                           607      
000015FC  6000 FC9E                608      BRA return
00001600                           609  
00001600                           610  asr
00001600  13FC 0004 00002213       611      MOVE.B  #4,(OutputType)
00001608  6100 0826                612      BSR     OUTPUT
0000160C                           613  
0000160C  43F9 0000225E            614      LEA    asrout,A1
00001612  13FC 0001 00002213       615      MOVE.B  #1,(OutputType)       
0000161A  6100 0814                616      BSR    OUTPUT
0000161E                           617      
0000161E  3412                     618      MOVE.W (A2),D2
00001620  0242 00C0                619      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001624  EC4A                     620      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001626                           621  
00001626                           622  
00001626                           623      
00001626                           624      *now to print size  
00001626  B47C 0002                625      cmp #2,D2 *if the size is 2 branch to long
0000162A  6700 FC9A                626      BEQ long
0000162E  B47C 0001                627      cmp #1,D2 *if the size is 1 branch to word
00001632  6700 FC7E                628      BEQ word
00001636  6100 FC66                629      BSR byte *otherwise branch to byte
0000163A                           630      
0000163A  6000 FC60                631      BRA return
0000163E                           632      
0000163E                           633  rol
0000163E  13FC 0004 00002213       634      MOVE.B  #4,(OutputType)
00001646  6100 07E8                635      BSR     OUTPUT
0000164A                           636  
0000164A  43F9 00002262            637      LEA    rolout,A1
00001650  13FC 0001 00002213       638      MOVE.B  #1,(OutputType)       
00001658  6100 07D6                639      BSR    OUTPUT
0000165C                           640      
0000165C  3412                     641      MOVE.W (A2),D2
0000165E  0242 00C0                642      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001662  EC4A                     643      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001664                           644  
00001664                           645  
00001664                           646      
00001664                           647      *now to print size  
00001664  B47C 0002                648      cmp #2,D2 *if the size is 2 branch to long
00001668  6700 FC5C                649      BEQ long
0000166C  B47C 0001                650      cmp #1,D2 *if the size is 1 branch to word
00001670  6700 FC40                651      BEQ word
00001674  6100 FC28                652      BSR byte *otherwise branch to byte
00001678                           653      
00001678  6000 FC22                654      BRA return
0000167C                           655  
0000167C                           656  ror
0000167C  13FC 0004 00002213       657      MOVE.B  #4,(OutputType)
00001684  6100 07AA                658      BSR     OUTPUT
00001688                           659  
00001688  43F9 00002266            660      LEA    rorout,A1
0000168E  13FC 0001 00002213       661      MOVE.B  #1,(OutputType)       
00001696  6100 0798                662      BSR    OUTPUT
0000169A                           663      
0000169A  3412                     664      MOVE.W (A2),D2
0000169C  0242 00C0                665      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016A0  EC4A                     666      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016A2                           667  
000016A2                           668  
000016A2                           669      
000016A2                           670      *now to print size  
000016A2  B47C 0002                671      cmp #2,D2 *if the size is 2 branch to long
000016A6  6700 FC1E                672      BEQ long
000016AA  B47C 0001                673      cmp #1,D2 *if the size is 1 branch to word
000016AE  6700 FC02                674      BEQ word
000016B2  6100 FBEA                675      BSR byte *otherwise branch to byte
000016B6                           676      
000016B6  6000 FBE4                677      BRA return
000016BA                           678      
000016BA                           679      
000016BA                           680  
000016BA                           681  lea
000016BA  13FC 0004 00002213       682      MOVE.B  #4,(OutputType)
000016C2  6100 076C                683      BSR     OUTPUT
000016C6                           684  
000016C6  43F9 00002243            685      LEA    leaout,A1
000016CC  13FC 0001 00002213       686      MOVE.B  #1,(OutputType)       
000016D4  6100 075A                687      BSR    OUTPUT
000016D8  6000 FBC2                688      BRA return
000016DC                           689      
000016DC                           690  or
000016DC  13FC 0004 00002213       691      MOVE.B  #4,(OutputType)
000016E4  6100 074A                692      BSR     OUTPUT
000016E8                           693  
000016E8  43F9 0000224B            694      LEA    orout,A1
000016EE  13FC 0001 00002213       695      MOVE.B  #1,(OutputType)       
000016F6  6100 0738                696      BSR    OUTPUT
000016FA                           697      
000016FA                           698          
000016FA  3412                     699      MOVE.W (A2),D2
000016FC  0242 00C0                700      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001700  EC4A                     701      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001702                           702  
00001702                           703      *now to print size  
00001702  B47C 0002                704      cmp #2,D2 *if the size is 2 branch to long
00001706  6700 FBBE                705      BEQ long
0000170A  B47C 0001                706      cmp #1,D2 *if the size is 1 branch to word
0000170E  6700 FBA2                707      BEQ word
00001712  6100 FB8A                708      BSR byte *otherwise branch to byte
00001716                           709      
00001716  6000 FB84                710      BRA return
0000171A                           711      
0000171A                           712  and
0000171A  13FC 0004 00002213       713      MOVE.B  #4,(OutputType)
00001722  6100 070C                714      BSR     OUTPUT
00001726                           715  
00001726  43F9 0000224E            716      LEA    andout,A1
0000172C  13FC 0001 00002213       717      MOVE.B  #1,(OutputType)       
00001734  6100 06FA                718      BSR    OUTPUT
00001738                           719      
00001738                           720          
00001738  3412                     721      MOVE.W (A2),D2
0000173A  0242 00C0                722      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000173E  EC4A                     723      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001740                           724  
00001740                           725      *now to print size  
00001740  B47C 0002                726      cmp #2,D2 *if the size is 2 branch to long
00001744  6700 FB80                727      BEQ long
00001748  B47C 0001                728      cmp #1,D2 *if the size is 1 branch to word
0000174C  6700 FB64                729      BEQ word
00001750  6100 FB4C                730      BSR byte *otherwise branch to byte
00001754                           731      
00001754  6000 FB46                732      BRA return    
00001758                           733  
00001758                           734  
00001758                           735  bra
00001758  13FC 0004 00002213       736      MOVE.B  #4,(OutputType)
00001760  6100 06CE                737      BSR     OUTPUT
00001764                           738  
00001764  43F9 00002274            739      LEA    braout,A1
0000176A  13FC 0001 00002213       740      MOVE.B  #1,(OutputType)       
00001772  6100 06BC                741      BSR    OUTPUT
00001776  6000 FB24                742      BRA return
0000177A                           743  
0000177A                           744  data
0000177A  13FC 0004 00002213       745      MOVE.B  #4,(OutputType)
00001782  6100 06AC                746      BSR     OUTPUT
00001786                           747  
00001786  43F9 00002278            748      LEA    dataout,A1
0000178C  13FC 0001 00002213       749      MOVE.B  #1,(OutputType)       
00001794  6100 069A                750      BSR    OUTPUT
00001798                           751      
00001798  13FC 0003 00002213       752      MOVE.B  #3,(OutputType)       
000017A0  6100 068E                753      BSR    OUTPUT *TODO fix data output type
000017A4                           754  
000017A4  6000 FAF6                755      BRA return
000017A8                           756  
000017A8                           757  
000017A8                           758  **********************************************************
000017A8                           759  *Subroutine: USERINPUT
000017A8                           760  *What it does: Takes in user input, rejects bad input
000017A8                           761  *Registers: Uses register A1, D0, D5
000017A8                           762  *A1: Stores messages and user input
000017A8                           763  *D0: Used for TRAP #15
000017A8                           764  *D5: Temporaraly stores user input to be masked then transfered
000017A8                           765  *Paramemeters: No parameters
000017A8                           766  **********************************************************
000017A8                           767  USERINPUT:
000017A8                           768  
000017A8                           769  welcomeExplanation
000017A8  43F9 00001F86            770      LEA     STARTMESSAGE,A1         
000017AE  103C 000E                771      MOVE.B  #14,D0
000017B2  4E4F                     772      TRAP    #15
000017B4                           773      
000017B4  5039 00002212            774      ADD.B   #8,(LineCounter)
000017BA                           775  
000017BA                           776  firstInput
000017BA  43F9 000020F8            777      LEA     INPUT1MESSAGE,A1        
000017C0  103C 000E                778      MOVE.B  #14,D0                  
000017C4  4E4F                     779      TRAP    #15                     Asks user for first input
000017C6  5239 00002212            780      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000017CC                           781      
000017CC  43F9 00008008            782      LEA     userInputStored,A1
000017D2  103C 0002                783      MOVE.B  #2,D0                   
000017D6  4E4F                     784      TRAP    #15                     User can input string for address
000017D8  5239 00002212            785      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000017DE                           786  
000017DE                           787      
000017DE  6100 00BC                788      BSR     CONVERTATOH                 String converted to hex address
000017E2                           789      
000017E2  0C39 0000 00002211       790      CMP.B   #0,(InputQuality)       Checks if bad input flag set
000017EA  6700 0014                791      BEQ     throwInput1CharError
000017EE                           792  
000017EE                           793      
000017EE  CABC 00FFFFFF            794      AND.L   #$00FFFFFF,D5
000017F4  23C5 00008000            795      MOVE.L  D5,input1               Moves result into input 1 memory location
000017FA  4285                     796      CLR.L   D5                      Clears D5 for future use
000017FC  6000 0020                797      BRA     secondInput
00001800                           798      
00001800                           799  throwInput1CharError
00001800  43F9 00002144            800      LEA     INPUTERRORBADCHAR,A1
00001806  103C 000E                801      MOVE.B  #14,D0
0000180A  4E4F                     802      TRAP    #15                     Outputs bad character error message
0000180C  5639 00002212            803      ADD.B   #3,(LineCounter)        Adds 2 to line counter
00001812                           804      
00001812  13FC 0001 00002211       805      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
0000181A  4285                     806      CLR.L   D5                      Clears D5 for future use
0000181C                           807      
0000181C                           808      
0000181C                           809      
0000181C  609C                     810      BRA     firstInput              Tries again for input1
0000181E                           811  
0000181E                           812      
0000181E                           813  secondInput
0000181E  43F9 0000211E            814      LEA     INPUT2MESSAGE,A1        
00001824  103C 000E                815      MOVE.B  #14,D0                  
00001828  4E4F                     816      TRAP    #15                     Asks user for second input
0000182A  5239 00002212            817      ADD.B   #1,(LineCounter)
00001830                           818      
00001830  43F9 00008008            819      LEA     userInputStored,A1
00001836  103C 0002                820      MOVE.B  #2,D0                   
0000183A  4E4F                     821      TRAP    #15                     User can input string for address
0000183C  5239 00002212            822      ADD.B   #1,(LineCounter)
00001842                           823  
00001842                           824      
00001842  6100 0058                825      BSR     CONVERTATOH                 String converted to hex address
00001846                           826  
00001846  0C39 0000 00002211       827      CMP.B   #0,(InputQuality)       
0000184E  6700 001C                828      BEQ     throwInput2CharError    Checks if bad input flag set
00001852                           829      
00001852  CABC 00FFFFFF            830      AND.L   #$00FFFFFF,D5
00001858  BAB9 00008000            831      CMP.L   (input1),D5
0000185E  6D00 0028                832      BLT     throwInput2LowerError
00001862                           833      
00001862                           834      
00001862                           835      
00001862  23C5 00008004            836      MOVE.L  D5,input2               Moves result into input 2 memory location
00001868  4285                     837      CLR.L   D5                      Clears D5 for future use
0000186A  4E75                     838      RTS    
0000186C                           839      
0000186C                           840  throwInput2CharError
0000186C  43F9 00002144            841      LEA     INPUTERRORBADCHAR,A1    
00001872  103C 000E                842      MOVE.B  #14,D0
00001876  4E4F                     843      TRAP    #15                     Outputs bad character error message
00001878                           844      
00001878  5639 00002211            845      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
0000187E  4285                     846      CLR.L   D5                      Clears D5 for future use
00001880                           847      
00001880  5639 00002212            848      ADD.B   #3,(LineCounter)
00001886                           849      
00001886  6096                     850      BRA     secondInput             Tries again for input2
00001888                           851      
00001888                           852  throwInput2LowerError
00001888  43F9 00002162            853      LEA     INPUTERROR2SMALLER,A1
0000188E  103C 000E                854      MOVE.B  #14,D0
00001892  4E4F                     855      TRAP    #15
00001894                           856      
00001894  5639 00002212            857      ADD.B   #3,(LineCounter)
0000189A                           858      
0000189A  6082                     859      BRA     secondInput
0000189C                           860  
0000189C                           861  
0000189C                           862  **********************************************************
0000189C                           863  *Subroutine: CONVERTATOH
0000189C                           864  *What it does: Converts user input to hex code
0000189C                           865  *Registers: Uses register A1, D2, D5
0000189C                           866  *Paramemeters: User input stored in (A1)
0000189C                           867  ********************************************************** 
0000189C                           868  CONVERTATOH:
0000189C                           869      
0000189C                           870  AtoH
0000189C  1419                     871      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
0000189E                           872      
0000189E  B43C 0000                873      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
000018A2  6700 004C                874      BEQ     Finish                  Moves to finish if they are equal (no more input)
000018A6                           875      
000018A6  E985                     876      ASL.L   #4,D5
000018A8                           877      
000018A8  B43C 0030                878      CMP.B   #$30,D2
000018AC  6D00 0044                879      BLT     inputError
000018B0                           880      
000018B0  B43C 0039                881      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
000018B4  6E00 000A                882      BGT     upperCase               Branches if greater, may or may not be a letter in hex
000018B8                           883      
000018B8  0402 0030                884      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
000018BC  DA02                     885      ADD.B   D2,D5
000018BE                           886      
000018BE  60DC                     887      BRA     AtoH
000018C0                           888  
000018C0                           889          
000018C0                           890  upperCase   
000018C0  B43C 0041                891      CMP.B   #$41,D2
000018C4  6D00 002C                892      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
000018C8                           893      
000018C8  B43C 0046                894      CMP.B   #$46,D2                 
000018CC  6E00 000A                895      BGT     lowerCase               Greater than 46 may be hex code in lowercase
000018D0                           896      
000018D0  0402 0037                897      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
000018D4  DA02                     898      ADD.B   D2,D5
000018D6  60C4                     899      BRA     AtoH
000018D8                           900  
000018D8                           901  lowerCase
000018D8  B43C 0061                902      CMP.B   #$61,D2
000018DC  6D00 0014                903      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
000018E0                           904      
000018E0  B43C 0066                905      CMP.B   #$66,D2
000018E4  6E00 000C                906      BGT     InputError              Greater than 66 is not part of hex code
000018E8                           907      
000018E8  0402 0057                908      SUBI.B  #$57,D2
000018EC  DA02                     909      ADD.B   D2,D5
000018EE  60AC                     910      BRA     AtoH
000018F0                           911          
000018F0                           912  Finish
000018F0  4E75                     913      RTS                             Return from CONVERT
000018F2                           914      
000018F2                           915  inputError
000018F2  13FC 0000 00002211       916      MOVE.B  #0,(InputQuality)
000018FA  4E75                     917      RTS
000018FC                           918  
000018FC                           919  *********************************************************************
000018FC                           920  *Subroutine: EA
000018FC                           921  *What it does: Outputs parts of opword, moves to new screen if needed
000018FC                           922  *Registers: Uses register A1, D0,
000018FC                           923  *A1: Used to store messages and single char
000018FC                           924  *Paramemeters: A1
000018FC                           925  *A1: Stores what should be used
000018FC                           926  *********************************************************************  
000018FC  =0000003F                927  BITS0TO5_MASK   EQU %00111111
000018FC  =000000C0                928  BITS7TO8_MASK   EQU %11000000
000018FC  =00000E00                929  BITS9TO11_MASK  EQU %00000111000000000
000018FC                           930  
000018FC  1E3C 000A                931  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001900  BC7C 0000                932                          CMP     #0,D6
00001904  6700 0006                933                          BEQ     IMMEDIATE0
00001908  6000 0004                934                          BRA     IMMEDIATE_END
0000190C  7C08                     935  IMMEDIATE0              MOVEQ   #8,D6
0000190E                           936  
0000190E  4E75                     937  IMMEDIATE_END           RTS
00001910                           938  
00001910  3212                     939  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001912  0201 003F                940                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001916  0001 00C0                941                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
0000191A  1C01                     942                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
0000191C  3212                     943                  MOVE.W  (A2),D1         
0000191E  3412                     944                  MOVE.W  (A2),D2 
00001920  0241 0E00                945                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001924  163C 0009                946                  MOVE.B  #9,D3                   * Prepare shift count
00001928  E669                     947                  LSR.W   D3,D1                   * Move destination register bits right
0000192A  0242 01C0                948                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
0000192E  E64A                     949                  LSR.W   #3,D2                  * Move destination mode bits right
00001930  8242                     950                  OR.W    D2,D1
00001932  1A01                     951                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001934  1206                     952                  MOVE.B  D6,D1               * Pass source into subroutine
00001936  4EB9 00001AF8            953                  JSR     CHECK_VALID_EA
0000193C  1205                     954                  MOVE.B  D5,D1               * Pass destination into subroutine
0000193E  4EB9 00001AF8            955                  JSR     CHECK_VALID_EA
00001944  6100 01F6                956                  BSR print_EA
00001948  6100 0496                957                  BSR print_NEWLINE
0000194C                           958                  
0000194C  4E75                     959                  RTS
0000194E                           960  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
0000194E  3212                     961  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001950  3412                     962          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001952  0201 003F                963          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001956                           964          
00001956  0242 0E00                965          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
0000195A  163C 0009                966          MOVE.B  #9,D3                   * Prepare shift count
0000195E  E66A                     967          LSR.W   D3,D2                   * Move register bits right
00001960  0202 00C7                968          ANDI.B  #%11000111,D2           * Set EA mode
00001964  3612                     969          MOVE.W  (A2),D3
00001966  0803 0008                970          BTST    #8,D3                   * Check opmode
0000196A  6700 000A                971          BEQ     EA1_MODE_ZERO           * Check opmode
0000196E                           972          
0000196E  3A01                     973  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001970  3C02                     974                  MOVE.W  D2,D6           * Set register as source
00001972  6000 0006                975                  BRA EA1_END             * Complete subroutine
00001976                           976          
00001976  3C01                     977  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001978  3A02                     978                  MOVE.W  D2,D5           * Set register as destination
0000197A                           979  
0000197A  0006 00C0                980  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
0000197E  1206                     981                  MOVE.B  D6,D1               * Pass source into subroutine
00001980  4EB9 00001AF8            982                  JSR     CHECK_VALID_EA
00001986  1205                     983                  MOVE.B  D5,D1               * Pass destination into subroutine
00001988  4EB9 00001AF8            984                  JSR     CHECK_VALID_EA
0000198E  6100 01AC                985                  BSR print_EA
00001992  6100 044C                986                  BSR print_NEWLINE
00001996                           987  
00001996  4E75                     988                  RTS
00001998                           989  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001998  3C12                     990  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
0000199A  0246 0E00                991                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
0000199E  163C 0009                992                  MOVE.B  #9,D3                   * Prepare shift count
000019A2  E66E                     993                  LSR.W   D3,D6                   * Move register bits right
000019A4  3612                     994                  MOVE.W  (A2),D3
000019A6  0803 0005                995                  BTST    #5,D3           * Check whether shift count is immediate
000019AA  6700 000A                996                  BEQ     EA2_IMMEDIATE
000019AE                           997   
000019AE  0006 00C0                998  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
000019B2  6000 000A                999                  BRA     EA2_END         * Complete subroutine
000019B6                          1000                  
000019B6  1E3C 000A               1001  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
000019BA  4EB8 18FC               1002                  JSR     FORMAT_IMMEDIATE_DATA
000019BE                          1003                  
000019BE  3A12                    1004  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
000019C0  CA3C 0007               1005                  AND.B   #%00000111,D5
000019C4  1206                    1006                  MOVE.B  D6,D1               * Pass source into subroutine
000019C6  4EB9 00001AF8           1007                  JSR     CHECK_VALID_EA
000019CC  1205                    1008                  MOVE.B  D5,D1               * Pass destination into subroutine
000019CE  4EB9 00001AF8           1009                  JSR     CHECK_VALID_EA
000019D4  6100 0166               1010                  BSR print_EA
000019D8  6100 0406               1011                  BSR print_NEWLINE
000019DC  4E75                    1012                  RTS   
000019DE                          1013  
000019DE                          1014  
000019DE                          1015  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
000019DE  3C12                    1016  EA_GROUP3     MOVE.W  (A2),D6
000019E0  0206 003F               1017          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
000019E4  0006 0080               1018          ORI.B   #%10000000,D6
000019E8  1206                    1019          MOVE.B  D6,D1               * Pass source into subroutine
000019EA  4EB9 00001AF8           1020          JSR     CHECK_VALID_EA
000019F0  6100 014A               1021          BSR print_EA
000019F4  6100 03EA               1022          BSR print_NEWLINE
000019F8  4E75                    1023          RTS
000019FA                          1024  
000019FA                          1025  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
000019FA  3212                    1026  EA_GROUP4     MOVE.W  (A2),D1         
000019FC  0201 003F               1027          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001A00  0001 00C0               1028          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001A04  1C01                    1029          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001A06  3212                    1030          MOVE.W  (A2),D1         
00001A08                          1031          
00001A08  0241 0E00               1032          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001A0C  143C 0009               1033          MOVE.B  #9,D2                   * Prepare shift count
00001A10  E469                    1034          LSR.W   D2,D1                   * Move register bits right
00001A12  0201 00CF               1035          ANDI.B  #%11001111,D1           * Set destination mode
00001A16  0001 0008               1036          ORI.B   #%00001000,D1           * Set destination mode
00001A1A  1A01                    1037          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001A1C  1206                    1038          MOVE.B  D6,D1               * Pass source into subroutine
00001A1E  4EB9 00001AF8           1039          JSR     CHECK_VALID_EA
00001A24  1205                    1040          MOVE.B  D5,D1               * Pass destination into subroutine
00001A26  4EB9 00001AF8           1041          JSR     CHECK_VALID_EA
00001A2C  6100 010E               1042          BSR print_EA
00001A30  6100 03AE               1043          BSR print_NEWLINE
00001A34  4E75                    1044          RTS
00001A36                          1045          
00001A36  3C12                    1046  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001A38  0246 0E00               1047          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001A3C  163C 0009               1048          MOVE.B  #9,D3                   * Prepare shift count
00001A40  E66E                    1049          LSR.W   D3,D6                  * Move source data bits right            !---
00001A42  3A12                    1050          MOVE.W  (A2),D5                 * Prepare destination bits
00001A44  0205 003F               1051          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001A48  4EB8 18FC               1052          JSR     FORMAT_IMMEDIATE_DATA
00001A4C  1206                    1053          MOVE.B  D6,D1               * Pass source into subroutine
00001A4E  4EB9 00001AF8           1054          JSR     CHECK_VALID_EA
00001A54  1205                    1055          MOVE.B  D5,D1               * Pass destination into subroutine
00001A56  4EB9 00001AF8           1056          JSR     CHECK_VALID_EA
00001A5C  4E75                    1057          RTS                                    !---
00001A5E                          1058          
00001A5E  3C12                    1059  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001A60  CC7C 00FF               1060              AND.W   #$00FF,D6                                                   !---
00001A64  3A12                    1061              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001A66  0245 0E00               1062              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001A6A  163C 0009               1063              MOVE.B  #9,D3                   * Prepare shift count
00001A6E  E66D                    1064              LSR.W   D3,D5                   * Move destination register bits right
00001A70  1E3C 000A               1065              MOVE.B  #10,D7
00001A74  1206                    1066              MOVE.B  D6,D1               * Pass source into subroutine
00001A76  4EB9 00001AF8           1067              JSR     CHECK_VALID_EA
00001A7C  1205                    1068              MOVE.B  D5,D1               * Pass destination into subroutine
00001A7E  4EB9 00001AF8           1069              JSR     CHECK_VALID_EA
00001A84  4E75                    1070              RTS                                 !---
00001A86                          1071  
00001A86                          1072  
00001A86                          1073  
00001A86                          1074  
00001A86  3412                    1075  MOVEM_EA   MOVE.W (A2),D2
00001A88  0802 000A               1076             BTST    #10, D2
00001A8C  6700 003E               1077             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001A90                          1078            
00001A90                          1079             
00001A90                          1080                  
00001A90                          1081  *ELSE IT IS  memory-to-register transfers
00001A90                          1082  
00001A90                          1083  
00001A90                          1084  
00001A90                          1085  
00001A90                          1086     
00001A90  E68A                    1087  Memory_to_Register LSR.L #3, D2
00001A92  C43C 0007               1088                     AND.B #$07, D2
00001A96  B43C 0002               1089                     CMP.B #$2,D2
00001A9A  6700 0022               1090                     BEQ   MODE_010
00001A9E  B43C 0003               1091                     CMP.B #$03, D2
00001AA2  6700 001A               1092                     BEQ   MODE_010  
00001AA6  B43C 0007               1093                     CMP.B #$07,D2
00001AAA  6700 0012               1094                     BEQ   MODE_010  
00001AAE  4EF9 00001AB4           1095                     JMP   WRONG_INSTRUCTION    
00001AB4                          1096     
00001AB4  1E3C 0005               1097  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001AB8  2C4A                    1098                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001ABA  3C12                    1099                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001ABC  4E75                    1100                               RTS 
00001ABE                          1101             
00001ABE  3412                    1102  MODE_010  MOVE.W    (A2),D2
00001AC0  C43C 003F               1103            AND.B     #$3F,D2
00001AC4  08C2 0007               1104            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001AC8  1C02                    1105            MOVE.B    D2,D6
00001ACA  4E75                    1106            RTS
00001ACC                          1107  
00001ACC  3412                    1108  Register_to_memory MOVE.W (A2),D2
00001ACE  E68A                    1109                     LSR.L #3, D2
00001AD0  C43C 0007               1110                     AND.B #$07, D2
00001AD4  B43C 0002               1111                     CMP.B #$2,D2
00001AD8  6700 0016               1112                     BEQ   MODE_01_0
00001ADC  B43C 0004               1113                     CMP.B #$04, D2
00001AE0  6700 000E               1114                     BEQ   MODE_01_0 
00001AE4  B43C 0007               1115                     CMP.B #$07,D2
00001AE8  6700 0006               1116                     BEQ   MODE_01_0 
00001AEC  4EF8 1AB4               1117                     JMP   WRONG_INSTRUCTION
00001AF0                          1118                     
00001AF0                          1119  
00001AF0  3C12                    1120  MODE_01_0       MOVE.W  (A2),D6
00001AF2  0206 003F               1121                  ANDI.B  #$3F,D6
00001AF6  4E75                    1122                  RTS
00001AF8                          1123           
00001AF8  1001                    1124  CHECK_VALID_EA  MOVE.B  D1,D0
00001AFA  0200 0038               1125                  ANDI.B  #%111000,D0
00001AFE  E648                    1126                  LSR     #3,D0
00001B00  B03C 0005               1127                  CMP.B   #%00000101,D0
00001B04  6700 002C               1128                  BEQ     INVALID_EA
00001B08  B03C 0006               1129                  CMP.B   #%00000110,D0
00001B0C  6700 0024               1130                  BEQ     INVALID_EA
00001B10  B03C 0007               1131                  CMP.B   #%00000111,D0
00001B14  6700 0004               1132                  BEQ     VALID_EA_PC
00001B18  4E75                    1133                  RTS
00001B1A                          1134                  
00001B1A                          1135                  
00001B1A  1001                    1136  VALID_EA_PC     MOVE.B  D1,D0
00001B1C  0200 0007               1137                  ANDI.B  #%000111,D0
00001B20  B03C 0010               1138                  CMP.B   #%00010000,D0
00001B24  6700 000C               1139                  BEQ     INVALID_EA
00001B28  B03C 0018               1140                  CMP.B   #%00011000,D0
00001B2C  6700 0004               1141                  BEQ     INVALID_EA
00001B30  4E75                    1142                  RTS
00001B32                          1143                  
00001B32  4EB8 1AB4               1144  INVALID_EA      JSR     WRONG_INSTRUCTION
00001B36  3A7C 0005               1145                  MOVE.W  #5, A5
00001B3A  4E75                    1146                  RTS
00001B3C                          1147                  
00001B3C  48E7 FFDE               1148  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001B40  163C 0038               1149                  MOVE.B  #$38,D3
00001B44  C604                    1150                  AND.B   D4,D3
00001B46  C83C 0007               1151                  AND.B   #$7, D4
00001B4A                          1152                  
00001B4A  B63C 0000               1153                  CMP.B   #$0, D3
00001B4E  6600 0014               1154                  BNE     CHECK_EA_AR
00001B52  0604 00D0               1155                  ADD.B   #$D0, D4
00001B56  4281                    1156                  CLR.L   D1
00001B58  1204                    1157                  MOVE.B  D4, D1
00001B5A  4EB9 00001D06           1158                  JSR     PRINT_REGISTOR              * DATA REG
00001B60  6000 0114               1159                  BRA     PRINT_EA_RETURN
00001B64                          1160  
00001B64  B63C 0008               1161  CHECK_EA_AR         CMP.B   #$8, D3
00001B68  6600 0014               1162                      BNE     CHECK_EA_INDIRECT
00001B6C  0604 00A0               1163                      ADD.B   #$A0, D4
00001B70  4281                    1164                      CLR.L   D1
00001B72  1204                    1165                      MOVE.B  D4, D1
00001B74  4EB9 00001D06           1166                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001B7A  6000 00FA               1167                      BRA     PRINT_EA_RETURN
00001B7E                          1168                      
00001B7E  B63C 0010               1169  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001B82  6600 0020               1170                          BNE     CHECK_EA_POST
00001B86  4EB9 00001D5A           1171                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001B8C  0604 00A0               1172                          ADD.B   #$A0, D4
00001B90  4281                    1173                          CLR.L   D1
00001B92  1204                    1174                          MOVE.B  D4, D1
00001B94  4EB9 00001D06           1175                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001B9A  4EB9 00001D6E           1176                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001BA0  6000 00D4               1177                          BRA     PRINT_EA_RETURN
00001BA4                          1178                          
00001BA4  B63C 0018               1179  CHECK_EA_POST   CMP.B   #$18,D3
00001BA8  6600 0026               1180                  BNE     CHECK_EA_PRE
00001BAC  4EB9 00001D5A           1181                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001BB2  0604 00A0               1182                  ADD.B   #$A0, D4
00001BB6  4281                    1183                  CLR.L   D1
00001BB8  1204                    1184                  MOVE.B  D4, D1
00001BBA  4EB9 00001D06           1185                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001BC0  4EB9 00001D6E           1186                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001BC6  4EB9 00001D86           1187                  JSR     PRINT_PLUS                  * +
00001BCC  6000 00A8               1188                  BRA     PRINT_EA_RETURN
00001BD0                          1189  
00001BD0  B63C 0020               1190  CHECK_EA_PRE        CMP.B   #$20,D3
00001BD4  6600 0026               1191                      BNE     CHECK_EA_AB_W
00001BD8  4EB9 00001D9A           1192                      JSR     PRINT_MINUS                 * -
00001BDE  4EB9 00001D5A           1193                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001BE4  0604 00A0               1194                      ADD.B   #$A0, D4
00001BE8  4281                    1195                      CLR.L   D1
00001BEA  1204                    1196                      MOVE.B  D4, D1
00001BEC  4EB9 00001D06           1197                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001BF2  4EB9 00001D6E           1198                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001BF8  6000 007C               1199                      BRA     PRINT_EA_RETURN
00001BFC                          1200  
00001BFC  D604                    1201  CHECK_EA_AB_W           ADD.B   D4,D3
00001BFE  B63C 0038               1202                          CMP.B   #$38,D3     
00001C02  6600 0018               1203                          BNE     CHECK_EA_AB_L
00001C06  4EB9 00001E08           1204                          JSR     PRINT_DOLLAR        * $
00001C0C  3A1A                    1205                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001C0E  163C 0002               1206                          MOVE.B  #2,D3
00001C12  4EB9 00001C9E           1207                          JSR     PRINT_HEX
00001C18  6000 005C               1208                          BRA     PRINT_EA_RETURN
00001C1C                          1209                          
00001C1C  B63C 0039               1210  CHECK_EA_AB_L       CMP.B   #$39, D3
00001C20  6600 0018               1211                      BNE     CHECK_EA_IMM
00001C24  4EB9 00001E08           1212                      JSR     PRINT_DOLLAR        * $
00001C2A  2A1A                    1213                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001C2C  163C 0004               1214                      MOVE.B  #4,D3
00001C30  4EB9 00001C9E           1215                      JSR     PRINT_HEX
00001C36  6000 003E               1216                      BRA     PRINT_EA_RETURN
00001C3A                          1217                      
00001C3A  BE3C 0004               1218  CHECK_EA_IMM        CMP.B   #4,D7
00001C3E  6600 001E               1219                      BNE     READ_WORD_IMM
00001C42  4EB9 00001DF4           1220                      JSR     PRINT_HASH_SIGN     * #
00001C48  4EB9 00001E08           1221                      JSR     PRINT_DOLLAR        * $
00001C4E  2A1A                    1222                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001C50  163C 0004               1223                      MOVE.B  #4,D3
00001C54  4EB9 00001C9E           1224                      JSR     PRINT_HEX
00001C5A  6000 001A               1225                      BRA     PRINT_EA_RETURN
00001C5E                          1226                      
00001C5E  4EB9 00001DF4           1227  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001C64  4EB9 00001E08           1228                      JSR     PRINT_DOLLAR        * $
00001C6A  3A1A                    1229                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001C6C  163C 0002               1230                      MOVE.B  #2,D3
00001C70  4EB9 00001C9E           1231                      JSR     PRINT_HEX
00001C76                          1232  
00001C76  4CDF 7BFF               1233  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001C7A  4E75                    1234                      RTS
00001C7C                          1235  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001C7C                          1236  PRINT_BUFFER    DS.B    10
00001C86= 30 30 30 30 30 30 ...   1237  IPUT_BUFFER_EX  DC.B    '00000000'
00001C8E                          1238  INPUT_BUFFER    DS.B    15                    
00001C9E  48E7 FFFE               1239  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001CA2  43F8 1C7C               1240                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001CA6  D3FC 0000000A           1241                  ADD.L       #10,A1
00001CAC  133C 0000               1242                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001CB0  6000 000E               1243                  BRA         POPULATE_BUFFER
00001CB4                          1244                  
00001CB4  103C 000E               1245  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001CB8  4E4F                    1246                      TRAP        #15
00001CBA  4CDF 7FFF               1247                      MOVEM.L     (SP)+,ALL_REG
00001CBE  4E75                    1248                      RTS
00001CC0                          1249                 
00001CC0  B63C 0000               1250  POPULATE_BUFFER     CMP.B       #0,D3
00001CC4  67EE                    1251                      BEQ         PRINT_HEX_RETURN
00001CC6  183C 000F               1252                      MOVE.B      #$0F,D4
00001CCA  C805                    1253                      AND.B       D5,D4
00001CCC  E81D                    1254                      ROR.B       #4,D5
00001CCE  4EB9 00001CEA           1255                      JSR         HEX_TO_ASCII
00001CD4  1304                    1256                      MOVE.B      D4,-(A1)
00001CD6  1805                    1257                      MOVE.B      D5,D4
00001CD8  C83C 000F               1258                      AND.B       #$0F,D4
00001CDC  4EB9 00001CEA           1259                      JSR         HEX_TO_ASCII
00001CE2  1304                    1260                      MOVE.B      D4,-(A1)
00001CE4  E08D                    1261                      LSR.L       #8,D5
00001CE6  5303                    1262                      SUB.B       #1,D3
00001CE8  60D6                    1263                      BRA         POPULATE_BUFFER
00001CEA                          1264  
00001CEA  48E7 E7FE               1265  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001CEE  B83C 0009               1266                          CMP.B       #9,D4
00001CF2  6F00 000C               1267                          BLE         NUMBER_TO_ASCII
00001CF6  0604 0037               1268                          ADD.B       #$37,D4
00001CFA  4CDF 7FE7               1269  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001CFE  4E75                    1270                          RTS
00001D00                          1271                  
00001D00  0604 0030               1272  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001D04  60F4                    1273                      BRA     HEX_TO_ASCII_RETURN                    
00001D06                          1274                      
00001D06  48E7 FFFE               1275  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001D0A  3F3C 0000               1276                      MOVE.W      #00,-(SP)           *for printing purpose
00001D0E  343C 00F0               1277                      MOVE.W      #$f0,D2             *manipulating each digit
00001D12  C441                    1278                      AND.W       D1,D2
00001D14  E842                    1279                      ASR.W       #4,D2
00001D16  4EB9 00001D3C           1280                      JSR         TO_STRING           * converts to the string ASCII val
00001D1C  E142                    1281                      ASL.W       #8,D2
00001D1E                          1282                      
00001D1E  C27C 000F               1283                      AND.W       #$F,D1              * the last digit
00001D22  1401                    1284                      MOVE.B      D1,D2               
00001D24  4EB9 00001D3C           1285                      JSR         TO_STRING
00001D2A  3F02                    1286                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001D2C                          1287                      
00001D2C  224F                    1288                      MOVE.L      SP,A1               * printing
00001D2E  103C 000E               1289                      MOVE.B      #14,D0
00001D32  4E4F                    1290                      TRAP        #15
00001D34  2A1F                    1291                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001D36                          1292  
00001D36  4CDF 7FFF               1293  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001D3A  4E75                    1294                                  RTS
00001D3C                          1295                                  
00001D3C  B43C 0009               1296  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001D40  6E00 0008               1297              BGT     LETTERS     
00001D44  0602 0030               1298              ADD.B   #$30,D2             * offseting digit
00001D48  4E75                    1299              RTS
00001D4A  0602 0037               1300  LETTERS     ADD.B   #$37,D2             * offseting leter
00001D4E  4E75                    1301              RTS   
00001D50                          1302  
00001D50                          1303  *________________________________________________________________________________________
00001D50                          1304  
00001D50                          1305  
00001D50                          1306  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001D50                          1307          *PARAMENTER     NO PARAMETER NEEDED
00001D50= 28 00                   1308  OPEN_PAR_TAG        DC.B    '(',0  
00001D52= 29 00                   1309  CLOSED_PAR_TAG      DC.B    ')',0
00001D54= 23 00                   1310  HASH_SIGN_TAG       DC.B    '#',0
00001D56= 24 00                   1311  DOLLAR_TAG          DC.B    '$',0
00001D58= 2F 00                   1312  FORWARD_SLASH_TAG   DC.B    '/',0      
00001D5A  48E7 FFFE               1313  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001D5E  43F8 1D50               1314                          LEA         OPEN_PAR_TAG, A1
00001D62  103C 000E               1315                          MOVE.B      #14,D0
00001D66  4E4F                    1316                          TRAP        #15
00001D68  4CDF 7FFF               1317                          MOVEM.L     (SP)+,ALL_REG
00001D6C  4E75                    1318                          RTS
00001D6E                          1319  *_________________________________________________________________________________
00001D6E                          1320  
00001D6E                          1321  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001D6E                          1322          *PARAMENTER     NO PARAMETER NEEDED
00001D6E                          1323          
00001D6E  48E7 FFFE               1324  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001D72  43F8 1D52               1325                              LEA         CLOSED_PAR_TAG, A1
00001D76  103C 000E               1326                              MOVE.B      #14,D0
00001D7A  4E4F                    1327                              TRAP        #15
00001D7C  4CDF 7FFF               1328                              MOVEM.L     (SP)+,ALL_REG
00001D80  4E75                    1329                              RTS
00001D82                          1330  *__________________________________________________________________________________
00001D82                          1331  
00001D82                          1332  *________________ PRINT PLUS SIGN _________________________________________________
00001D82                          1333          *PARAMENTER     NO PARAMETER NEEDED
00001D82= 2B 00                   1334  PLUS_TAG            DC.B    '+',0
00001D84= 2D 00                   1335  MINUS_TAG           DC.B    '-',0        
00001D86  48E7 FFFE               1336  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001D8A  43F8 1D82               1337                  LEA         PLUS_TAG, A1
00001D8E  103C 000E               1338                  MOVE.B      #14,D0
00001D92  4E4F                    1339                  TRAP        #15
00001D94  4CDF 7FFF               1340                  MOVEM.L     (SP)+,ALL_REG
00001D98  4E75                    1341                  RTS
00001D9A                          1342  *_________________________________________________________________________________
00001D9A                          1343  
00001D9A                          1344  *________________ PRINT MINUS SIGN _______________________________________________
00001D9A                          1345          *PARAMENTER     NO PARAMETER NEEDED
00001D9A                          1346          
00001D9A  48E7 FFFE               1347  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001D9E  43F8 1D84               1348                      LEA         MINUS_TAG, A1
00001DA2  103C 000E               1349                      MOVE.B      #14,D0
00001DA6  4E4F                    1350                      TRAP        #15
00001DA8  4CDF 7FFF               1351                      MOVEM.L     (SP)+,ALL_REG
00001DAC  4E75                    1352                      RTS
00001DAE                          1353  *_________________________________________________________________________________
00001DAE                          1354  
00001DAE                          1355  *________________ PRINT COMMA ____________________________________________________
00001DAE                          1356          *PARAMENTER     NO PARAMETER NEEDED
00001DAE= 09 00                   1357  TAB_TAG         DC.B    $9,0
00001DB0= 20 00                   1358  SPACE_TAG       DC.B    ' ',0
00001DB2= 2C 00                   1359  COMMA_TAG       DC.B    ',',0        
00001DB4  48E7 FFFE               1360  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001DB8  43F8 1DB2               1361                      LEA         COMMA_TAG, A1
00001DBC  103C 000E               1362                      MOVE.B      #14,D0
00001DC0  4E4F                    1363                      TRAP        #15
00001DC2  4CDF 7FFF               1364                      MOVEM.L     (SP)+,ALL_REG
00001DC6  4E75                    1365                      RTS
00001DC8                          1366  *_________________________________________________________________________________
00001DC8                          1367  
00001DC8                          1368  *________________ PRINT TAB ______________________________________________________
00001DC8                          1369          *PARAMENTER     NO PARAMETER NEEDED
00001DC8                          1370          
00001DC8  48E7 FFFE               1371  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001DCC  43F8 1DAE               1372                  LEA         TAB_TAG, A1
00001DD0  103C 000E               1373                  MOVE.B      #14,D0
00001DD4  4E4F                    1374                  TRAP        #15
00001DD6  4CDF 7FFF               1375                  MOVEM.L     (SP)+,ALL_REG
00001DDA  4E75                    1376                  RTS
00001DDC                          1377  *_________________________________________________________________________________
00001DDC                          1378  
00001DDC                          1379  
00001DDC                          1380  *_______________    PRINT NEWLINE   ________________________________________________
00001DDC                          1381          *PARAMETER NO PARAMETER NEEDED
00001DDC= 0D 0A 00                1382  NEWLINE_TAG         DC.B    CR,LF,0        
00001DE0  48E7 FFFE               1383  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001DE4  43F8 1DDC               1384                      LEA         NEWLINE_TAG, A1
00001DE8  103C 000E               1385                      MOVE.B      #14,D0
00001DEC  4E4F                    1386                      TRAP        #15
00001DEE  4CDF 7FFF               1387                      MOVEM.L     (SP)+,ALL_REG
00001DF2  4E75                    1388                      RTS
00001DF4                          1389  
00001DF4                          1390  *___________________________________________________________________________________
00001DF4                          1391  
00001DF4                          1392  
00001DF4                          1393  *_______________    PRINT HASH SIGN   ________________________________________________
00001DF4                          1394          *PARAMETER NO PARAMETER NEEDED
00001DF4                          1395          
00001DF4  48E7 FFFE               1396  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001DF8  43F8 1D54               1397                      LEA         HASH_SIGN_TAG, A1
00001DFC  103C 000E               1398                      MOVE.B      #14,D0
00001E00  4E4F                    1399                      TRAP        #15
00001E02  4CDF 7FFF               1400                      MOVEM.L     (SP)+,ALL_REG
00001E06  4E75                    1401                      RTS
00001E08                          1402  
00001E08                          1403  *___________________________________________________________________________________
00001E08                          1404  
00001E08                          1405  
00001E08                          1406  
00001E08                          1407  *_______________    PRINT DOLLAR   ________________________________________________
00001E08                          1408          *PARAMETER NO PARAMETER NEEDED
00001E08                          1409          
00001E08  48E7 FFFE               1410  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001E0C  43F8 1D56               1411                      LEA         DOLLAR_TAG, A1
00001E10  103C 000E               1412                      MOVE.B      #14,D0
00001E14  4E4F                    1413                      TRAP        #15
00001E16  4CDF 7FFF               1414                      MOVEM.L     (SP)+,ALL_REG
00001E1A  4E75                    1415                      RTS
00001E1C                          1416  
00001E1C                          1417  *___________________________________________________________________________________
00001E1C                          1418  
00001E1C                          1419  
00001E1C                          1420  
00001E1C                          1421  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001E1C                          1422          *PARAMETER NO PARAMETER NEEDED
00001E1C                          1423          
00001E1C  48E7 FFFE               1424  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001E20  43F8 1D58               1425                          LEA         FORWARD_SLASH_TAG, A1
00001E24  103C 000E               1426                          MOVE.B      #14,D0
00001E28  4E4F                    1427                          TRAP        #15
00001E2A  4CDF 7FFF               1428                          MOVEM.L     (SP)+,ALL_REG
00001E2E  4E75                    1429                          RTS
00001E30                          1430  
00001E30                          1431  
00001E30                          1432     
00001E30                          1433  *********************************************************************
00001E30                          1434  *Subroutine: OUTPUT
00001E30                          1435  *What it does: Outputs parts of opword, moves to new screen if needed
00001E30                          1436  *Registers: Uses register A1, D0,
00001E30                          1437  *A1: Used to store messages and single char
00001E30                          1438  *Paramemeters: A1, A2
00001E30                          1439  *A1: Stores what should be used
00001E30                          1440  *********************************************************************  
00001E30                          1441  
00001E30                          1442       OUTPUT:
00001E30                          1443       
00001E30  0C39 0001 00002213      1444       CMP.B  #1,(OutputType)
00001E38  6700 0026               1445       BEQ    outputOpcode
00001E3C  0C39 0002 00002213      1446       CMP.B  #2,(OutputType)
00001E44  6700 0066               1447       BEQ    OutputSize
00001E48  0C39 0003 00002213      1448       CMP.B  #3,(OutputType)
00001E50  6700 0062               1449       BEQ    OutputData
00001E54  0C39 0004 00002213      1450       CMP.B  #4,(OutputType)
00001E5C  6700 00AC               1451       BEQ    OutputAddress
00001E60                          1452       
00001E60                          1453  outputOpcode    
00001E60  0C39 001E 00002212      1454       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001E68  6C00 0010               1455       BGE    outputOpcodeNewScreen
00001E6C                          1456       
00001E6C  103C 000E               1457       MOVE.B #14,D0
00001E70  4E4F                    1458       TRAP   #15
00001E72                          1459       
00001E72  5239 00002212           1460       ADD.B  #1,(LineCounter)
00001E78                          1461       
00001E78  4E75                    1462       RTS
00001E7A                          1463       
00001E7A                          1464       
00001E7A                          1465  outputOpcodeNewScreen
00001E7A  2F09                    1466       MOVE.L A1,-(SP)                Storing last message to be used later
00001E7C                          1467       
00001E7C  43F9 000021E8           1468       LEA    OUTPUTNEWSCREEN,A1         
00001E82  103C 000E               1469       MOVE.B #14,D0
00001E86  4E4F                    1470       TRAP   #15
00001E88                          1471       
00001E88  43F9 00008008           1472       LEA    userInputStored,A1         Pauses program to show screen full of data
00001E8E  103C 0002               1473       MOVE.B #2,D0
00001E92  4E4F                    1474       TRAP   #15
00001E94                          1475       
00001E94  13FC 0000 00002212      1476       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001E9C                          1477       
00001E9C  225F                    1478       MOVE.L (SP)+,A1                Retriving message to be used
00001E9E                          1479       
00001E9E  103C 000E               1480       MOVE.B #14,D0                  Outputting decoded message
00001EA2  4E4F                    1481       TRAP   #15
00001EA4                          1482       
00001EA4  5239 00002212           1483       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001EAA                          1484       
00001EAA  4E75                    1485       RTS
00001EAC                          1486       
00001EAC                          1487  outputSize
00001EAC  103C 000E               1488      MOVE.B  #14,D0
00001EB0  4E4F                    1489      TRAP    #15
00001EB2  4E75                    1490      RTS
00001EB4                          1491  outputData
00001EB4  267C 00000800           1492      MOVE.L   #$800,A3
00001EBA  3692                    1493      MOVE.W  (A2),(A3)
00001EBC  2F06                    1494      MOVE.L  D6,-(SP)
00001EBE  103C 0000               1495      MOVE.B  #0,D0
00001EC2  43F9 00009005           1496      LEA     addressOutput,A1
00001EC8                          1497  
00001EC8                          1498  outputDataLoop
00001EC8                          1499  *check if loop has run 4 times
00001EC8  B03C 0002               1500      CMP.B   #2,D0
00001ECC  6700 001C               1501      BEQ     outputDataLoopEnd
00001ED0                          1502      *Grab byte from address, dont increment
00001ED0  1C13                    1503      MOVE.B  (A3),D6
00001ED2                          1504      *LSR to isolate left bit
00001ED2  E80E                    1505      LSR.B   #4,D6
00001ED4                          1506      *Call converthtoa
00001ED4  6100 008A               1507      BSR     CONVERTHTOA
00001ED8  12C6                    1508      MOVE.B  D6,(A1)+   
00001EDA                          1509      *Grab bye from address, increment
00001EDA  1C1B                    1510      MOVE.B  (A3)+,D6
00001EDC                          1511      *AND Mask second digit
00001EDC  CC3C 000F               1512      AND.B   #$0F,D6
00001EE0  6100 007E               1513      BSR     CONVERTHTOA
00001EE4  12C6                    1514      MOVE.B  D6,(A1)+
00001EE6  5200                    1515      ADD.B   #1,D0
00001EE8  60DE                    1516      BRA     outputDataLoop
00001EEA                          1517      
00001EEA                          1518  outputDataLoopEnd
00001EEA  12BC 0000               1519      MOVE.B  #$00,(A1)
00001EEE  2C1F                    1520      MOVE.L  (SP)+,D6
00001EF0  43F9 00009005           1521      LEA     addressOutput,A1
00001EF6  103C 000E               1522      MOVE.B  #14,D0
00001EFA  4E4F                    1523      TRAP    #15
00001EFC                          1524      
00001EFC  43F9 0000220B           1525      LEA     NEWLINE,A1
00001F02  103C 000E               1526      MOVE.B  #14,D0
00001F06  4E4F                    1527      TRAP    #15
00001F08                          1528  
00001F08  4E75                    1529      RTS
00001F0A                          1530   
00001F0A                          1531      
00001F0A                          1532  outputAddress
00001F0A  267C 00000800           1533      MOVE.L  #$800,A3
00001F10  268A                    1534      MOVE.L  A2,(A3)
00001F12  2F06                    1535      MOVE.L  D6,-(SP)
00001F14  103C 0000               1536      MOVE.B  #0,D0
00001F18  43F9 00009005           1537      LEA     addressOutput,A1
00001F1E                          1538  outputAddressLoop
00001F1E                          1539      *check if loop has run 4 times
00001F1E  B03C 0004               1540      CMP.B   #4,D0
00001F22  6700 001C               1541      BEQ     outputAddressLoopEnd
00001F26                          1542      *Grab byte from address, dont increment
00001F26  1C13                    1543      MOVE.B  (A3),D6
00001F28                          1544      *LSR to isolate left bit
00001F28  E80E                    1545      LSR.B   #4,D6
00001F2A                          1546      *Call converthtoa
00001F2A  6100 0034               1547      BSR     CONVERTHTOA
00001F2E  12C6                    1548      MOVE.B  D6,(A1)+   
00001F30                          1549      *Grab bye from address, increment
00001F30  1C1B                    1550      MOVE.B  (A3)+,D6
00001F32                          1551      *AND Mask second digit
00001F32  CC3C 000F               1552      AND.B   #$0F,D6
00001F36  6100 0028               1553      BSR     CONVERTHTOA
00001F3A  12C6                    1554      MOVE.B  D6,(A1)+
00001F3C  5200                    1555      ADD.B   #1,D0
00001F3E  60DE                    1556      BRA     outputAddressLoop
00001F40                          1557      
00001F40                          1558      
00001F40                          1559  outputAddressLoopEnd
00001F40  12BC 0000               1560      MOVE.B  #$00,(A1)
00001F44  2C1F                    1561      MOVE.L  (SP)+,D6
00001F46  43F9 00009005           1562      LEA     addressOutput,A1
00001F4C                          1563      
00001F4C  103C 000E               1564      MOVE.B  #14,D0
00001F50  4E4F                    1565      TRAP    #15
00001F52                          1566      
00001F52  43F9 0000220E           1567      LEA     spaces,A1
00001F58  103C 000E               1568      MOVE.B  #14,D0
00001F5C  4E4F                    1569      TRAP    #15
00001F5E                          1570  
00001F5E                          1571  
00001F5E  4E75                    1572      RTS
00001F60                          1573  
00001F60                          1574  *********************************************************************
00001F60                          1575  *Subroutine: CONVERTHTOA
00001F60                          1576  *What it does: Converts HEX to ASCII
00001F60                          1577  *Registers: Uses register D6,D0
00001F60                          1578  *D6: Stores hex character to be converted
00001F60                          1579  *Paramemeters: D6
00001F60                          1580  *D6: Stores hex characcter to be converted
00001F60                          1581  *********************************************************************
00001F60                          1582      CONVERTHTOA:
00001F60                          1583      
00001F60  BC3C 0009               1584      CMP.B   #9,D6
00001F64  6F00 0006               1585      BLE     zerotonine
00001F68  6000 000A               1586      BRA     AtoF
00001F6C                          1587      
00001F6C                          1588  zerotonine    
00001F6C  0686 00000030           1589      ADD.L   #$30,D6
00001F72  4E75                    1590      RTS
00001F74                          1591  AtoF
00001F74  0686 00000037           1592      ADD.L   #$37,D6
00001F7A  4E75                    1593      RTS
00001F7C                          1594      
00001F7C                          1595  END_SIMULATION:
00001F7C                          1596          
00001F7C  103C 0009               1597      MOVE.B  #9,D0
00001F80  4E4F                    1598      TRAP    #15
00001F82                          1599  
00001F82  FFFF FFFF               1600      SIMHALT             ; halt simulator
00001F86                          1601  
00001F86                          1602  * Put variables and constants here
00001F86= 57 65 6C 63 6F 6D ...   1603  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
00001FAC= 53 6F 6D 65 20 71 ...   1604                  DC.B    'Some quick rules:',CR,LF
00001FBF= 31 29 20 4F 6E 6C ...   1605                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
00001FFB= 32 29 20 54 68 65 ...   1606                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
00002046= 33 29 20 41 6E 79 ...   1607                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
0000208A= 20 20 20 77 69 6C ...   1608                  DC.B    '   will be rejected',CR,LF
0000209F= 34 29 20 54 68 65 ...   1609                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
000020E2= 20 20 20 77 69 6C ...   1610                  DC.B    '   will be rejected',CR,LF,0      
000020F8= 50 6C 65 61 73 65 ...   1611  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
0000211E= 50 6C 65 61 73 65 ...   1612  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
00002144                          1613  
00002144= 0D 0A 54 68 69 73 ...   1614  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
00002162= 0D 0A 49 6E 70 75 ...   1615  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
0000219E                          1616  
0000219E= 54 6F 20 72 65 70 ...   1617  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
000021E8                          1618  
000021E8= 50 6C 65 61 73 65 ...   1619  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
0000220B                          1620  
0000220B= 0D 0A 00                1621  NEWLINE     DC.B    CR,LF,0
0000220E= 20 20 00                1622  SPACES      DC.B    '  ',0
00002211                          1623  
00002211= 01                      1624  InputQuality    DC.B    1       Set to 1 for default good
00002212= 00                      1625  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
00002213= 00                      1626  OutputType      DC.B    0      To track what type is being output
00002214                          1627  
00002214= 4E 4F 50 0D 0A 00       1628  nopout  DC.B    'NOP',CR,LF,0
0000221A= 4D 4F 56 45 00          1629  moveout  DC.B    'MOVE',0
0000221F= 4D 4F 56 45 41 00       1630  moveaout DC.B      'MOVEA',0
00002225= 4D 4F 56 45 51 00       1631  moveqout DC.B   'MOVEQ',0
0000222B= 4D 4F 56 45 4D 00       1632  movemout DC.B   'MOVEM',0
00002231                          1633  
00002231= 53 55 42 00             1634  subout    DC.B  'SUB',0
00002235= 41 44 44 00             1635  addout    DC.B 'ADD',0
00002239= 41 44 44 41 00          1636  addaout    DC.B 'ADDA',0
0000223E= 41 44 44 51 00          1637  addqout    DC.B 'ADDQ',0
00002243                          1638  
00002243= 4C 45 41 00             1639  leaout    DC.B  'LEA',0
00002247                          1640  
00002247= 4E 4F 54 00             1641  notout    DC.B  'NOT',0
0000224B= 4F 52 00                1642  orout DC.B     'OR',0
0000224E= 41 4E 44 00             1643  andout DC.B     'AND',0
00002252                          1644  
00002252                          1645  
00002252= 4C 53 4C 00             1646  lslout    DC.B  'LSL',0
00002256= 4C 53 52 00             1647  lsrout    DC.B  'LSR',0
0000225A= 41 53 4C 00             1648  aslout    DC.B  'ASL',0
0000225E= 41 53 52 00             1649  asrout    DC.B  'ASR',0
00002262                          1650  
00002262= 52 4F 4C 00             1651  rolout    DC.B  'ROL',0
00002266= 52 4F 52 00             1652  rorout    DC.B  'ROR',0
0000226A                          1653  
0000226A= 4A 53 52 00             1654  jsrout DC.B     'JSR',0
0000226E= 52 54 53 0D 0A 00       1655  rtsout DC.B     'RTS',CR,LF,0
00002274= 42 52 41 00             1656  braout DC.B     'BRA',0
00002278                          1657  
00002278= 44 41 54 41 20 20 ...   1658  dataout DC.B    'DATA   ',0
00002280                          1659  
00002280                          1660  
00002280                          1661  
00002280= 2E 42 20 20 20 20 00    1662  byteout  DC.B    '.B    ',0
00002287= 2E 57 20 20 20 20 00    1663  wordout  DC.B    '.W    ',0
0000228E= 2E 4C 20 20 20 20 00    1664  longout  DC.B    '.L    ',0
00002295                          1665  
00002295= 0D 0A 00                1666  empty    DC.B    '',CR,LF,0
00002298                          1667  
00002298  =0000000D               1668  CR  EQU $0D
00002298  =0000000A               1669  LF  EQU $0A
00002298                          1670  
00002298                          1671  
00002298                          1672      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 144C
ADDA                148A
ADDAOUT             2239
ADDOUT              2235
ADDQ                140E
ADDQOUT             223E
ADDQ_EA             1A36
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 171A
ANDOUT              224E
ASL                 15C2
ASLOUT              225A
ASR                 1600
ASROUT              225E
ATOF                1F74
ATOH                189C
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BRA                 1758
BRAOUT              2274
BYTE                129E
BYTEOUT             2280
CHECK_EA_AB_L       1C1C
CHECK_EA_AB_W       1BFC
CHECK_EA_AR         1B64
CHECK_EA_IMM        1C3A
CHECK_EA_INDIRECT   1B7E
CHECK_EA_POST       1BA4
CHECK_EA_PRE        1BD0
CHECK_VALID_EA      1AF8
CLOSED_PAR_TAG      1D52
COMMA_TAG           1DB2
CONVERTATOH         189C
CONVERTHTOA         1F60
CR                  D
DATA                177A
DATAOUT             2278
DOLLAR_TAG          1D56
EA1_END             197A
EA1_MODE_ONE        196E
EA1_MODE_ZERO       1976
EA2_END             19BE
EA2_IMMEDIATE       19B6
EA2_REGISTER        19AE
EA_GROUP1           194E
EA_GROUP2           1998
EA_GROUP3           19DE
EA_GROUP4           19FA
EMPTY               2295
END_SIMULATION      1F7C
FINISH              18F0
FIRSTINPUT          17BA
FORMAT_IMMEDIATE_DATA  18FC
FORWARD_SLASH_TAG   1D58
HASH_SIGN_TAG       1D54
HERE                1020
HEX_TO_ASCII        1CEA
HEX_TO_ASCII_RETURN  1CFA
IMMEDIATE0          190C
IMMEDIATE_END       190E
INPUT1              8000
INPUT1MESSAGE       20F8
INPUT2              8004
INPUT2MESSAGE       211E
INPUTERROR          18F2
INPUTERROR2SMALLER  2162
INPUTERRORBADCHAR   2144
INPUTQUALITY        2211
INPUTREPEAT         219E
INPUT_BUFFER        1C8E
INVALID_EA          1B32
IPUT_BUFFER_EX      1C86
JSR                 14E6
JSROUT              226A
LEA                 16BA
LEAOUT              2243
LETSGO              1058
LETTERS             1D4A
LF                  A
LINECOUNTER         2212
LONG                12C6
LONGOUT             228E
LOWERCASE           18D8
LSL                 1546
LSLOUT              2252
LSR                 1584
LSROUT              2256
MEMORY_TO_REGISTER  1A90
MINUS_TAG           1D84
MODE_010            1ABE
MODE_01_0           1AF0
MOVE                12FA
MOVEA               1342
MOVEAOUT            221F
MOVEM               139A
MOVEMOUT            222B
MOVEM_EA            1A86
MOVEOUT             221A
MOVEQ               1378
MOVEQOUT            2225
MOVEQ_EA            1A5E
MOVE_MOVEA_EA       1910
NEWLINE             220B
NEWLINE_TAG         1DDC
NOP                 12DA
NOPOUT              2214
NOT                 1508
NOTOUT              2247
NUMBER_TO_ASCII     1D00
OPCODE              11A0
OPEN_PAR_TAG        1D50
OR                  16DC
OROUT               224B
OUTPUT              1E30
OUTPUTADDRESS       1F0A
OUTPUTADDRESSLOOP   1F1E
OUTPUTADDRESSLOOPEND  1F40
OUTPUTDATA          1EB4
OUTPUTDATALOOP      1EC8
OUTPUTDATALOOPEND   1EEA
OUTPUTNEWSCREEN     21E8
OUTPUTOPCODE        1E60
OUTPUTOPCODENEWSCREEN  1E7A
OUTPUTSIZE          1EAC
OUTPUTTYPE          2213
PLUS_TAG            1D82
POPULATE_BUFFER     1CC0
PRINT_BUFFER        1C7C
PRINT_CLOSED_PARENTHESIS  1D6E
PRINT_COMMA         1DB4
PRINT_DOLLAR        1E08
PRINT_EA            1B3C
PRINT_EA_RETURN     1C76
PRINT_FORWARD_SLASH  1E1C
PRINT_HASH_SIGN     1DF4
PRINT_HEX           1C9E
PRINT_HEX_RETURN    1CB4
PRINT_MINUS         1D9A
PRINT_NEWLINE       1DE0
PRINT_OPEN_PARENTHESIS  1D5A
PRINT_PLUS          1D86
PRINT_REGISTOR      1D06
PRINT_REGISTOR_RETURN  1D36
PRINT_TAB           1DC8
READ_WORD_IMM       1C5E
REGISTER_TO_MEMORY  1ACC
RETURN              129C
ROL                 163E
ROLOUT              2262
ROR                 167C
ROROUT              2266
RTS                 14C4
RTSOUT              226E
SECONDINPUT         181E
SPACES              220E
SPACE_TAG           1DB0
START               1000
STARTMESSAGE        1F86
SUB                 13D0
SUBOUT              2231
TAB_TAG             1DAE
THERE               1174
THROWINPUT1CHARERROR  1800
THROWINPUT2CHARERROR  186C
THROWINPUT2LOWERERROR  1888
TO_STRING           1D3C
UPPERCASE           18C0
USERINPUT           17A8
USERINPUTREPEAT     1176
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1B1A
WELCOMEEXPLANATION  17A8
WORD                12B2
WORDOUT             2287
WRONG_INSTRUCTION   1AB4
ZEROTONINE          1F6C
