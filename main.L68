00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 12:27:01 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 000021EA        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 0776                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 0000114C             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048                            42  
00001048                            43  
00001048                            44      
00001048                            45  * calls-------------------------------------------------------
00001048  347C 100C                 46      MOVE.W #$100C, A2
0000104C  6100 012A                 47      BSR     OPCODE * test MOVE.B
00001050                            48  
00001050  347C 1010                 49      MOVE.W #$1010, A2
00001054  6100 0122                 50      BSR     OPCODE * test MOVEA.W
00001058                            51      
00001058  347C 1014                 52      MOVE.W #$1014, A2
0000105C  6100 011A                 53      BSR     OPCODE * test MOVEQ
00001060                            54     
00001060  347C 1016                 55      MOVE.W #$1016, A2
00001064  6100 0112                 56      BSR     OPCODE *test MOVEA.L
00001068                            57      
00001068  347C 1018                 58      MOVE.W #$1018, A2
0000106C  6100 010A                 59      BSR     OPCODE *test DATA
00001070                            60      
00001070                            61      
00001070  347C 101A                 62      MOVE.W #$101A, A2
00001074  6100 0102                 63      BSR     OPCODE *test SUB.L
00001078                            64      
00001078  347C 101C                 65      MOVE.W #$101C, A2
0000107C  6100 00FA                 66      BSR     OPCODE *test BRA
00001080                            67      
00001080  347C 1020                 68      MOVE.W #$1020, A2
00001084  6100 00F2                 69      BSR     OPCODE *test JSR
00001088                            70      
00001088                            71      
00001088  43F9 0000226D             72      LEA empty,A1
0000108E  13FC 0001 000021EB        73      MOVE.B  #1,(OutputType)       
00001096  6100 0D70                 74      BSR    OUTPUT
0000109A                            75  
0000109A                            76      
0000109A  347C 1026                 77      MOVE.W #$1026, A2
0000109E  6100 00D8                 78      BSR     OPCODE *test NOT
000010A2                            79      
000010A2  347C 1028                 80      MOVE.W #$1028, A2
000010A6  6100 00D0                 81      BSR     OPCODE *test LEA
000010AA                            82      
000010AA  347C 102A                 83      MOVE.W #$102A, A2
000010AE  6100 00C8                 84      BSR     OPCODE *test OR
000010B2                            85      
000010B2  43F9 0000226D             86       LEA empty,A1
000010B8  13FC 0001 000021EB        87      MOVE.B  #1,(OutputType)       
000010C0  6100 0D46                 88      BSR    OUTPUT
000010C4                            89  
000010C4                            90      
000010C4  347C 1030                 91      MOVE.W #$1030, A2
000010C8  6100 00AE                 92      BSR     OPCODE *test MOVEM
000010CC                            93  
000010CC  347C 1034                 94      MOVE.W #$1034, A2
000010D0  6100 00A6                 95      BSR     OPCODE *test AND
000010D4                            96      
000010D4  347C 1036                 97      MOVE.W #$1036, A2
000010D8  6100 009E                 98      BSR     OPCODE *test ADD
000010DC                            99      
000010DC  43F9 0000226D            100      LEA empty,A1
000010E2  13FC 0001 000021EB       101      MOVE.B  #1,(OutputType) * new line  
000010EA  6100 0D1C                102      BSR    OUTPUT
000010EE                           103  
000010EE  347C 1038                104      MOVE.W #$1038, A2
000010F2  6100 0084                105      BSR     OPCODE *test ADDA
000010F6                           106      
000010F6  347C 103A                107      MOVE.W #$103A, A2
000010FA  6100 007C                108      BSR     OPCODE *test ADDQ
000010FE                           109      
000010FE  347C 103C                110      MOVE.W #$103C, A2
00001102  6100 0074                111      BSR     OPCODE *test LSL
00001106                           112  
00001106  347C 103E                113      MOVE.W #$103E, A2
0000110A  6100 006C                114      BSR     OPCODE *test LSR
0000110E                           115      
0000110E  347C 1040                116      MOVE.W #$1040, A2
00001112  6100 0064                117      BSR     OPCODE *test ASL
00001116                           118      
00001116  43F9 0000226D            119      LEA empty,A1
0000111C  13FC 0001 000021EB       120      MOVE.B  #1,(OutputType) * new line  
00001124  6100 0CE2                121      BSR    OUTPUT
00001128                           122  
00001128                           123  
00001128  347C 1042                124      MOVE.W #$1042, A2
0000112C  6100 004A                125      BSR     OPCODE *test ASR
00001130                           126      
00001130                           127      
00001130  347C 1044                128      MOVE.W #$1044, A2
00001134  6100 0042                129      BSR     OPCODE *test ROL
00001138                           130  
00001138  347C 1046                131      MOVE.W #$1046, A2
0000113C  6100 003A                132      BSR     OPCODE *test ROR
00001140                           133  
00001140                           134  
00001140                           135    
00001140  347C 10B4                136      MOVE.W #$10B4, A2
00001144  6100 0032                137      BSR     OPCODE *test RTS
00001148                           138  
00001148                           139  
00001148                           140  * calls---------------------------------------------------------    
00001148  6000 0004                141      BRA userInputRepeat
0000114C                           142  there    
0000114C  4E75                     143      RTS
0000114E                           144  * end testing--------------------------------------------------------------
0000114E                           145   
0000114E                           146  
0000114E                           147       
0000114E                           148    
0000114E                           149  
0000114E                           150      
0000114E                           151  userInputRepeat
0000114E  43F9 00002176            152      LEA     INPUTREPEAT,A1
00001154  103C 000E                153      MOVE.B  #14,D0
00001158  4E4F                     154      TRAP    #15
0000115A  5239 000021EA            155      ADD.B   #1,(LineCounter)
00001160                           156      
00001160  43F9 00008008            157      LEA     userInputStored,A1
00001166  103C 0005                158      MOVE.B  #5,D0
0000116A  4E4F                     159      TRAP    #15
0000116C                           160      
0000116C  0C11 0000                161      CMP.B   #$00,(A1)
00001170  6700 FE96                162      BEQ     userInputStart
00001174                           163   
00001174  FFFF FFFF                164      SIMHALT
00001178                           165  
00001178                           166  **********************************************************
00001178                           167  *Subroutine: OPCODE
00001178                           168  *What it does: Looks at the word pointed to by A2 and determines opcode
00001178                           169  *Registers: 
00001178                           170  *A1: printing
00001178                           171  *A2: parameter with instruction address
00001178                           172  *D0: printing
00001178                           173  *D3: used for determing the instruction, mostly shifts
00001178                           174  *D2: used for determing the size
00001178                           175  *Paramemeters: A2 the memory address to decode from
00001178                           176  **********************************************************
00001178                           177  OPCODE:
00001178  4243                     178      CLR D3
0000117A                           179      
0000117A  0C52 4E75                180      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
0000117E  6700 031C                181      BEQ rts
00001182                           182      
00001182  0C52 4E71                183      CMP #$4E71, (A2) *NOP compare
00001186  6700 012A                184      BEQ nop
0000118A                           185      
0000118A  3612                     186      Move.W (A2), D3 
0000118C  E04B                     187      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
0000118E  E84B                     188      LSR #4,D3
00001190                           189      
00001190                           190      
00001190  B67C 0008                191      CMP #%1000, D3 * OR compare
00001194  6700 051E                192      BEQ or
00001198                           193      
00001198                           194      
00001198  B67C 0003                195      CMP #%0011, D3 *MOVE and MOVEA compare
0000119C  6F00 0134                196      BLE move
000011A0                           197      
000011A0  B67C 0007                198      CMP #%0111, D3 *MOVEQ compare
000011A4  6700 01AA                199      BEQ moveq
000011A8                           200      
000011A8  B67C 0009                201      CMP #%1001, D3 *SUB compare
000011AC  6700 01FA                202      BEQ sub
000011B0                           203      
000011B0  B67C 000C                204      CMP #%1100, D3 *AND compare
000011B4  6700 053C                205      BEQ and
000011B8                           206      
000011B8  B67C 0005                207      CMP #%0101, D3 *ADDQ compare
000011BC  6700 0228                208      BEQ addq
000011C0                           209  
000011C0  3612                     210      Move.W (A2), D3 * reset D3
000011C2  0243 F118                211      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
000011C6  B67C E108                212      CMP #%1110000100001000,D3 * LSL compare
000011CA  6700 0352                213      BEQ lsl
000011CE                           214  
000011CE  3612                     215      Move.W (A2), D3 * reset D3
000011D0  0243 F118                216      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
000011D4  B67C E008                217      CMP #%1110000000001000,D3 * LSR compare
000011D8  6700 0382                218      BEQ lsr
000011DC                           219      
000011DC                           220      
000011DC  3612                     221      Move.W (A2), D3 * reset D3
000011DE  0243 F118                222      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
000011E2  B67C E100                223      CMP #%1110000100000000,D3 * ASL compare
000011E6  6700 03B2                224      BEQ asl
000011EA                           225  
000011EA  3612                     226      Move.W (A2), D3 * reset D3
000011EC  0243 F118                227      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
000011F0  B67C E000                228      CMP #%1110000000000000,D3 * ASR compare
000011F4  6700 03E2                229      BEQ asr
000011F8                           230  
000011F8  3612                     231      Move.W (A2), D3 * reset D3
000011FA  0243 F118                232      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
000011FE  B67C E118                233      CMP #%1110000100011000,D3 * ROL compare
00001202  6700 0412                234      BEQ rol
00001206                           235  
00001206  3612                     236      Move.W (A2), D3 * reset D3
00001208  0243 F118                237      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000120C  B67C E018                238      CMP #%1110000000011000,D3 * ROR compare
00001210  6700 0442                239      BEQ ror
00001214                           240  
00001214                           241      
00001214                           242      
00001214  3612                     243      Move.W (A2), D3 * reset D3
00001216  0243 F0C0                244      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000121A  B67C D0C0                245      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
0000121E  6700 0242                246      BEQ adda
00001222                           247      
00001222  3612                     248      Move.W (A2), D3 
00001224  E04B                     249      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001226  E84B                     250      LSR #4,D3
00001228  B67C 000D                251      CMP #%1101, D3 *ADD compare
0000122C  6700 01F6                252      BEQ add
00001230                           253  
00001230                           254    
00001230  3612                     255      Move.W (A2), D3 * reset D3
00001232  0243 FB80                256      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001236  B67C 4880                257      CMP #%0100100010000000,D3 * MOVEM compare
0000123A  6700 0136                258      BEQ movem
0000123E                           259  
0000123E                           260      
0000123E                           261      
0000123E  3612                     262      Move.W (A2), D3 * reset D3
00001240  EC4B                     263      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001242  B67C 013A                264      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001246  6700 0276                265      BEQ jsr
0000124A                           266  
0000124A  3612                     267      Move.W (A2), D3 * reset D3
0000124C  E04B                     268      LSR #8,D3 * make D3 only contain the first 8 bits
0000124E  B67C 0046                269      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001252  6700 028C                270      BEQ not
00001256                           271      
00001256  3612                     272      Move.W (A2), D3 * reset D3
00001258  0243 F1C0                273      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000125C  B67C 41C0                274      CMP #%0100000111000000,D3 *LEA compare
00001260  6700 0430                275      BEQ lea
00001264                           276  
00001264                           277     
00001264  3612                     278      Move.W (A2), D3 * reset D3
00001266  E04B                     279      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
00001268                           280   
00001268  B67C 0060                281      CMP #%01100000, D3 *BRA compare
0000126C  6700 04C2                282      BEQ bra
00001270                           283      
00001270                           284      
00001270  6000 04E0                285      BRA data
00001274                           286      
00001274                           287  return
00001274  4E75                     288      RTS
00001276                           289  byte
00001276  43F9 00002258            290      LEA    byteout,A1        
0000127C  13FC 0002 000021EB       291      MOVE.B  #2,(OutputType)
00001284  6100 0B82                292      BSR     OUTPUT 
00001288  60EA                     293      BRA return
0000128A                           294  word
0000128A  43F9 0000225F            295      LEA    wordout,A1        
00001290  13FC 0002 000021EB       296      MOVE.B  #2,(OutputType)
00001298  6100 0B6E                297      BSR     OUTPUT
0000129C  60D6                     298      BRA return
0000129E                           299  long
0000129E  43F9 00002266            300      LEA    longout,A1        
000012A4  13FC 0002 000021EB       301      MOVE.B  #2,(OutputType)
000012AC  6100 0B5A                302      BSR     OUTPUT 
000012B0  60C2                     303      BRA return
000012B2                           304      
000012B2                           305  nop 
000012B2  13FC 0004 000021EB       306      MOVE.B  #4,(OutputType)
000012BA  6100 0B4C                307      BSR     OUTPUT
000012BE  43F9 000021EC            308      LEA    nopout,A1        
000012C4  13FC 0001 000021EB       309      MOVE.B  #1,(OutputType)
000012CC  6100 0B3A                310      BSR     OUTPUT
000012D0  60A2                     311      BRA return
000012D2                           312      
000012D2                           313  move
000012D2                           314      * put the size of the instruction into D2 to use later
000012D2                           315      * since the first two bits of D3 are 00 for move moving the entire word works
000012D2  3403                     316      Move.W D3, D2
000012D4                           317  
000012D4                           318  
000012D4                           319      * determine if MOVE or MOVEA
000012D4                           320      * if bits 8,7,6 = 001 its MOVEA
000012D4  3612                     321      MOVE.W (A2),D3
000012D6  0243 01C0                322      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
000012DA                           323      
000012DA  B67C 0040                324      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
000012DE  6700 003A                325      BEQ movea
000012E2                           326      
000012E2  13FC 0004 000021EB       327      MOVE.B  #4,(OutputType)
000012EA  6100 0B1C                328      BSR     OUTPUT
000012EE                           329  
000012EE  43F9 000021F2            330      LEA    moveout,A1     *print the type
000012F4  13FC 0001 000021EB       331      MOVE.B  #1,(OutputType)   
000012FC  6100 0B0A                332      BSR    OUTPUT
00001300                           333      
00001300                           334      *now to print size  
00001300  B47C 0002                335      cmp #2,D2 *if the size is 2 branch to long
00001304  6798                     336      BEQ long
00001306  B47C 0003                337      cmp #3,D2 *if the size is 3 branch to word
0000130A  6700 FF7E                338      BEQ word
0000130E  6100 FF66                339      BSR byte *otherwise branch to byte
00001312                           340    
00001312  6100 05D4                341      BSR MOVE_MOVEA_EA
00001316                           342      
00001316  6000 FF5C                343      BRA return
0000131A                           344      
0000131A                           345      
0000131A                           346  movea
0000131A  13FC 0004 000021EB       347      MOVE.B  #4,(OutputType)
00001322  6100 0AE4                348      BSR     OUTPUT
00001326                           349  
00001326  43F9 000021F7            350      LEA    moveaout,A1
0000132C  13FC 0001 000021EB       351      MOVE.B  #1,(OutputType)       
00001334  6100 0AD2                352      BSR    OUTPUT
00001338                           353      
00001338                           354      *now to print size  
00001338  B47C 0002                355      cmp #2,D2 *if the size is 2 branch to long
0000133C  6700 FF60                356      BEQ long
00001340  B47C 0003                357      cmp #3,D2 *if the size is 3 branch to word
00001344  6100 FF44                358      BSR word
00001348                           359      
00001348  6100 059E                360      BSR MOVE_MOVEA_EA
0000134C                           361      
0000134C  6000 FF26                362      BRA return
00001350                           363      
00001350                           364  moveq
00001350  13FC 0004 000021EB       365      MOVE.B  #4,(OutputType)
00001358  6100 0AAE                366      BSR     OUTPUT
0000135C                           367  
0000135C  43F9 000021FD            368      LEA    moveqout,A1
00001362  13FC 0001 000021EB       369      MOVE.B  #1,(OutputType)       
0000136A  6100 0A9C                370      BSR    OUTPUT
0000136E  6000 FF04                371      BRA return
00001372                           372  
00001372                           373      
00001372                           374  movem
00001372  13FC 0004 000021EB       375      MOVE.B  #4,(OutputType)
0000137A  6100 0A8C                376      BSR     OUTPUT
0000137E                           377      
0000137E  43F9 00002203            378      LEA    movemout,A1
00001384  13FC 0001 000021EB       379      MOVE.B  #1,(OutputType)       
0000138C  6100 0A7A                380      BSR    OUTPUT
00001390                           381      
00001390  3412                     382      MOVE.W (A2),D2
00001392  0242 0040                383      ANDI.W #%0000000001000000, D2 * set to only the size bits
00001396  EC4A                     384      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001398  B47C 0001                385      CMP #1, D2 * if the size is 1 branch to long
0000139C  6700 FF00                386      BEQ long
000013A0  6100 FEE8                387      BSR word * otherwise branch to word
000013A4                           388  
000013A4                           389      
000013A4  6000 FECE                390      BRA return
000013A8                           391  sub 
000013A8  13FC 0004 000021EB       392      MOVE.B  #4,(OutputType)
000013B0  6100 0A56                393      BSR     OUTPUT
000013B4                           394     
000013B4  43F9 00002209            395      LEA    subout,A1
000013BA  13FC 0001 000021EB       396      MOVE.B  #1,(OutputType)       
000013C2  6100 0A44                397      BSR    OUTPUT
000013C6                           398      
000013C6  3412                     399      MOVE.W (A2),D2
000013C8  0242 00C0                400      ANDI.W #%0000000011000000, D2 * set to only the size bits
000013CC  EC4A                     401      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013CE                           402  
000013CE                           403  
000013CE                           404      
000013CE                           405      *now to print size  
000013CE  B47C 0002                406      cmp #2,D2 *if the size is 2 branch to long
000013D2  6700 FECA                407      BEQ long
000013D6  B47C 0001                408      cmp #1,D2 *if the size is 1 branch to word
000013DA  6700 FEAE                409      BEQ word
000013DE  6100 FE96                410      BSR byte *otherwise branch to byte
000013E2                           411      
000013E2  6000 FE90                412      BRA return
000013E6                           413      
000013E6                           414  addq 
000013E6  13FC 0004 000021EB       415      MOVE.B  #4,(OutputType)
000013EE  6100 0A18                416      BSR     OUTPUT
000013F2                           417     
000013F2  43F9 00002216            418      LEA    addqout,A1
000013F8  13FC 0001 000021EB       419      MOVE.B  #1,(OutputType)       
00001400  6100 0A06                420      BSR    OUTPUT
00001404                           421      
00001404  3412                     422      MOVE.W (A2),D2
00001406  0242 00C0                423      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000140A  EC4A                     424      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000140C                           425  
0000140C                           426  
0000140C                           427      
0000140C                           428      *now to print size  
0000140C  B47C 0002                429      cmp #2,D2 *if the size is 2 branch to long
00001410  6700 FE8C                430      BEQ long
00001414  B47C 0001                431      cmp #1,D2 *if the size is 1 branch to word
00001418  6700 FE70                432      BEQ word
0000141C  6100 FE58                433      BSR byte *otherwise branch to byte
00001420                           434      
00001420  6000 FE52                435      BRA return    
00001424                           436      
00001424                           437      
00001424                           438  add
00001424  13FC 0004 000021EB       439      MOVE.B  #4,(OutputType)
0000142C  6100 09DA                440      BSR     OUTPUT
00001430                           441  
00001430  43F9 0000220D            442      LEA    addout,A1
00001436  13FC 0001 000021EB       443      MOVE.B  #1,(OutputType)       
0000143E  6100 09C8                444      BSR    OUTPUT
00001442                           445      
00001442  3412                     446      MOVE.W (A2),D2
00001444  0242 00C0                447      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001448  EC4A                     448      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000144A                           449  
0000144A                           450  
0000144A                           451      
0000144A                           452      *now to print size  
0000144A  B47C 0002                453      cmp #2,D2 *if the size is 2 branch to long
0000144E  6700 FE4E                454      BEQ long
00001452  B47C 0001                455      cmp #1,D2 *if the size is 1 branch to word
00001456  6700 FE32                456      BEQ word
0000145A  6100 FE1A                457      BSR byte *otherwise branch to byte
0000145E                           458      
0000145E  6000 FE14                459      BRA return
00001462                           460  
00001462                           461  adda
00001462                           462  
00001462  13FC 0004 000021EB       463      MOVE.B  #4,(OutputType)
0000146A  6100 099C                464      BSR     OUTPUT
0000146E                           465  
0000146E  43F9 00002211            466      LEA    addaout,A1
00001474  13FC 0001 000021EB       467      MOVE.B  #1,(OutputType)       
0000147C  6100 098A                468      BSR    OUTPUT
00001480                           469      
00001480  3412                     470      MOVE.W (A2),D2
00001482  0242 0100                471      ANDI.W #%0000000100000000, D2 * set to only the size bit
00001486  E04A                     472      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
00001488                           473  
00001488                           474  
00001488                           475      
00001488                           476      *now to print size  
00001488  B47C 0001                477      cmp #1,D2 *if the size is 1 branch to long
0000148C  6700 FE10                478      BEQ long
00001490  B47C 0000                479      cmp #0,D2 *if the size is 0 branch to word
00001494  6700 FDF4                480      BEQ word
00001498                           481         
00001498  6000 FDDA                482      BRA return
0000149C                           483  
0000149C                           484      
0000149C                           485  rts
0000149C  13FC 0004 000021EB       486      MOVE.B  #4,(OutputType)
000014A4  6100 0962                487      BSR     OUTPUT
000014A8                           488  
000014A8  43F9 00002246            489      LEA    rtsout,A1
000014AE  13FC 0001 000021EB       490      MOVE.B  #1,(OutputType)       
000014B6  6100 0950                491      BSR    OUTPUT
000014BA  6000 FDB8                492      BRA return
000014BE                           493      
000014BE                           494      
000014BE                           495  jsr 
000014BE  13FC 0004 000021EB       496      MOVE.B  #4,(OutputType)
000014C6  6100 0940                497      BSR     OUTPUT
000014CA                           498     
000014CA  43F9 00002242            499      LEA    jsrout,A1
000014D0  13FC 0001 000021EB       500      MOVE.B  #1,(OutputType)       
000014D8  6100 092E                501      BSR    OUTPUT
000014DC  6000 FD96                502      BRA return
000014E0                           503      
000014E0                           504      
000014E0                           505  not 
000014E0  13FC 0004 000021EB       506      MOVE.B  #4,(OutputType)
000014E8  6100 091E                507      BSR     OUTPUT
000014EC                           508    
000014EC  43F9 0000221F            509      LEA    notout,A1
000014F2  13FC 0001 000021EB       510      MOVE.B  #1,(OutputType)       
000014FA  6100 090C                511      BSR    OUTPUT
000014FE                           512      
000014FE  3412                     513      MOVE.W (A2),D2
00001500  0242 00C0                514      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001504  EC4A                     515      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001506                           516  
00001506                           517      *now to print size  
00001506  B47C 0002                518      cmp #2,D2 *if the size is 2 branch to long
0000150A  6700 FD92                519      BEQ long
0000150E  B47C 0001                520      cmp #1,D2 *if the size is 1 branch to word
00001512  6700 FD76                521      BEQ word
00001516  6100 FD5E                522      BSR byte *otherwise branch to byte
0000151A                           523      
0000151A                           524  
0000151A                           525      
0000151A  6000 FD58                526      BRA return
0000151E                           527  
0000151E                           528  lsl
0000151E  13FC 0004 000021EB       529      MOVE.B  #4,(OutputType)
00001526  6100 08E0                530      BSR     OUTPUT
0000152A                           531  
0000152A  43F9 0000222A            532      LEA    lslout,A1
00001530  13FC 0001 000021EB       533      MOVE.B  #1,(OutputType)       
00001538  6100 08CE                534      BSR    OUTPUT
0000153C                           535      
0000153C  3412                     536      MOVE.W (A2),D2
0000153E  0242 00C0                537      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001542  EC4A                     538      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001544                           539  
00001544                           540  
00001544                           541      
00001544                           542      *now to print size  
00001544  B47C 0002                543      cmp #2,D2 *if the size is 2 branch to long
00001548  6700 FD54                544      BEQ long
0000154C  B47C 0001                545      cmp #1,D2 *if the size is 1 branch to word
00001550  6700 FD38                546      BEQ word
00001554  6100 FD20                547      BSR byte *otherwise branch to byte
00001558                           548      
00001558  6000 FD1A                549      BRA return
0000155C                           550  
0000155C                           551  lsr
0000155C  13FC 0004 000021EB       552      MOVE.B  #4,(OutputType)
00001564  6100 08A2                553      BSR     OUTPUT
00001568                           554  
00001568  43F9 0000222E            555      LEA    lsrout,A1
0000156E  13FC 0001 000021EB       556      MOVE.B  #1,(OutputType)       
00001576  6100 0890                557      BSR    OUTPUT
0000157A                           558      
0000157A  3412                     559      MOVE.W (A2),D2
0000157C  0242 00C0                560      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001580  EC4A                     561      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001582                           562  
00001582                           563  
00001582                           564      
00001582                           565      *now to print size  
00001582  B47C 0002                566      cmp #2,D2 *if the size is 2 branch to long
00001586  6700 FD16                567      BEQ long
0000158A  B47C 0001                568      cmp #1,D2 *if the size is 1 branch to word
0000158E  6700 FCFA                569      BEQ word
00001592  6100 FCE2                570      BSR byte *otherwise branch to byte
00001596                           571      
00001596  6000 FCDC                572      BRA return
0000159A                           573  asl
0000159A  13FC 0004 000021EB       574      MOVE.B  #4,(OutputType)
000015A2  6100 0864                575      BSR     OUTPUT
000015A6                           576  
000015A6  43F9 00002232            577      LEA    aslout,A1
000015AC  13FC 0001 000021EB       578      MOVE.B  #1,(OutputType)       
000015B4  6100 0852                579      BSR    OUTPUT
000015B8                           580      
000015B8  3412                     581      MOVE.W (A2),D2
000015BA  0242 00C0                582      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015BE  EC4A                     583      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015C0                           584  
000015C0                           585  
000015C0                           586      
000015C0                           587      *now to print size  
000015C0  B47C 0002                588      cmp #2,D2 *if the size is 2 branch to long
000015C4  6700 FCD8                589      BEQ long
000015C8  B47C 0001                590      cmp #1,D2 *if the size is 1 branch to word
000015CC  6700 FCBC                591      BEQ word
000015D0  6100 FCA4                592      BSR byte *otherwise branch to byte
000015D4                           593      
000015D4  6000 FC9E                594      BRA return
000015D8                           595  
000015D8                           596  asr
000015D8  13FC 0004 000021EB       597      MOVE.B  #4,(OutputType)
000015E0  6100 0826                598      BSR     OUTPUT
000015E4                           599  
000015E4  43F9 00002236            600      LEA    asrout,A1
000015EA  13FC 0001 000021EB       601      MOVE.B  #1,(OutputType)       
000015F2  6100 0814                602      BSR    OUTPUT
000015F6                           603      
000015F6  3412                     604      MOVE.W (A2),D2
000015F8  0242 00C0                605      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015FC  EC4A                     606      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015FE                           607  
000015FE                           608  
000015FE                           609      
000015FE                           610      *now to print size  
000015FE  B47C 0002                611      cmp #2,D2 *if the size is 2 branch to long
00001602  6700 FC9A                612      BEQ long
00001606  B47C 0001                613      cmp #1,D2 *if the size is 1 branch to word
0000160A  6700 FC7E                614      BEQ word
0000160E  6100 FC66                615      BSR byte *otherwise branch to byte
00001612                           616      
00001612  6000 FC60                617      BRA return
00001616                           618      
00001616                           619  rol
00001616  13FC 0004 000021EB       620      MOVE.B  #4,(OutputType)
0000161E  6100 07E8                621      BSR     OUTPUT
00001622                           622  
00001622  43F9 0000223A            623      LEA    rolout,A1
00001628  13FC 0001 000021EB       624      MOVE.B  #1,(OutputType)       
00001630  6100 07D6                625      BSR    OUTPUT
00001634                           626      
00001634  3412                     627      MOVE.W (A2),D2
00001636  0242 00C0                628      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000163A  EC4A                     629      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000163C                           630  
0000163C                           631  
0000163C                           632      
0000163C                           633      *now to print size  
0000163C  B47C 0002                634      cmp #2,D2 *if the size is 2 branch to long
00001640  6700 FC5C                635      BEQ long
00001644  B47C 0001                636      cmp #1,D2 *if the size is 1 branch to word
00001648  6700 FC40                637      BEQ word
0000164C  6100 FC28                638      BSR byte *otherwise branch to byte
00001650                           639      
00001650  6000 FC22                640      BRA return
00001654                           641  
00001654                           642  ror
00001654  13FC 0004 000021EB       643      MOVE.B  #4,(OutputType)
0000165C  6100 07AA                644      BSR     OUTPUT
00001660                           645  
00001660  43F9 0000223E            646      LEA    rorout,A1
00001666  13FC 0001 000021EB       647      MOVE.B  #1,(OutputType)       
0000166E  6100 0798                648      BSR    OUTPUT
00001672                           649      
00001672  3412                     650      MOVE.W (A2),D2
00001674  0242 00C0                651      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001678  EC4A                     652      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000167A                           653  
0000167A                           654  
0000167A                           655      
0000167A                           656      *now to print size  
0000167A  B47C 0002                657      cmp #2,D2 *if the size is 2 branch to long
0000167E  6700 FC1E                658      BEQ long
00001682  B47C 0001                659      cmp #1,D2 *if the size is 1 branch to word
00001686  6700 FC02                660      BEQ word
0000168A  6100 FBEA                661      BSR byte *otherwise branch to byte
0000168E                           662      
0000168E  6000 FBE4                663      BRA return
00001692                           664      
00001692                           665      
00001692                           666  
00001692                           667  lea
00001692  13FC 0004 000021EB       668      MOVE.B  #4,(OutputType)
0000169A  6100 076C                669      BSR     OUTPUT
0000169E                           670  
0000169E  43F9 0000221B            671      LEA    leaout,A1
000016A4  13FC 0001 000021EB       672      MOVE.B  #1,(OutputType)       
000016AC  6100 075A                673      BSR    OUTPUT
000016B0  6000 FBC2                674      BRA return
000016B4                           675      
000016B4                           676  or
000016B4  13FC 0004 000021EB       677      MOVE.B  #4,(OutputType)
000016BC  6100 074A                678      BSR     OUTPUT
000016C0                           679  
000016C0  43F9 00002223            680      LEA    orout,A1
000016C6  13FC 0001 000021EB       681      MOVE.B  #1,(OutputType)       
000016CE  6100 0738                682      BSR    OUTPUT
000016D2                           683      
000016D2                           684          
000016D2  3412                     685      MOVE.W (A2),D2
000016D4  0242 00C0                686      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016D8  EC4A                     687      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016DA                           688  
000016DA                           689      *now to print size  
000016DA  B47C 0002                690      cmp #2,D2 *if the size is 2 branch to long
000016DE  6700 FBBE                691      BEQ long
000016E2  B47C 0001                692      cmp #1,D2 *if the size is 1 branch to word
000016E6  6700 FBA2                693      BEQ word
000016EA  6100 FB8A                694      BSR byte *otherwise branch to byte
000016EE                           695      
000016EE  6000 FB84                696      BRA return
000016F2                           697      
000016F2                           698  and
000016F2  13FC 0004 000021EB       699      MOVE.B  #4,(OutputType)
000016FA  6100 070C                700      BSR     OUTPUT
000016FE                           701  
000016FE  43F9 00002226            702      LEA    andout,A1
00001704  13FC 0001 000021EB       703      MOVE.B  #1,(OutputType)       
0000170C  6100 06FA                704      BSR    OUTPUT
00001710                           705      
00001710                           706          
00001710  3412                     707      MOVE.W (A2),D2
00001712  0242 00C0                708      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001716  EC4A                     709      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001718                           710  
00001718                           711      *now to print size  
00001718  B47C 0002                712      cmp #2,D2 *if the size is 2 branch to long
0000171C  6700 FB80                713      BEQ long
00001720  B47C 0001                714      cmp #1,D2 *if the size is 1 branch to word
00001724  6700 FB64                715      BEQ word
00001728  6100 FB4C                716      BSR byte *otherwise branch to byte
0000172C                           717      
0000172C  6000 FB46                718      BRA return    
00001730                           719  
00001730                           720  
00001730                           721  bra
00001730  13FC 0004 000021EB       722      MOVE.B  #4,(OutputType)
00001738  6100 06CE                723      BSR     OUTPUT
0000173C                           724  
0000173C  43F9 0000224C            725      LEA    braout,A1
00001742  13FC 0001 000021EB       726      MOVE.B  #1,(OutputType)       
0000174A  6100 06BC                727      BSR    OUTPUT
0000174E  6000 FB24                728      BRA return
00001752                           729  
00001752                           730  data
00001752  13FC 0004 000021EB       731      MOVE.B  #4,(OutputType)
0000175A  6100 06AC                732      BSR     OUTPUT
0000175E                           733  
0000175E  43F9 00002250            734      LEA    dataout,A1
00001764  13FC 0001 000021EB       735      MOVE.B  #1,(OutputType)       
0000176C  6100 069A                736      BSR    OUTPUT
00001770                           737      
00001770  13FC 0003 000021EB       738      MOVE.B  #3,(OutputType)       
00001778  6100 068E                739      BSR    OUTPUT *TODO fix data output type
0000177C                           740  
0000177C  6000 FAF6                741      BRA return
00001780                           742  
00001780                           743  
00001780                           744  **********************************************************
00001780                           745  *Subroutine: USERINPUT
00001780                           746  *What it does: Takes in user input, rejects bad input
00001780                           747  *Registers: Uses register A1, D0, D5
00001780                           748  *A1: Stores messages and user input
00001780                           749  *D0: Used for TRAP #15
00001780                           750  *D5: Temporaraly stores user input to be masked then transfered
00001780                           751  *Paramemeters: No parameters
00001780                           752  **********************************************************
00001780                           753  USERINPUT:
00001780                           754  
00001780                           755  welcomeExplanation
00001780  43F9 00001F5E            756      LEA     STARTMESSAGE,A1         
00001786  103C 000E                757      MOVE.B  #14,D0
0000178A  4E4F                     758      TRAP    #15
0000178C                           759      
0000178C  5039 000021EA            760      ADD.B   #8,(LineCounter)
00001792                           761  
00001792                           762  firstInput
00001792  43F9 000020D0            763      LEA     INPUT1MESSAGE,A1        
00001798  103C 000E                764      MOVE.B  #14,D0                  
0000179C  4E4F                     765      TRAP    #15                     Asks user for first input
0000179E  5239 000021EA            766      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000017A4                           767      
000017A4  43F9 00008008            768      LEA     userInputStored,A1
000017AA  103C 0002                769      MOVE.B  #2,D0                   
000017AE  4E4F                     770      TRAP    #15                     User can input string for address
000017B0  5239 000021EA            771      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000017B6                           772  
000017B6                           773      
000017B6  6100 00BC                774      BSR     CONVERTATOH                 String converted to hex address
000017BA                           775      
000017BA  0C39 0000 000021E9       776      CMP.B   #0,(InputQuality)       Checks if bad input flag set
000017C2  6700 0014                777      BEQ     throwInput1CharError
000017C6                           778  
000017C6                           779      
000017C6  CABC 00FFFFFF            780      AND.L   #$00FFFFFF,D5
000017CC  23C5 00008000            781      MOVE.L  D5,input1               Moves result into input 1 memory location
000017D2  4285                     782      CLR.L   D5                      Clears D5 for future use
000017D4  6000 0020                783      BRA     secondInput
000017D8                           784      
000017D8                           785  throwInput1CharError
000017D8  43F9 0000211C            786      LEA     INPUTERRORBADCHAR,A1
000017DE  103C 000E                787      MOVE.B  #14,D0
000017E2  4E4F                     788      TRAP    #15                     Outputs bad character error message
000017E4  5639 000021EA            789      ADD.B   #3,(LineCounter)        Adds 2 to line counter
000017EA                           790      
000017EA  13FC 0001 000021E9       791      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
000017F2  4285                     792      CLR.L   D5                      Clears D5 for future use
000017F4                           793      
000017F4                           794      
000017F4                           795      
000017F4  609C                     796      BRA     firstInput              Tries again for input1
000017F6                           797  
000017F6                           798      
000017F6                           799  secondInput
000017F6  43F9 000020F6            800      LEA     INPUT2MESSAGE,A1        
000017FC  103C 000E                801      MOVE.B  #14,D0                  
00001800  4E4F                     802      TRAP    #15                     Asks user for second input
00001802  5239 000021EA            803      ADD.B   #1,(LineCounter)
00001808                           804      
00001808  43F9 00008008            805      LEA     userInputStored,A1
0000180E  103C 0002                806      MOVE.B  #2,D0                   
00001812  4E4F                     807      TRAP    #15                     User can input string for address
00001814  5239 000021EA            808      ADD.B   #1,(LineCounter)
0000181A                           809  
0000181A                           810      
0000181A  6100 0058                811      BSR     CONVERTATOH                 String converted to hex address
0000181E                           812  
0000181E  0C39 0000 000021E9       813      CMP.B   #0,(InputQuality)       
00001826  6700 001C                814      BEQ     throwInput2CharError    Checks if bad input flag set
0000182A                           815      
0000182A  CABC 00FFFFFF            816      AND.L   #$00FFFFFF,D5
00001830  BAB9 00008000            817      CMP.L   (input1),D5
00001836  6D00 0028                818      BLT     throwInput2LowerError
0000183A                           819      
0000183A                           820      
0000183A                           821      
0000183A  23C5 00008004            822      MOVE.L  D5,input2               Moves result into input 2 memory location
00001840  4285                     823      CLR.L   D5                      Clears D5 for future use
00001842  4E75                     824      RTS    
00001844                           825      
00001844                           826  throwInput2CharError
00001844  43F9 0000211C            827      LEA     INPUTERRORBADCHAR,A1    
0000184A  103C 000E                828      MOVE.B  #14,D0
0000184E  4E4F                     829      TRAP    #15                     Outputs bad character error message
00001850                           830      
00001850  5639 000021E9            831      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
00001856  4285                     832      CLR.L   D5                      Clears D5 for future use
00001858                           833      
00001858  5639 000021EA            834      ADD.B   #3,(LineCounter)
0000185E                           835      
0000185E  6096                     836      BRA     secondInput             Tries again for input2
00001860                           837      
00001860                           838  throwInput2LowerError
00001860  43F9 0000213A            839      LEA     INPUTERROR2SMALLER,A1
00001866  103C 000E                840      MOVE.B  #14,D0
0000186A  4E4F                     841      TRAP    #15
0000186C                           842      
0000186C  5639 000021EA            843      ADD.B   #3,(LineCounter)
00001872                           844      
00001872  6082                     845      BRA     secondInput
00001874                           846  
00001874                           847  
00001874                           848  **********************************************************
00001874                           849  *Subroutine: CONVERTATOH
00001874                           850  *What it does: Converts user input to hex code
00001874                           851  *Registers: Uses register A1, D2, D5
00001874                           852  *Paramemeters: User input stored in (A1)
00001874                           853  ********************************************************** 
00001874                           854  CONVERTATOH:
00001874                           855      
00001874                           856  AtoH
00001874  1419                     857      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
00001876                           858      
00001876  B43C 0000                859      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
0000187A  6700 004C                860      BEQ     Finish                  Moves to finish if they are equal (no more input)
0000187E                           861      
0000187E  E985                     862      ASL.L   #4,D5
00001880                           863      
00001880  B43C 0030                864      CMP.B   #$30,D2
00001884  6D00 0044                865      BLT     inputError
00001888                           866      
00001888  B43C 0039                867      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
0000188C  6E00 000A                868      BGT     upperCase               Branches if greater, may or may not be a letter in hex
00001890                           869      
00001890  0402 0030                870      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
00001894  DA02                     871      ADD.B   D2,D5
00001896                           872      
00001896  60DC                     873      BRA     AtoH
00001898                           874  
00001898                           875          
00001898                           876  upperCase   
00001898  B43C 0041                877      CMP.B   #$41,D2
0000189C  6D00 002C                878      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
000018A0                           879      
000018A0  B43C 0046                880      CMP.B   #$46,D2                 
000018A4  6E00 000A                881      BGT     lowerCase               Greater than 46 may be hex code in lowercase
000018A8                           882      
000018A8  0402 0037                883      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
000018AC  DA02                     884      ADD.B   D2,D5
000018AE  60C4                     885      BRA     AtoH
000018B0                           886  
000018B0                           887  lowerCase
000018B0  B43C 0061                888      CMP.B   #$61,D2
000018B4  6D00 0014                889      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
000018B8                           890      
000018B8  B43C 0066                891      CMP.B   #$66,D2
000018BC  6E00 000C                892      BGT     InputError              Greater than 66 is not part of hex code
000018C0                           893      
000018C0  0402 0057                894      SUBI.B  #$57,D2
000018C4  DA02                     895      ADD.B   D2,D5
000018C6  60AC                     896      BRA     AtoH
000018C8                           897          
000018C8                           898  Finish
000018C8  4E75                     899      RTS                             Return from CONVERT
000018CA                           900      
000018CA                           901  inputError
000018CA  13FC 0000 000021E9       902      MOVE.B  #0,(InputQuality)
000018D2  4E75                     903      RTS
000018D4                           904  
000018D4                           905  *********************************************************************
000018D4                           906  *Subroutine: EA
000018D4                           907  *What it does: Outputs parts of opword, moves to new screen if needed
000018D4                           908  *Registers: Uses register A1, D0,
000018D4                           909  *A1: Used to store messages and single char
000018D4                           910  *Paramemeters: A1
000018D4                           911  *A1: Stores what should be used
000018D4                           912  *********************************************************************  
000018D4  =0000003F                913  BITS0TO5_MASK   EQU %00111111
000018D4  =000000C0                914  BITS7TO8_MASK   EQU %11000000
000018D4  =00000E00                915  BITS9TO11_MASK  EQU %00000111000000000
000018D4                           916  
000018D4  1E3C 000A                917  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
000018D8  BC7C 0000                918                          CMP     #0,D6
000018DC  6700 0006                919                          BEQ     IMMEDIATE0
000018E0  6000 0004                920                          BRA     IMMEDIATE_END
000018E4  7C08                     921  IMMEDIATE0              MOVEQ   #8,D6
000018E6                           922  
000018E6  4E75                     923  IMMEDIATE_END           RTS
000018E8                           924  
000018E8  3212                     925  MOVE_MOVEA_EA   MOVE.W  (A2),D1
000018EA  0201 003F                926                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
000018EE  0001 00C0                927                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
000018F2  1C01                     928                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
000018F4  3212                     929                  MOVE.W  (A2),D1         
000018F6  3412                     930                  MOVE.W  (A2),D2 
000018F8  0241 0E00                931                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
000018FC  163C 0009                932                  MOVE.B  #9,D3                   * Prepare shift count
00001900  E669                     933                  LSR.W   D3,D1                   * Move destination register bits right
00001902  0242 01C0                934                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001906  E64A                     935                  LSR.W   #3,D2                  * Move destination mode bits right
00001908  8242                     936                  OR.W    D2,D1
0000190A  1A01                     937                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
0000190C  1206                     938                  MOVE.B  D6,D1               * Pass source into subroutine
0000190E  4EB9 00001AD0            939                  JSR     CHECK_VALID_EA
00001914  1205                     940                  MOVE.B  D5,D1               * Pass destination into subroutine
00001916  4EB9 00001AD0            941                  JSR     CHECK_VALID_EA
0000191C  6100 01F6                942                  BSR print_EA
00001920  6100 0496                943                  BSR print_NEWLINE
00001924                           944                  
00001924  4E75                     945                  RTS
00001926                           946  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001926  3212                     947  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001928  3412                     948          MOVE.W  (A2),D2                 * Prepare to capture EA field
0000192A  0201 003F                949          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
0000192E                           950          
0000192E  0242 0E00                951          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001932  163C 0009                952          MOVE.B  #9,D3                   * Prepare shift count
00001936  E66A                     953          LSR.W   D3,D2                   * Move register bits right
00001938  0202 00C7                954          ANDI.B  #%11000111,D2           * Set EA mode
0000193C  3612                     955          MOVE.W  (A2),D3
0000193E  0803 0008                956          BTST    #8,D3                   * Check opmode
00001942  6700 000A                957          BEQ     EA1_MODE_ZERO           * Check opmode
00001946                           958          
00001946  3A01                     959  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001948  3C02                     960                  MOVE.W  D2,D6           * Set register as source
0000194A  6000 0006                961                  BRA EA1_END             * Complete subroutine
0000194E                           962          
0000194E  3C01                     963  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001950  3A02                     964                  MOVE.W  D2,D5           * Set register as destination
00001952                           965  
00001952  0006 00C0                966  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001956  1206                     967                  MOVE.B  D6,D1               * Pass source into subroutine
00001958  4EB9 00001AD0            968                  JSR     CHECK_VALID_EA
0000195E  1205                     969                  MOVE.B  D5,D1               * Pass destination into subroutine
00001960  4EB9 00001AD0            970                  JSR     CHECK_VALID_EA
00001966  6100 01AC                971                  BSR print_EA
0000196A  6100 044C                972                  BSR print_NEWLINE
0000196E                           973  
0000196E  4E75                     974                  RTS
00001970                           975  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001970  3C12                     976  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001972  0246 0E00                977                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001976  163C 0009                978                  MOVE.B  #9,D3                   * Prepare shift count
0000197A  E66E                     979                  LSR.W   D3,D6                   * Move register bits right
0000197C  3612                     980                  MOVE.W  (A2),D3
0000197E  0803 0005                981                  BTST    #5,D3           * Check whether shift count is immediate
00001982  6700 000A                982                  BEQ     EA2_IMMEDIATE
00001986                           983   
00001986  0006 00C0                984  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
0000198A  6000 000A                985                  BRA     EA2_END         * Complete subroutine
0000198E                           986                  
0000198E  1E3C 000A                987  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001992  4EB8 18D4                988                  JSR     FORMAT_IMMEDIATE_DATA
00001996                           989                  
00001996  3A12                     990  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001998  CA3C 0007                991                  AND.B   #%00000111,D5
0000199C  1206                     992                  MOVE.B  D6,D1               * Pass source into subroutine
0000199E  4EB9 00001AD0            993                  JSR     CHECK_VALID_EA
000019A4  1205                     994                  MOVE.B  D5,D1               * Pass destination into subroutine
000019A6  4EB9 00001AD0            995                  JSR     CHECK_VALID_EA
000019AC  6100 0166                996                  BSR print_EA
000019B0  6100 0406                997                  BSR print_NEWLINE
000019B4  4E75                     998                  RTS   
000019B6                           999  
000019B6                          1000  
000019B6                          1001  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
000019B6  3C12                    1002  EA_GROUP3     MOVE.W  (A2),D6
000019B8  0206 003F               1003          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
000019BC  0006 0080               1004          ORI.B   #%10000000,D6
000019C0  1206                    1005          MOVE.B  D6,D1               * Pass source into subroutine
000019C2  4EB9 00001AD0           1006          JSR     CHECK_VALID_EA
000019C8  6100 014A               1007          BSR print_EA
000019CC  6100 03EA               1008          BSR print_NEWLINE
000019D0  4E75                    1009          RTS
000019D2                          1010  
000019D2                          1011  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
000019D2  3212                    1012  EA_GROUP4     MOVE.W  (A2),D1         
000019D4  0201 003F               1013          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
000019D8  0001 00C0               1014          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
000019DC  1C01                    1015          MOVE.B  D1,D6                   * Pass source EA to print subroutine
000019DE  3212                    1016          MOVE.W  (A2),D1         
000019E0                          1017          
000019E0  0241 0E00               1018          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
000019E4  143C 0009               1019          MOVE.B  #9,D2                   * Prepare shift count
000019E8  E469                    1020          LSR.W   D2,D1                   * Move register bits right
000019EA  0201 00CF               1021          ANDI.B  #%11001111,D1           * Set destination mode
000019EE  0001 0008               1022          ORI.B   #%00001000,D1           * Set destination mode
000019F2  1A01                    1023          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
000019F4  1206                    1024          MOVE.B  D6,D1               * Pass source into subroutine
000019F6  4EB9 00001AD0           1025          JSR     CHECK_VALID_EA
000019FC  1205                    1026          MOVE.B  D5,D1               * Pass destination into subroutine
000019FE  4EB9 00001AD0           1027          JSR     CHECK_VALID_EA
00001A04  6100 010E               1028          BSR print_EA
00001A08  6100 03AE               1029          BSR print_NEWLINE
00001A0C  4E75                    1030          RTS
00001A0E                          1031          
00001A0E  3C12                    1032  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001A10  0246 0E00               1033          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001A14  163C 0009               1034          MOVE.B  #9,D3                   * Prepare shift count
00001A18  E66E                    1035          LSR.W   D3,D6                  * Move source data bits right            !---
00001A1A  3A12                    1036          MOVE.W  (A2),D5                 * Prepare destination bits
00001A1C  0205 003F               1037          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001A20  4EB8 18D4               1038          JSR     FORMAT_IMMEDIATE_DATA
00001A24  1206                    1039          MOVE.B  D6,D1               * Pass source into subroutine
00001A26  4EB9 00001AD0           1040          JSR     CHECK_VALID_EA
00001A2C  1205                    1041          MOVE.B  D5,D1               * Pass destination into subroutine
00001A2E  4EB9 00001AD0           1042          JSR     CHECK_VALID_EA
00001A34  4E75                    1043          RTS                                    !---
00001A36                          1044          
00001A36  3C12                    1045  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001A38  CC7C 00FF               1046              AND.W   #$00FF,D6                                                   !---
00001A3C  3A12                    1047              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001A3E  0245 0E00               1048              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001A42  163C 0009               1049              MOVE.B  #9,D3                   * Prepare shift count
00001A46  E66D                    1050              LSR.W   D3,D5                   * Move destination register bits right
00001A48  1E3C 000A               1051              MOVE.B  #10,D7
00001A4C  1206                    1052              MOVE.B  D6,D1               * Pass source into subroutine
00001A4E  4EB9 00001AD0           1053              JSR     CHECK_VALID_EA
00001A54  1205                    1054              MOVE.B  D5,D1               * Pass destination into subroutine
00001A56  4EB9 00001AD0           1055              JSR     CHECK_VALID_EA
00001A5C  4E75                    1056              RTS                                 !---
00001A5E                          1057  
00001A5E                          1058  
00001A5E                          1059  
00001A5E                          1060  
00001A5E  3412                    1061  MOVEM_EA   MOVE.W (A2),D2
00001A60  0802 000A               1062             BTST    #10, D2
00001A64  6700 003E               1063             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001A68                          1064            
00001A68                          1065             
00001A68                          1066                  
00001A68                          1067  *ELSE IT IS  memory-to-register transfers
00001A68                          1068  
00001A68                          1069  
00001A68                          1070  
00001A68                          1071  
00001A68                          1072     
00001A68  E68A                    1073  Memory_to_Register LSR.L #3, D2
00001A6A  C43C 0007               1074                     AND.B #$07, D2
00001A6E  B43C 0002               1075                     CMP.B #$2,D2
00001A72  6700 0022               1076                     BEQ   MODE_010
00001A76  B43C 0003               1077                     CMP.B #$03, D2
00001A7A  6700 001A               1078                     BEQ   MODE_010  
00001A7E  B43C 0007               1079                     CMP.B #$07,D2
00001A82  6700 0012               1080                     BEQ   MODE_010  
00001A86  4EF9 00001A8C           1081                     JMP   WRONG_INSTRUCTION    
00001A8C                          1082     
00001A8C  1E3C 0005               1083  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001A90  2C4A                    1084                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001A92  3C12                    1085                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001A94  4E75                    1086                               RTS 
00001A96                          1087             
00001A96  3412                    1088  MODE_010  MOVE.W    (A2),D2
00001A98  C43C 003F               1089            AND.B     #$3F,D2
00001A9C  08C2 0007               1090            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001AA0  1C02                    1091            MOVE.B    D2,D6
00001AA2  4E75                    1092            RTS
00001AA4                          1093  
00001AA4  3412                    1094  Register_to_memory MOVE.W (A2),D2
00001AA6  E68A                    1095                     LSR.L #3, D2
00001AA8  C43C 0007               1096                     AND.B #$07, D2
00001AAC  B43C 0002               1097                     CMP.B #$2,D2
00001AB0  6700 0016               1098                     BEQ   MODE_01_0
00001AB4  B43C 0004               1099                     CMP.B #$04, D2
00001AB8  6700 000E               1100                     BEQ   MODE_01_0 
00001ABC  B43C 0007               1101                     CMP.B #$07,D2
00001AC0  6700 0006               1102                     BEQ   MODE_01_0 
00001AC4  4EF8 1A8C               1103                     JMP   WRONG_INSTRUCTION
00001AC8                          1104                     
00001AC8                          1105  
00001AC8  3C12                    1106  MODE_01_0       MOVE.W  (A2),D6
00001ACA  0206 003F               1107                  ANDI.B  #$3F,D6
00001ACE  4E75                    1108                  RTS
00001AD0                          1109           
00001AD0  1001                    1110  CHECK_VALID_EA  MOVE.B  D1,D0
00001AD2  0200 0038               1111                  ANDI.B  #%111000,D0
00001AD6  E648                    1112                  LSR     #3,D0
00001AD8  B03C 0005               1113                  CMP.B   #%00000101,D0
00001ADC  6700 002C               1114                  BEQ     INVALID_EA
00001AE0  B03C 0006               1115                  CMP.B   #%00000110,D0
00001AE4  6700 0024               1116                  BEQ     INVALID_EA
00001AE8  B03C 0007               1117                  CMP.B   #%00000111,D0
00001AEC  6700 0004               1118                  BEQ     VALID_EA_PC
00001AF0  4E75                    1119                  RTS
00001AF2                          1120                  
00001AF2                          1121                  
00001AF2  1001                    1122  VALID_EA_PC     MOVE.B  D1,D0
00001AF4  0200 0007               1123                  ANDI.B  #%000111,D0
00001AF8  B03C 0010               1124                  CMP.B   #%00010000,D0
00001AFC  6700 000C               1125                  BEQ     INVALID_EA
00001B00  B03C 0018               1126                  CMP.B   #%00011000,D0
00001B04  6700 0004               1127                  BEQ     INVALID_EA
00001B08  4E75                    1128                  RTS
00001B0A                          1129                  
00001B0A  4EB8 1A8C               1130  INVALID_EA      JSR     WRONG_INSTRUCTION
00001B0E  3A7C 0005               1131                  MOVE.W  #5, A5
00001B12  4E75                    1132                  RTS
00001B14                          1133                  
00001B14  48E7 FFDE               1134  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001B18  163C 0038               1135                  MOVE.B  #$38,D3
00001B1C  C604                    1136                  AND.B   D4,D3
00001B1E  C83C 0007               1137                  AND.B   #$7, D4
00001B22                          1138                  
00001B22  B63C 0000               1139                  CMP.B   #$0, D3
00001B26  6600 0014               1140                  BNE     CHECK_EA_AR
00001B2A  0604 00D0               1141                  ADD.B   #$D0, D4
00001B2E  4281                    1142                  CLR.L   D1
00001B30  1204                    1143                  MOVE.B  D4, D1
00001B32  4EB9 00001CDE           1144                  JSR     PRINT_REGISTOR              * DATA REG
00001B38  6000 0114               1145                  BRA     PRINT_EA_RETURN
00001B3C                          1146  
00001B3C  B63C 0008               1147  CHECK_EA_AR         CMP.B   #$8, D3
00001B40  6600 0014               1148                      BNE     CHECK_EA_INDIRECT
00001B44  0604 00A0               1149                      ADD.B   #$A0, D4
00001B48  4281                    1150                      CLR.L   D1
00001B4A  1204                    1151                      MOVE.B  D4, D1
00001B4C  4EB9 00001CDE           1152                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001B52  6000 00FA               1153                      BRA     PRINT_EA_RETURN
00001B56                          1154                      
00001B56  B63C 0010               1155  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001B5A  6600 0020               1156                          BNE     CHECK_EA_POST
00001B5E  4EB9 00001D32           1157                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001B64  0604 00A0               1158                          ADD.B   #$A0, D4
00001B68  4281                    1159                          CLR.L   D1
00001B6A  1204                    1160                          MOVE.B  D4, D1
00001B6C  4EB9 00001CDE           1161                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001B72  4EB9 00001D46           1162                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001B78  6000 00D4               1163                          BRA     PRINT_EA_RETURN
00001B7C                          1164                          
00001B7C  B63C 0018               1165  CHECK_EA_POST   CMP.B   #$18,D3
00001B80  6600 0026               1166                  BNE     CHECK_EA_PRE
00001B84  4EB9 00001D32           1167                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001B8A  0604 00A0               1168                  ADD.B   #$A0, D4
00001B8E  4281                    1169                  CLR.L   D1
00001B90  1204                    1170                  MOVE.B  D4, D1
00001B92  4EB9 00001CDE           1171                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001B98  4EB9 00001D46           1172                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001B9E  4EB9 00001D5E           1173                  JSR     PRINT_PLUS                  * +
00001BA4  6000 00A8               1174                  BRA     PRINT_EA_RETURN
00001BA8                          1175  
00001BA8  B63C 0020               1176  CHECK_EA_PRE        CMP.B   #$20,D3
00001BAC  6600 0026               1177                      BNE     CHECK_EA_AB_W
00001BB0  4EB9 00001D72           1178                      JSR     PRINT_MINUS                 * -
00001BB6  4EB9 00001D32           1179                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001BBC  0604 00A0               1180                      ADD.B   #$A0, D4
00001BC0  4281                    1181                      CLR.L   D1
00001BC2  1204                    1182                      MOVE.B  D4, D1
00001BC4  4EB9 00001CDE           1183                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001BCA  4EB9 00001D46           1184                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001BD0  6000 007C               1185                      BRA     PRINT_EA_RETURN
00001BD4                          1186  
00001BD4  D604                    1187  CHECK_EA_AB_W           ADD.B   D4,D3
00001BD6  B63C 0038               1188                          CMP.B   #$38,D3     
00001BDA  6600 0018               1189                          BNE     CHECK_EA_AB_L
00001BDE  4EB9 00001DE0           1190                          JSR     PRINT_DOLLAR        * $
00001BE4  3A1A                    1191                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001BE6  163C 0002               1192                          MOVE.B  #2,D3
00001BEA  4EB9 00001C76           1193                          JSR     PRINT_HEX
00001BF0  6000 005C               1194                          BRA     PRINT_EA_RETURN
00001BF4                          1195                          
00001BF4  B63C 0039               1196  CHECK_EA_AB_L       CMP.B   #$39, D3
00001BF8  6600 0018               1197                      BNE     CHECK_EA_IMM
00001BFC  4EB9 00001DE0           1198                      JSR     PRINT_DOLLAR        * $
00001C02  2A1A                    1199                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001C04  163C 0004               1200                      MOVE.B  #4,D3
00001C08  4EB9 00001C76           1201                      JSR     PRINT_HEX
00001C0E  6000 003E               1202                      BRA     PRINT_EA_RETURN
00001C12                          1203                      
00001C12  BE3C 0004               1204  CHECK_EA_IMM        CMP.B   #4,D7
00001C16  6600 001E               1205                      BNE     READ_WORD_IMM
00001C1A  4EB9 00001DCC           1206                      JSR     PRINT_HASH_SIGN     * #
00001C20  4EB9 00001DE0           1207                      JSR     PRINT_DOLLAR        * $
00001C26  2A1A                    1208                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001C28  163C 0004               1209                      MOVE.B  #4,D3
00001C2C  4EB9 00001C76           1210                      JSR     PRINT_HEX
00001C32  6000 001A               1211                      BRA     PRINT_EA_RETURN
00001C36                          1212                      
00001C36  4EB9 00001DCC           1213  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001C3C  4EB9 00001DE0           1214                      JSR     PRINT_DOLLAR        * $
00001C42  3A1A                    1215                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001C44  163C 0002               1216                      MOVE.B  #2,D3
00001C48  4EB9 00001C76           1217                      JSR     PRINT_HEX
00001C4E                          1218  
00001C4E  4CDF 7BFF               1219  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001C52  4E75                    1220                      RTS
00001C54                          1221  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001C54                          1222  PRINT_BUFFER    DS.B    10
00001C5E= 30 30 30 30 30 30 ...   1223  IPUT_BUFFER_EX  DC.B    '00000000'
00001C66                          1224  INPUT_BUFFER    DS.B    15                    
00001C76  48E7 FFFE               1225  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001C7A  43F8 1C54               1226                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001C7E  D3FC 0000000A           1227                  ADD.L       #10,A1
00001C84  133C 0000               1228                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001C88  6000 000E               1229                  BRA         POPULATE_BUFFER
00001C8C                          1230                  
00001C8C  103C 000E               1231  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001C90  4E4F                    1232                      TRAP        #15
00001C92  4CDF 7FFF               1233                      MOVEM.L     (SP)+,ALL_REG
00001C96  4E75                    1234                      RTS
00001C98                          1235                 
00001C98  B63C 0000               1236  POPULATE_BUFFER     CMP.B       #0,D3
00001C9C  67EE                    1237                      BEQ         PRINT_HEX_RETURN
00001C9E  183C 000F               1238                      MOVE.B      #$0F,D4
00001CA2  C805                    1239                      AND.B       D5,D4
00001CA4  E81D                    1240                      ROR.B       #4,D5
00001CA6  4EB9 00001CC2           1241                      JSR         HEX_TO_ASCII
00001CAC  1304                    1242                      MOVE.B      D4,-(A1)
00001CAE  1805                    1243                      MOVE.B      D5,D4
00001CB0  C83C 000F               1244                      AND.B       #$0F,D4
00001CB4  4EB9 00001CC2           1245                      JSR         HEX_TO_ASCII
00001CBA  1304                    1246                      MOVE.B      D4,-(A1)
00001CBC  E08D                    1247                      LSR.L       #8,D5
00001CBE  5303                    1248                      SUB.B       #1,D3
00001CC0  60D6                    1249                      BRA         POPULATE_BUFFER
00001CC2                          1250  
00001CC2  48E7 E7FE               1251  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001CC6  B83C 0009               1252                          CMP.B       #9,D4
00001CCA  6F00 000C               1253                          BLE         NUMBER_TO_ASCII
00001CCE  0604 0037               1254                          ADD.B       #$37,D4
00001CD2  4CDF 7FE7               1255  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001CD6  4E75                    1256                          RTS
00001CD8                          1257                  
00001CD8  0604 0030               1258  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001CDC  60F4                    1259                      BRA     HEX_TO_ASCII_RETURN                    
00001CDE                          1260                      
00001CDE  48E7 FFFE               1261  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001CE2  3F3C 0000               1262                      MOVE.W      #00,-(SP)           *for printing purpose
00001CE6  343C 00F0               1263                      MOVE.W      #$f0,D2             *manipulating each digit
00001CEA  C441                    1264                      AND.W       D1,D2
00001CEC  E842                    1265                      ASR.W       #4,D2
00001CEE  4EB9 00001D14           1266                      JSR         TO_STRING           * converts to the string ASCII val
00001CF4  E142                    1267                      ASL.W       #8,D2
00001CF6                          1268                      
00001CF6  C27C 000F               1269                      AND.W       #$F,D1              * the last digit
00001CFA  1401                    1270                      MOVE.B      D1,D2               
00001CFC  4EB9 00001D14           1271                      JSR         TO_STRING
00001D02  3F02                    1272                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001D04                          1273                      
00001D04  224F                    1274                      MOVE.L      SP,A1               * printing
00001D06  103C 000E               1275                      MOVE.B      #14,D0
00001D0A  4E4F                    1276                      TRAP        #15
00001D0C  2A1F                    1277                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001D0E                          1278  
00001D0E  4CDF 7FFF               1279  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001D12  4E75                    1280                                  RTS
00001D14                          1281                                  
00001D14  B43C 0009               1282  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001D18  6E00 0008               1283              BGT     LETTERS     
00001D1C  0602 0030               1284              ADD.B   #$30,D2             * offseting digit
00001D20  4E75                    1285              RTS
00001D22  0602 0037               1286  LETTERS     ADD.B   #$37,D2             * offseting leter
00001D26  4E75                    1287              RTS   
00001D28                          1288  
00001D28                          1289  *________________________________________________________________________________________
00001D28                          1290  
00001D28                          1291  
00001D28                          1292  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001D28                          1293          *PARAMENTER     NO PARAMETER NEEDED
00001D28= 28 00                   1294  OPEN_PAR_TAG        DC.B    '(',0  
00001D2A= 29 00                   1295  CLOSED_PAR_TAG      DC.B    ')',0
00001D2C= 23 00                   1296  HASH_SIGN_TAG       DC.B    '#',0
00001D2E= 24 00                   1297  DOLLAR_TAG          DC.B    '$',0
00001D30= 2F 00                   1298  FORWARD_SLASH_TAG   DC.B    '/',0      
00001D32  48E7 FFFE               1299  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001D36  43F8 1D28               1300                          LEA         OPEN_PAR_TAG, A1
00001D3A  103C 000E               1301                          MOVE.B      #14,D0
00001D3E  4E4F                    1302                          TRAP        #15
00001D40  4CDF 7FFF               1303                          MOVEM.L     (SP)+,ALL_REG
00001D44  4E75                    1304                          RTS
00001D46                          1305  *_________________________________________________________________________________
00001D46                          1306  
00001D46                          1307  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001D46                          1308          *PARAMENTER     NO PARAMETER NEEDED
00001D46                          1309          
00001D46  48E7 FFFE               1310  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001D4A  43F8 1D2A               1311                              LEA         CLOSED_PAR_TAG, A1
00001D4E  103C 000E               1312                              MOVE.B      #14,D0
00001D52  4E4F                    1313                              TRAP        #15
00001D54  4CDF 7FFF               1314                              MOVEM.L     (SP)+,ALL_REG
00001D58  4E75                    1315                              RTS
00001D5A                          1316  *__________________________________________________________________________________
00001D5A                          1317  
00001D5A                          1318  *________________ PRINT PLUS SIGN _________________________________________________
00001D5A                          1319          *PARAMENTER     NO PARAMETER NEEDED
00001D5A= 2B 00                   1320  PLUS_TAG            DC.B    '+',0
00001D5C= 2D 00                   1321  MINUS_TAG           DC.B    '-',0        
00001D5E  48E7 FFFE               1322  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001D62  43F8 1D5A               1323                  LEA         PLUS_TAG, A1
00001D66  103C 000E               1324                  MOVE.B      #14,D0
00001D6A  4E4F                    1325                  TRAP        #15
00001D6C  4CDF 7FFF               1326                  MOVEM.L     (SP)+,ALL_REG
00001D70  4E75                    1327                  RTS
00001D72                          1328  *_________________________________________________________________________________
00001D72                          1329  
00001D72                          1330  *________________ PRINT MINUS SIGN _______________________________________________
00001D72                          1331          *PARAMENTER     NO PARAMETER NEEDED
00001D72                          1332          
00001D72  48E7 FFFE               1333  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001D76  43F8 1D5C               1334                      LEA         MINUS_TAG, A1
00001D7A  103C 000E               1335                      MOVE.B      #14,D0
00001D7E  4E4F                    1336                      TRAP        #15
00001D80  4CDF 7FFF               1337                      MOVEM.L     (SP)+,ALL_REG
00001D84  4E75                    1338                      RTS
00001D86                          1339  *_________________________________________________________________________________
00001D86                          1340  
00001D86                          1341  *________________ PRINT COMMA ____________________________________________________
00001D86                          1342          *PARAMENTER     NO PARAMETER NEEDED
00001D86= 09 00                   1343  TAB_TAG         DC.B    $9,0
00001D88= 20 00                   1344  SPACE_TAG       DC.B    ' ',0
00001D8A= 2C 00                   1345  COMMA_TAG       DC.B    ',',0        
00001D8C  48E7 FFFE               1346  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001D90  43F8 1D8A               1347                      LEA         COMMA_TAG, A1
00001D94  103C 000E               1348                      MOVE.B      #14,D0
00001D98  4E4F                    1349                      TRAP        #15
00001D9A  4CDF 7FFF               1350                      MOVEM.L     (SP)+,ALL_REG
00001D9E  4E75                    1351                      RTS
00001DA0                          1352  *_________________________________________________________________________________
00001DA0                          1353  
00001DA0                          1354  *________________ PRINT TAB ______________________________________________________
00001DA0                          1355          *PARAMENTER     NO PARAMETER NEEDED
00001DA0                          1356          
00001DA0  48E7 FFFE               1357  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001DA4  43F8 1D86               1358                  LEA         TAB_TAG, A1
00001DA8  103C 000E               1359                  MOVE.B      #14,D0
00001DAC  4E4F                    1360                  TRAP        #15
00001DAE  4CDF 7FFF               1361                  MOVEM.L     (SP)+,ALL_REG
00001DB2  4E75                    1362                  RTS
00001DB4                          1363  *_________________________________________________________________________________
00001DB4                          1364  
00001DB4                          1365  
00001DB4                          1366  *_______________    PRINT NEWLINE   ________________________________________________
00001DB4                          1367          *PARAMETER NO PARAMETER NEEDED
00001DB4= 0D 0A 00                1368  NEWLINE_TAG         DC.B    CR,LF,0        
00001DB8  48E7 FFFE               1369  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001DBC  43F8 1DB4               1370                      LEA         NEWLINE_TAG, A1
00001DC0  103C 000E               1371                      MOVE.B      #14,D0
00001DC4  4E4F                    1372                      TRAP        #15
00001DC6  4CDF 7FFF               1373                      MOVEM.L     (SP)+,ALL_REG
00001DCA  4E75                    1374                      RTS
00001DCC                          1375  
00001DCC                          1376  *___________________________________________________________________________________
00001DCC                          1377  
00001DCC                          1378  
00001DCC                          1379  *_______________    PRINT HASH SIGN   ________________________________________________
00001DCC                          1380          *PARAMETER NO PARAMETER NEEDED
00001DCC                          1381          
00001DCC  48E7 FFFE               1382  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001DD0  43F8 1D2C               1383                      LEA         HASH_SIGN_TAG, A1
00001DD4  103C 000E               1384                      MOVE.B      #14,D0
00001DD8  4E4F                    1385                      TRAP        #15
00001DDA  4CDF 7FFF               1386                      MOVEM.L     (SP)+,ALL_REG
00001DDE  4E75                    1387                      RTS
00001DE0                          1388  
00001DE0                          1389  *___________________________________________________________________________________
00001DE0                          1390  
00001DE0                          1391  
00001DE0                          1392  
00001DE0                          1393  *_______________    PRINT DOLLAR   ________________________________________________
00001DE0                          1394          *PARAMETER NO PARAMETER NEEDED
00001DE0                          1395          
00001DE0  48E7 FFFE               1396  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001DE4  43F8 1D2E               1397                      LEA         DOLLAR_TAG, A1
00001DE8  103C 000E               1398                      MOVE.B      #14,D0
00001DEC  4E4F                    1399                      TRAP        #15
00001DEE  4CDF 7FFF               1400                      MOVEM.L     (SP)+,ALL_REG
00001DF2  4E75                    1401                      RTS
00001DF4                          1402  
00001DF4                          1403  *___________________________________________________________________________________
00001DF4                          1404  
00001DF4                          1405  
00001DF4                          1406  
00001DF4                          1407  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001DF4                          1408          *PARAMETER NO PARAMETER NEEDED
00001DF4                          1409          
00001DF4  48E7 FFFE               1410  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001DF8  43F8 1D30               1411                          LEA         FORWARD_SLASH_TAG, A1
00001DFC  103C 000E               1412                          MOVE.B      #14,D0
00001E00  4E4F                    1413                          TRAP        #15
00001E02  4CDF 7FFF               1414                          MOVEM.L     (SP)+,ALL_REG
00001E06  4E75                    1415                          RTS
00001E08                          1416  
00001E08                          1417  
00001E08                          1418     
00001E08                          1419  *********************************************************************
00001E08                          1420  *Subroutine: OUTPUT
00001E08                          1421  *What it does: Outputs parts of opword, moves to new screen if needed
00001E08                          1422  *Registers: Uses register A1, D0,
00001E08                          1423  *A1: Used to store messages and single char
00001E08                          1424  *Paramemeters: A1, A2
00001E08                          1425  *A1: Stores what should be used
00001E08                          1426  *********************************************************************  
00001E08                          1427  
00001E08                          1428       OUTPUT:
00001E08                          1429       
00001E08  0C39 0001 000021EB      1430       CMP.B  #1,(OutputType)
00001E10  6700 0026               1431       BEQ    outputOpcode
00001E14  0C39 0002 000021EB      1432       CMP.B  #2,(OutputType)
00001E1C  6700 0066               1433       BEQ    OutputSize
00001E20  0C39 0003 000021EB      1434       CMP.B  #3,(OutputType)
00001E28  6700 0062               1435       BEQ    OutputData
00001E2C  0C39 0004 000021EB      1436       CMP.B  #4,(OutputType)
00001E34  6700 00AC               1437       BEQ    OutputAddress
00001E38                          1438       
00001E38                          1439  outputOpcode    
00001E38  0C39 001E 000021EA      1440       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001E40  6C00 0010               1441       BGE    outputOpcodeNewScreen
00001E44                          1442       
00001E44  103C 000E               1443       MOVE.B #14,D0
00001E48  4E4F                    1444       TRAP   #15
00001E4A                          1445       
00001E4A  5239 000021EA           1446       ADD.B  #1,(LineCounter)
00001E50                          1447       
00001E50  4E75                    1448       RTS
00001E52                          1449       
00001E52                          1450       
00001E52                          1451  outputOpcodeNewScreen
00001E52  2F09                    1452       MOVE.L A1,-(SP)                Storing last message to be used later
00001E54                          1453       
00001E54  43F9 000021C0           1454       LEA    OUTPUTNEWSCREEN,A1         
00001E5A  103C 000E               1455       MOVE.B #14,D0
00001E5E  4E4F                    1456       TRAP   #15
00001E60                          1457       
00001E60  43F9 00008008           1458       LEA    userInputStored,A1         Pauses program to show screen full of data
00001E66  103C 0002               1459       MOVE.B #2,D0
00001E6A  4E4F                    1460       TRAP   #15
00001E6C                          1461       
00001E6C  13FC 0000 000021EA      1462       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001E74                          1463       
00001E74  225F                    1464       MOVE.L (SP)+,A1                Retriving message to be used
00001E76                          1465       
00001E76  103C 000E               1466       MOVE.B #14,D0                  Outputting decoded message
00001E7A  4E4F                    1467       TRAP   #15
00001E7C                          1468       
00001E7C  5239 000021EA           1469       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001E82                          1470       
00001E82  4E75                    1471       RTS
00001E84                          1472       
00001E84                          1473  outputSize
00001E84  103C 000E               1474      MOVE.B  #14,D0
00001E88  4E4F                    1475      TRAP    #15
00001E8A  4E75                    1476      RTS
00001E8C                          1477  outputData
00001E8C  267C 00000800           1478      MOVE.L   #$800,A3
00001E92  3692                    1479      MOVE.W  (A2),(A3)
00001E94  2F06                    1480      MOVE.L  D6,-(SP)
00001E96  103C 0000               1481      MOVE.B  #0,D0
00001E9A  43F9 00009005           1482      LEA     addressOutput,A1
00001EA0                          1483  
00001EA0                          1484  outputDataLoop
00001EA0                          1485  *check if loop has run 4 times
00001EA0  B03C 0002               1486      CMP.B   #2,D0
00001EA4  6700 001C               1487      BEQ     outputDataLoopEnd
00001EA8                          1488      *Grab byte from address, dont increment
00001EA8  1C13                    1489      MOVE.B  (A3),D6
00001EAA                          1490      *LSR to isolate left bit
00001EAA  E80E                    1491      LSR.B   #4,D6
00001EAC                          1492      *Call converthtoa
00001EAC  6100 008A               1493      BSR     CONVERTHTOA
00001EB0  12C6                    1494      MOVE.B  D6,(A1)+   
00001EB2                          1495      *Grab bye from address, increment
00001EB2  1C1B                    1496      MOVE.B  (A3)+,D6
00001EB4                          1497      *AND Mask second digit
00001EB4  CC3C 000F               1498      AND.B   #$0F,D6
00001EB8  6100 007E               1499      BSR     CONVERTHTOA
00001EBC  12C6                    1500      MOVE.B  D6,(A1)+
00001EBE  5200                    1501      ADD.B   #1,D0
00001EC0  60DE                    1502      BRA     outputDataLoop
00001EC2                          1503      
00001EC2                          1504  outputDataLoopEnd
00001EC2  12BC 0000               1505      MOVE.B  #$00,(A1)
00001EC6  2C1F                    1506      MOVE.L  (SP)+,D6
00001EC8  43F9 00009005           1507      LEA     addressOutput,A1
00001ECE  103C 000E               1508      MOVE.B  #14,D0
00001ED2  4E4F                    1509      TRAP    #15
00001ED4                          1510      
00001ED4  43F9 000021E3           1511      LEA     NEWLINE,A1
00001EDA  103C 000E               1512      MOVE.B  #14,D0
00001EDE  4E4F                    1513      TRAP    #15
00001EE0                          1514  
00001EE0  4E75                    1515      RTS
00001EE2                          1516   
00001EE2                          1517      
00001EE2                          1518  outputAddress
00001EE2  267C 00000800           1519      MOVE.L  #$800,A3
00001EE8  268A                    1520      MOVE.L  A2,(A3)
00001EEA  2F06                    1521      MOVE.L  D6,-(SP)
00001EEC  103C 0000               1522      MOVE.B  #0,D0
00001EF0  43F9 00009005           1523      LEA     addressOutput,A1
00001EF6                          1524  outputAddressLoop
00001EF6                          1525      *check if loop has run 4 times
00001EF6  B03C 0004               1526      CMP.B   #4,D0
00001EFA  6700 001C               1527      BEQ     outputAddressLoopEnd
00001EFE                          1528      *Grab byte from address, dont increment
00001EFE  1C13                    1529      MOVE.B  (A3),D6
00001F00                          1530      *LSR to isolate left bit
00001F00  E80E                    1531      LSR.B   #4,D6
00001F02                          1532      *Call converthtoa
00001F02  6100 0034               1533      BSR     CONVERTHTOA
00001F06  12C6                    1534      MOVE.B  D6,(A1)+   
00001F08                          1535      *Grab bye from address, increment
00001F08  1C1B                    1536      MOVE.B  (A3)+,D6
00001F0A                          1537      *AND Mask second digit
00001F0A  CC3C 000F               1538      AND.B   #$0F,D6
00001F0E  6100 0028               1539      BSR     CONVERTHTOA
00001F12  12C6                    1540      MOVE.B  D6,(A1)+
00001F14  5200                    1541      ADD.B   #1,D0
00001F16  60DE                    1542      BRA     outputAddressLoop
00001F18                          1543      
00001F18                          1544      
00001F18                          1545  outputAddressLoopEnd
00001F18  12BC 0000               1546      MOVE.B  #$00,(A1)
00001F1C  2C1F                    1547      MOVE.L  (SP)+,D6
00001F1E  43F9 00009005           1548      LEA     addressOutput,A1
00001F24                          1549      
00001F24  103C 000E               1550      MOVE.B  #14,D0
00001F28  4E4F                    1551      TRAP    #15
00001F2A                          1552      
00001F2A  43F9 000021E6           1553      LEA     spaces,A1
00001F30  103C 000E               1554      MOVE.B  #14,D0
00001F34  4E4F                    1555      TRAP    #15
00001F36                          1556  
00001F36                          1557  
00001F36  4E75                    1558      RTS
00001F38                          1559  
00001F38                          1560  *********************************************************************
00001F38                          1561  *Subroutine: CONVERTHTOA
00001F38                          1562  *What it does: Converts HEX to ASCII
00001F38                          1563  *Registers: Uses register D6,D0
00001F38                          1564  *D6: Stores hex character to be converted
00001F38                          1565  *Paramemeters: D6
00001F38                          1566  *D6: Stores hex characcter to be converted
00001F38                          1567  *********************************************************************
00001F38                          1568      CONVERTHTOA:
00001F38                          1569      
00001F38  BC3C 0009               1570      CMP.B   #9,D6
00001F3C  6F00 0006               1571      BLE     zerotonine
00001F40  6000 000A               1572      BRA     AtoF
00001F44                          1573      
00001F44                          1574  zerotonine    
00001F44  0686 00000030           1575      ADD.L   #$30,D6
00001F4A  4E75                    1576      RTS
00001F4C                          1577  AtoF
00001F4C  0686 00000037           1578      ADD.L   #$37,D6
00001F52  4E75                    1579      RTS
00001F54                          1580      
00001F54                          1581  END_SIMULATION:
00001F54                          1582          
00001F54  103C 0009               1583      MOVE.B  #9,D0
00001F58  4E4F                    1584      TRAP    #15
00001F5A                          1585  
00001F5A  FFFF FFFF               1586      SIMHALT             ; halt simulator
00001F5E                          1587  
00001F5E                          1588  * Put variables and constants here
00001F5E= 57 65 6C 63 6F 6D ...   1589  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
00001F84= 53 6F 6D 65 20 71 ...   1590                  DC.B    'Some quick rules:',CR,LF
00001F97= 31 29 20 4F 6E 6C ...   1591                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
00001FD3= 32 29 20 54 68 65 ...   1592                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
0000201E= 33 29 20 41 6E 79 ...   1593                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
00002062= 20 20 20 77 69 6C ...   1594                  DC.B    '   will be rejected',CR,LF
00002077= 34 29 20 54 68 65 ...   1595                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
000020BA= 20 20 20 77 69 6C ...   1596                  DC.B    '   will be rejected',CR,LF,0      
000020D0= 50 6C 65 61 73 65 ...   1597  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
000020F6= 50 6C 65 61 73 65 ...   1598  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
0000211C                          1599  
0000211C= 0D 0A 54 68 69 73 ...   1600  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
0000213A= 0D 0A 49 6E 70 75 ...   1601  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
00002176                          1602  
00002176= 54 6F 20 72 65 70 ...   1603  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
000021C0                          1604  
000021C0= 50 6C 65 61 73 65 ...   1605  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
000021E3                          1606  
000021E3= 0D 0A 00                1607  NEWLINE     DC.B    CR,LF,0
000021E6= 20 20 00                1608  SPACES      DC.B    '  ',0
000021E9                          1609  
000021E9= 01                      1610  InputQuality    DC.B    1       Set to 1 for default good
000021EA= 00                      1611  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
000021EB= 00                      1612  OutputType      DC.B    0      To track what type is being output
000021EC                          1613  
000021EC= 4E 4F 50 0D 0A 00       1614  nopout  DC.B    'NOP',CR,LF,0
000021F2= 4D 4F 56 45 00          1615  moveout  DC.B    'MOVE',0
000021F7= 4D 4F 56 45 41 00       1616  moveaout DC.B      'MOVEA',0
000021FD= 4D 4F 56 45 51 00       1617  moveqout DC.B   'MOVEQ',0
00002203= 4D 4F 56 45 4D 00       1618  movemout DC.B   'MOVEM',0
00002209                          1619  
00002209= 53 55 42 00             1620  subout    DC.B  'SUB',0
0000220D= 41 44 44 00             1621  addout    DC.B 'ADD',0
00002211= 41 44 44 41 00          1622  addaout    DC.B 'ADDA',0
00002216= 41 44 44 51 00          1623  addqout    DC.B 'ADDQ',0
0000221B                          1624  
0000221B= 4C 45 41 00             1625  leaout    DC.B  'LEA',0
0000221F                          1626  
0000221F= 4E 4F 54 00             1627  notout    DC.B  'NOT',0
00002223= 4F 52 00                1628  orout DC.B     'OR',0
00002226= 41 4E 44 00             1629  andout DC.B     'AND',0
0000222A                          1630  
0000222A                          1631  
0000222A= 4C 53 4C 00             1632  lslout    DC.B  'LSL',0
0000222E= 4C 53 52 00             1633  lsrout    DC.B  'LSR',0
00002232= 41 53 4C 00             1634  aslout    DC.B  'ASL',0
00002236= 41 53 52 00             1635  asrout    DC.B  'ASR',0
0000223A                          1636  
0000223A= 52 4F 4C 00             1637  rolout    DC.B  'ROL',0
0000223E= 52 4F 52 00             1638  rorout    DC.B  'ROR',0
00002242                          1639  
00002242= 4A 53 52 00             1640  jsrout DC.B     'JSR',0
00002246= 52 54 53 0D 0A 00       1641  rtsout DC.B     'RTS',CR,LF,0
0000224C= 42 52 41 00             1642  braout DC.B     'BRA',0
00002250                          1643  
00002250= 44 41 54 41 20 20 ...   1644  dataout DC.B    'DATA   ',0
00002258                          1645  
00002258                          1646  
00002258                          1647  
00002258= 2E 42 20 20 20 20 00    1648  byteout  DC.B    '.B    ',0
0000225F= 2E 57 20 20 20 20 00    1649  wordout  DC.B    '.W    ',0
00002266= 2E 4C 20 20 20 20 00    1650  longout  DC.B    '.L    ',0
0000226D                          1651  
0000226D= 0D 0A 00                1652  empty    DC.B    '',CR,LF,0
00002270                          1653  
00002270  =0000000D               1654  CR  EQU $0D
00002270  =0000000A               1655  LF  EQU $0A
00002270                          1656  
00002270                          1657  
00002270                          1658      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 1424
ADDA                1462
ADDAOUT             2211
ADDOUT              220D
ADDQ                13E6
ADDQOUT             2216
ADDQ_EA             1A0E
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 16F2
ANDOUT              2226
ASL                 159A
ASLOUT              2232
ASR                 15D8
ASROUT              2236
ATOF                1F4C
ATOH                1874
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BRA                 1730
BRAOUT              224C
BYTE                1276
BYTEOUT             2258
CHECK_EA_AB_L       1BF4
CHECK_EA_AB_W       1BD4
CHECK_EA_AR         1B3C
CHECK_EA_IMM        1C12
CHECK_EA_INDIRECT   1B56
CHECK_EA_POST       1B7C
CHECK_EA_PRE        1BA8
CHECK_VALID_EA      1AD0
CLOSED_PAR_TAG      1D2A
COMMA_TAG           1D8A
CONVERTATOH         1874
CONVERTHTOA         1F38
CR                  D
DATA                1752
DATAOUT             2250
DOLLAR_TAG          1D2E
EA1_END             1952
EA1_MODE_ONE        1946
EA1_MODE_ZERO       194E
EA2_END             1996
EA2_IMMEDIATE       198E
EA2_REGISTER        1986
EA_GROUP1           1926
EA_GROUP2           1970
EA_GROUP3           19B6
EA_GROUP4           19D2
EMPTY               226D
END_SIMULATION      1F54
FINISH              18C8
FIRSTINPUT          1792
FORMAT_IMMEDIATE_DATA  18D4
FORWARD_SLASH_TAG   1D30
HASH_SIGN_TAG       1D2C
HERE                1020
HEX_TO_ASCII        1CC2
HEX_TO_ASCII_RETURN  1CD2
IMMEDIATE0          18E4
IMMEDIATE_END       18E6
INPUT1              8000
INPUT1MESSAGE       20D0
INPUT2              8004
INPUT2MESSAGE       20F6
INPUTERROR          18CA
INPUTERROR2SMALLER  213A
INPUTERRORBADCHAR   211C
INPUTQUALITY        21E9
INPUTREPEAT         2176
INPUT_BUFFER        1C66
INVALID_EA          1B0A
IPUT_BUFFER_EX      1C5E
JSR                 14BE
JSROUT              2242
LEA                 1692
LEAOUT              221B
LETTERS             1D22
LF                  A
LINECOUNTER         21EA
LONG                129E
LONGOUT             2266
LOWERCASE           18B0
LSL                 151E
LSLOUT              222A
LSR                 155C
LSROUT              222E
MEMORY_TO_REGISTER  1A68
MINUS_TAG           1D5C
MODE_010            1A96
MODE_01_0           1AC8
MOVE                12D2
MOVEA               131A
MOVEAOUT            21F7
MOVEM               1372
MOVEMOUT            2203
MOVEM_EA            1A5E
MOVEOUT             21F2
MOVEQ               1350
MOVEQOUT            21FD
MOVEQ_EA            1A36
MOVE_MOVEA_EA       18E8
NEWLINE             21E3
NEWLINE_TAG         1DB4
NOP                 12B2
NOPOUT              21EC
NOT                 14E0
NOTOUT              221F
NUMBER_TO_ASCII     1CD8
OPCODE              1178
OPEN_PAR_TAG        1D28
OR                  16B4
OROUT               2223
OUTPUT              1E08
OUTPUTADDRESS       1EE2
OUTPUTADDRESSLOOP   1EF6
OUTPUTADDRESSLOOPEND  1F18
OUTPUTDATA          1E8C
OUTPUTDATALOOP      1EA0
OUTPUTDATALOOPEND   1EC2
OUTPUTNEWSCREEN     21C0
OUTPUTOPCODE        1E38
OUTPUTOPCODENEWSCREEN  1E52
OUTPUTSIZE          1E84
OUTPUTTYPE          21EB
PLUS_TAG            1D5A
POPULATE_BUFFER     1C98
PRINT_BUFFER        1C54
PRINT_CLOSED_PARENTHESIS  1D46
PRINT_COMMA         1D8C
PRINT_DOLLAR        1DE0
PRINT_EA            1B14
PRINT_EA_RETURN     1C4E
PRINT_FORWARD_SLASH  1DF4
PRINT_HASH_SIGN     1DCC
PRINT_HEX           1C76
PRINT_HEX_RETURN    1C8C
PRINT_MINUS         1D72
PRINT_NEWLINE       1DB8
PRINT_OPEN_PARENTHESIS  1D32
PRINT_PLUS          1D5E
PRINT_REGISTOR      1CDE
PRINT_REGISTOR_RETURN  1D0E
PRINT_TAB           1DA0
READ_WORD_IMM       1C36
REGISTER_TO_MEMORY  1AA4
RETURN              1274
ROL                 1616
ROLOUT              223A
ROR                 1654
ROROUT              223E
RTS                 149C
RTSOUT              2246
SECONDINPUT         17F6
SPACES              21E6
SPACE_TAG           1D88
START               1000
STARTMESSAGE        1F5E
SUB                 13A8
SUBOUT              2209
TAB_TAG             1D86
THERE               114C
THROWINPUT1CHARERROR  17D8
THROWINPUT2CHARERROR  1844
THROWINPUT2LOWERERROR  1860
TO_STRING           1D14
UPPERCASE           1898
USERINPUT           1780
USERINPUTREPEAT     114E
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1AF2
WELCOMEEXPLANATION  1780
WORD                128A
WORDOUT             225F
WRONG_INSTRUCTION   1A8C
ZEROTONINE          1F44
