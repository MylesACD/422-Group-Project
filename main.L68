00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/11/2022 1:28:17 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 00002422        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 0930                 15      BSR     USERINPUT
0000100C  45F9 00008000             16      LEA     input1,A2
00001012                            17  *memoryLoop
00001012                            18     * BSR     OPCODE
00001012                            19     * ADD.L   #2,A2
00001012                            20      *CMP.B   A2,(input2)
00001012                            21      *BGE     userInputRepeat
00001012                            22      *BRA     memoryLoop
00001012                            23  
00001012                            24      
00001012                            25  *testing purposes----------------------------------------------------
00001012  1C3C 0004                 26      MOVE.B #$04, D6
00001016  347C 1004                 27      MOVE.W #$1004, A2
0000101A  7C0A                      28      MOVEQ #10, D6
0000101C  264A                      29      MOVEA.L A2, A3
0000101E  B641                      30      CMP D1,D3
00001020  9C82                      31      SUB.L D2, D6
00001022                            32  
00001022  6000 0002                 33      BRA here
00001026                            34  here
00001026  4EB9 0000118C             35      JSR there
0000102C  4693                      36      NOT.L (A3)
0000102E  47D1                      37      LEA (A1),A3
00001030  8AB9 00008000             38      OR.L input1, D5
00001036  48E7 FFFE                 39      MOVEM.L D0-D7/A0-A6,-(SP) 
0000103A  CC01                      40      AND.B D1,D6
0000103C  D803                      41      ADD.B D3,D4
0000103E  D4C9                      42      ADDA.W A1,A2
00001040  5E81                      43      ADDQ.L #7,D1
00001042  E709                      44      LSL.B #3,D1
00001044  E449                      45      lSR.W #2,D1
00001046  ED02                      46      ASL.B #6,D2
00001048  EA42                      47      ASR.W #5,D2
0000104A  EB1B                      48      ROL.B #5,D3
0000104C  E85B                      49      ROR.W #4,D3
0000104E  6E00 000E                 50      BGT letsgo
00001052  B67C 0004                 51      CMP #4,D3 
00001056  6700 0006                 52      BEQ letsgo
0000105A  6F00 0002                 53      BLE letsgo
0000105E                            54     
0000105E                            55  letsgo
0000105E                            56      
0000105E                            57  * calls-------------------------------------------------------
0000105E  347C 1012                 58      MOVE.W #$1012, A2
00001062  6100 0154                 59      BSR     OPCODE * test MOVE.B
00001066                            60  
00001066  347C 1016                 61      MOVE.W #$1016, A2
0000106A  6100 014C                 62      BSR     OPCODE * test MOVEA.W
0000106E                            63      
0000106E  347C 101A                 64      MOVE.W #$101A, A2
00001072  6100 0144                 65      BSR     OPCODE * test MOVEQ
00001076                            66     
00001076  347C 101C                 67      MOVE.W #$101C, A2
0000107A  6100 013C                 68      BSR     OPCODE *test MOVEA.L
0000107E                            69      
0000107E  347C 101E                 70      MOVE.W #$101E, A2
00001082  6100 0134                 71      BSR     OPCODE *test DATA
00001086                            72      
00001086                            73      
00001086  347C 1020                 74      MOVE.W #$1020, A2
0000108A  6100 012C                 75      BSR     OPCODE *test SUB.L
0000108E                            76      
0000108E  347C 1022                 77      MOVE.W #$1022, A2
00001092  6100 0124                 78      BSR     OPCODE *test BRA
00001096                            79      
00001096  347C 1026                 80      MOVE.W #$1026, A2
0000109A  6100 011C                 81      BSR     OPCODE *test JSR
0000109E                            82      
0000109E                            83      
0000109E  43F9 000024BE             84      LEA empty,A1
000010A4  13FC 0001 00002423        85      MOVE.B  #1,(OutputType)       
000010AC  6100 0F92                 86      BSR    OUTPUT
000010B0                            87  
000010B0                            88      
000010B0  347C 102C                 89      MOVE.W #$102C, A2
000010B4  6100 0102                 90      BSR     OPCODE *test NOT
000010B8                            91      
000010B8  347C 102E                 92      MOVE.W #$102E, A2
000010BC  6100 00FA                 93      BSR     OPCODE *test LEA
000010C0                            94      
000010C0  347C 1030                 95      MOVE.W #$1030, A2
000010C4  6100 00F2                 96      BSR     OPCODE *test OR
000010C8                            97      
000010C8  43F9 000024BE             98       LEA empty,A1
000010CE  13FC 0001 00002423        99      MOVE.B  #1,(OutputType)       
000010D6  6100 0F68                100      BSR    OUTPUT
000010DA                           101  
000010DA                           102      
000010DA  347C 1036                103      MOVE.W #$1036, A2
000010DE  6100 00D8                104      BSR     OPCODE *test MOVEM
000010E2                           105  
000010E2  347C 103A                106      MOVE.W #$103A, A2
000010E6  6100 00D0                107      BSR     OPCODE *test AND
000010EA                           108      
000010EA  347C 103C                109      MOVE.W #$103C, A2
000010EE  6100 00C8                110      BSR     OPCODE *test ADD
000010F2                           111      
000010F2  43F9 000024BE            112      LEA empty,A1
000010F8  13FC 0001 00002423       113      MOVE.B  #1,(OutputType) * new line  
00001100  6100 0F3E                114      BSR    OUTPUT
00001104                           115  
00001104  347C 103E                116      MOVE.W #$103E, A2
00001108  6100 00AE                117      BSR     OPCODE *test ADDA
0000110C                           118      
0000110C  347C 1040                119      MOVE.W #$1040, A2
00001110  6100 00A6                120      BSR     OPCODE *test ADDQ
00001114                           121      
00001114  347C 1042                122      MOVE.W #$1042, A2
00001118  6100 009E                123      BSR     OPCODE *test LSL
0000111C                           124  
0000111C  347C 1044                125      MOVE.W #$1044, A2
00001120  6100 0096                126      BSR     OPCODE *test LSR
00001124                           127      
00001124  347C 1046                128      MOVE.W #$1046, A2
00001128  6100 008E                129      BSR     OPCODE *test ASL
0000112C                           130      
0000112C  43F9 000024BE            131      LEA empty,A1
00001132  13FC 0001 00002423       132      MOVE.B  #1,(OutputType) * new line  
0000113A  6100 0F04                133      BSR    OUTPUT
0000113E                           134  
0000113E                           135  
0000113E  347C 1048                136      MOVE.W #$1048, A2
00001142  6100 0074                137      BSR     OPCODE *test ASR
00001146                           138      
00001146                           139      
00001146  347C 104A                140      MOVE.W #$104A, A2
0000114A  6100 006C                141      BSR     OPCODE *test ROL
0000114E                           142  
0000114E  347C 104C                143      MOVE.W #$104C, A2
00001152  6100 0064                144      BSR     OPCODE *test ROR
00001156                           145      
00001156  43F9 000024BE            146      LEA empty,A1
0000115C  13FC 0001 00002423       147      MOVE.B  #1,(OutputType) * new line  
00001164  6100 0EDA                148      BSR    OUTPUT
00001168                           149  
00001168  347C 104E                150      MOVE.W #$104E, A2
0000116C  6100 004A                151      BSR     OPCODE *test BGT
00001170                           152  
00001170  347C 1056                153      MOVE.W #$1056, A2
00001174  6100 0042                154      BSR     OPCODE *test BEQ
00001178                           155      
00001178  347C 105A                156      MOVE.W #$105A, A2
0000117C  6100 003A                157      BSR     OPCODE *test BLE
00001180                           158      
00001180                           159  
00001180                           160    
00001180  347C 118C                161      MOVE.W #$118C, A2
00001184  6100 0032                162      BSR     OPCODE *test RTS
00001188                           163  
00001188                           164  
00001188                           165  * calls---------------------------------------------------------    
00001188  6000 0004                166      BRA userInputRepeat
0000118C                           167  there    
0000118C  4E75                     168      RTS
0000118E                           169  * end testing--------------------------------------------------------------
0000118E                           170   
0000118E                           171  
0000118E                           172       
0000118E                           173    
0000118E                           174  
0000118E                           175      
0000118E                           176  userInputRepeat
0000118E  43F9 000023AE            177      LEA     INPUTREPEAT,A1
00001194  103C 000E                178      MOVE.B  #14,D0
00001198  4E4F                     179      TRAP    #15
0000119A  5239 00002422            180      ADD.B   #1,(LineCounter)
000011A0                           181      
000011A0  43F9 00008008            182      LEA     userInputStored,A1
000011A6  103C 0005                183      MOVE.B  #5,D0
000011AA  4E4F                     184      TRAP    #15
000011AC                           185      
000011AC  B23C 000D                186      CMP.B   #$0D,D1
000011B0  6700 FE56                187      BEQ     userInputStart
000011B4                           188   
000011B4  FFFF FFFF                189      SIMHALT
000011B8                           190  
000011B8                           191  **********************************************************
000011B8                           192  *Subroutine: OPCODE
000011B8                           193  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B8                           194  *Registers: 
000011B8                           195  *A1: printing
000011B8                           196  *A2: parameter with instruction address
000011B8                           197  *D0: printing
000011B8                           198  *D3: used for determing the instruction, mostly shifts
000011B8                           199  *D2: used for determing the size
000011B8                           200  *D4: used for passing size to SIZE
000011B8                           201  *Paramemeters: A2 the memory address to decode from
000011B8                           202  **********************************************************
000011B8                           203  OPCODE:
000011B8  4243                     204      CLR D3
000011BA                           205      
000011BA  0C52 4E75                206      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011BE  6700 0380                207      BEQ rts
000011C2                           208      
000011C2  0C52 4E71                209      CMP #$4E71, (A2) *NOP compare
000011C6  6700 0138                210      BEQ nop
000011CA                           211      
000011CA  3612                     212      Move.W (A2), D3 
000011CC  E04B                     213      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011CE  E84B                     214      LSR #4,D3
000011D0                           215      
000011D0                           216      
000011D0  B67C 0008                217      CMP #%1000, D3 * OR compare
000011D4  6700 05F0                218      BEQ or
000011D8                           219      
000011D8                           220      
000011D8  B67C 0003                221      CMP #%0011, D3 *MOVE and MOVEA compare
000011DC  6F00 0142                222      BLE move
000011E0                           223      
000011E0  B67C 0007                224      CMP #%0111, D3 *MOVEQ compare
000011E4  6700 01C8                225      BEQ moveq
000011E8                           226      
000011E8  B67C 0009                227      CMP #%1001, D3 *SUB compare
000011EC  6700 022A                228      BEQ sub
000011F0                           229      
000011F0  B67C 000C                230      CMP #%1100, D3 *AND compare
000011F4  6700 061C                231      BEQ and
000011F8                           232      
000011F8  B67C 0005                233      CMP #%0101, D3 *ADDQ compare
000011FC  6700 0266                234      BEQ addq
00001200                           235      
00001200  B67C 0006                236      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
00001204  6700 0658                237      BEQ bcc
00001208                           238      
00001208                           239  
00001208  3612                     240      Move.W (A2), D3 * reset D3
0000120A  0243 F118                241      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
0000120E  B67C E108                242      CMP #%1110000100001000,D3 * LSL compare
00001212  6700 03C4                243      BEQ lsl
00001216                           244  
00001216  3612                     245      Move.W (A2), D3 * reset D3
00001218  0243 F118                246      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
0000121C  B67C E008                247      CMP #%1110000000001000,D3 * LSR compare
00001220  6700 0402                248      BEQ lsr
00001224                           249      
00001224                           250      
00001224  3612                     251      Move.W (A2), D3 * reset D3
00001226  0243 F118                252      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
0000122A  B67C E100                253      CMP #%1110000100000000,D3 * ASL compare
0000122E  6700 0440                254      BEQ asl
00001232                           255  
00001232  3612                     256      Move.W (A2), D3 * reset D3
00001234  0243 F118                257      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001238  B67C E000                258      CMP #%1110000000000000,D3 * ASR compare
0000123C  6700 047E                259      BEQ asr
00001240                           260  
00001240  3612                     261      Move.W (A2), D3 * reset D3
00001242  0243 F118                262      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001246  B67C E118                263      CMP #%1110000100011000,D3 * ROL compare
0000124A  6700 04BC                264      BEQ rol
0000124E                           265  
0000124E  3612                     266      Move.W (A2), D3 * reset D3
00001250  0243 F118                267      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001254  B67C E018                268      CMP #%1110000000011000,D3 * ROR compare
00001258  6700 04FA                269      BEQ ror
0000125C                           270  
0000125C                           271      
0000125C                           272      
0000125C  3612                     273      Move.W (A2), D3 * reset D3
0000125E  0243 F0C0                274      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
00001262  B67C D0C0                275      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001266  6700 0294                276      BEQ adda
0000126A                           277      
0000126A  3612                     278      Move.W (A2), D3 
0000126C  E04B                     279      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
0000126E  E84B                     280      LSR #4,D3
00001270  B67C 000D                281      CMP #%1101, D3 *ADD compare
00001274  6700 023A                282      BEQ add
00001278                           283  
00001278                           284    
00001278  3612                     285      Move.W (A2), D3 * reset D3
0000127A  0243 FB80                286      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
0000127E  B67C 4880                287      CMP #%0100100010000000,D3 * MOVEM compare
00001282  6700 0150                288      BEQ movem
00001286                           289  
00001286                           290      
00001286                           291      
00001286  3612                     292      Move.W (A2), D3 * reset D3
00001288  EC4B                     293      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
0000128A  B67C 013A                294      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
0000128E  6700 02D6                295      BEQ jsr
00001292                           296  
00001292  3612                     297      Move.W (A2), D3 * reset D3
00001294  E04B                     298      LSR #8,D3 * make D3 only contain the first 8 bits
00001296  B67C 0046                299      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
0000129A  6700 02F0                300      BEQ not
0000129E                           301      
0000129E  3612                     302      Move.W (A2), D3 * reset D3
000012A0  0243 F1C0                303      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
000012A4  B67C 41C0                304      CMP #%0100000111000000,D3 *LEA compare
000012A8  6700 04F6                305      BEQ lea
000012AC                           306      
000012AC                           307      
000012AC                           308      
000012AC                           309      
000012AC                           310      
000012AC                           311  
000012AC                           312  
000012AC                           313     
000012AC  3612                     314      Move.W (A2), D3 * reset D3
000012AE  E04B                     315      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012B0  B67C 0060                316      CMP #%01100000, D3 *BRA compare
000012B4  6700 0634                317      BEQ bra
000012B8                           318      
000012B8                           319      
000012B8  6000 0652                320      BRA data
000012BC                           321      
000012BC                           322  return
000012BC  4E75                     323      RTS
000012BE                           324      
000012BE                           325  
000012BE                           326  
000012BE                           327      
000012BE                           328  byte
000012BE  43F9 000024A1            329      LEA    byteout,A1        
000012C4  13FC 0002 00002423       330      MOVE.B  #2,(OutputType)
000012CC  6100 0D72                331      BSR     OUTPUT 
000012D0  2257                     332      MOVE.L (SP),A1 
000012D2  4ED1                     333      JMP (A1)
000012D4                           334  
000012D4                           335  word
000012D4  43F9 000024A8            336      LEA    wordout,A1        
000012DA  13FC 0002 00002423       337      MOVE.B  #2,(OutputType)
000012E2  6100 0D5C                338      BSR     OUTPUT
000012E6  2257                     339      MOVE.L (SP),A1 
000012E8  4ED1                     340      JMP (A1)
000012EA                           341  
000012EA                           342  long
000012EA  43F9 000024AF            343      LEA    longout,A1        
000012F0  13FC 0002 00002423       344      MOVE.B  #2,(OutputType)
000012F8  6100 0D46                345      BSR     OUTPUT
000012FC  2257                     346      MOVE.L (SP),A1 
000012FE  4ED1                     347      JMP (A1)
00001300                           348      
00001300                           349       
00001300                           350      
00001300                           351  nop 
00001300  13FC 0004 00002423       352      MOVE.B  #4,(OutputType)
00001308  6100 0D36                353      BSR     OUTPUT
0000130C  43F9 00002425            354      LEA    nopout,A1        
00001312  13FC 0001 00002423       355      MOVE.B  #1,(OutputType)
0000131A  6100 0D24                356      BSR     OUTPUT
0000131E  609C                     357      BRA return
00001320                           358      
00001320                           359  move
00001320                           360      * put the size of the instruction into D2 to use later
00001320                           361      * since the first two bits of D3 are 00 for move moving the entire word works
00001320  3403                     362      Move.W D3, D2
00001322                           363  
00001322                           364  
00001322                           365      * determine if MOVE or MOVEA
00001322                           366      * if bits 8,7,6 = 001 its MOVEA
00001322  3612                     367      MOVE.W (A2),D3
00001324  0243 01C0                368      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
00001328                           369      
00001328  B67C 0040                370      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
0000132C  6700 0044                371      BEQ movea
00001330                           372      
00001330  13FC 0004 00002423       373      MOVE.B  #4,(OutputType)
00001338  6100 0D06                374      BSR     OUTPUT
0000133C                           375  
0000133C  43F9 0000242B            376      LEA    moveout,A1     *print the type
00001342  13FC 0001 00002423       377      MOVE.B  #1,(OutputType)   
0000134A  6100 0CF4                378      BSR    OUTPUT
0000134E                           379      
0000134E                           380      *now to print size  
0000134E  4879 0000136A            381      PEA op1
00001354                           382      
00001354  B47C 0002                383      cmp #2,D2 *if the size is 2 branch to long
00001358  6790                     384      BEQ long
0000135A  B47C 0003                385      cmp #3,D2 *if the size is 3 branch to word
0000135E  6700 FF74                386      BEQ word
00001362  B47C 0001                387      cmp #1,D2 * if the size is 1 branch to byte
00001366  6700 FF56                388      BEQ byte   
0000136A                           389  op1
0000136A  6100 07B4                390      BSR MOVE_MOVEA_EA
0000136E  6000 FF4C                391      BRA return
00001372                           392      
00001372                           393  movea
00001372  13FC 0004 00002423       394      MOVE.B  #4,(OutputType)
0000137A  6100 0CC4                395      BSR     OUTPUT
0000137E                           396  
0000137E  43F9 00002430            397      LEA    moveaout,A1
00001384  13FC 0001 00002423       398      MOVE.B  #1,(OutputType)       
0000138C  6100 0CB2                399      BSR    OUTPUT
00001390                           400      
00001390                           401      *now to print size  
00001390  4879 000013A6            402      PEA op2
00001396                           403  
00001396  B47C 0002                404      cmp #2,D2 *if the size is 2 branch to long
0000139A  6700 FF4E                405      BEQ long
0000139E  B47C 0003                406      cmp #3,D2 *if the size is 3 branch to word
000013A2  6700 FF30                407      BEQ word
000013A6                           408  op2
000013A6  6100 0778                409      BSR MOVE_MOVEA_EA
000013AA  6000 FF10                410      BRA return
000013AE                           411      
000013AE                           412  moveq
000013AE  13FC 0004 00002423       413      MOVE.B  #4,(OutputType)
000013B6  6100 0C88                414      BSR     OUTPUT
000013BA                           415  
000013BA  43F9 00002436            416      LEA    moveqout,A1
000013C0  13FC 0001 00002423       417      MOVE.B  #1,(OutputType)       
000013C8  6100 0C76                418      BSR    OUTPUT
000013CC  6100 08A0                419      BSR MOVEQ_EA
000013D0  6000 FEEA                420      BRA return
000013D4                           421  
000013D4                           422      
000013D4                           423  movem
000013D4  13FC 0004 00002423       424      MOVE.B  #4,(OutputType)
000013DC  6100 0C62                425      BSR     OUTPUT
000013E0                           426      
000013E0  43F9 0000243C            427      LEA    movemout,A1
000013E6  13FC 0001 00002423       428      MOVE.B  #1,(OutputType)       
000013EE  6100 0C50                429      BSR    OUTPUT
000013F2                           430      
000013F2  4879 00001410            431      PEA op3
000013F8  3412                     432      MOVE.W (A2),D2
000013FA  0242 0040                433      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013FE  EC4A                     434      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001400  B47C 0001                435      CMP #1, D2 * if the size is 1 branch to long
00001404  6700 FEE4                436      BEQ long
00001408  B47C 0000                437      CMP #0, D2 * if the size is 0 branch to long
0000140C  6700 FEC6                438      BEQ word
00001410                           439  op3
00001410  6100 0884                440      BSR MOVEM_EA
00001414  6000 FEA6                441      BRA return
00001418                           442      
00001418                           443      
00001418                           444  sub 
00001418  13FC 0004 00002423       445      MOVE.B  #4,(OutputType)
00001420  6100 0C1E                446      BSR     OUTPUT
00001424                           447     
00001424  43F9 00002442            448      LEA    subout,A1
0000142A  13FC 0001 00002423       449      MOVE.B  #1,(OutputType)       
00001432  6100 0C0C                450      BSR    OUTPUT
00001436                           451      
00001436  3412                     452      MOVE.W (A2),D2
00001438  0242 00C0                453      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000143C  EC4A                     454      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000143E                           455  
0000143E                           456  
0000143E                           457      
0000143E                           458      *now to print size  
0000143E  4879 0000145C            459      PEA op4
00001444  B47C 0002                460      cmp #2,D2 *if the size is 2 branch to long
00001448  6700 FEA0                461      BEQ long
0000144C  B47C 0001                462      cmp #1,D2 *if the size is 1 branch to word
00001450  6700 FE82                463      BEQ word
00001454  B47C 0000                464      cmp #0,D2 *if the size is 0 branch to byte
00001458  6700 FE64                465      BEQ byte 
0000145C                           466  op4
0000145C  6100 0700                467      BSR EA_GROUP1
00001460  6000 FE5A                468      BRA return
00001464                           469      
00001464                           470  addq 
00001464  13FC 0004 00002423       471      MOVE.B  #4,(OutputType)
0000146C  6100 0BD2                472      BSR     OUTPUT
00001470                           473     
00001470  43F9 0000244F            474      LEA    addqout,A1
00001476  13FC 0001 00002423       475      MOVE.B  #1,(OutputType)       
0000147E  6100 0BC0                476      BSR    OUTPUT
00001482                           477      
00001482  3412                     478      MOVE.W (A2),D2
00001484  0242 00C0                479      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001488  EC4A                     480      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000148A                           481  
0000148A                           482  
0000148A                           483      
0000148A                           484      *now to print size  
0000148A  4879 000014A8            485      PEA op5
00001490  B47C 0002                486      cmp #2,D2 *if the size is 2 branch to long
00001494  6700 FE54                487      BEQ long
00001498  B47C 0001                488      cmp #1,D2 *if the size is 1 branch to word
0000149C  6700 FE36                489      BEQ word
000014A0  B47C 0000                490      cmp #0,D2 *if the size is 0 branch to byte
000014A4  6700 FE18                491      BEQ byte *otherwise branch to byte
000014A8                           492  op5    
000014A8  6100 079C                493      BSR ADDQ_EA
000014AC  6000 FE0E                494      BRA return    
000014B0                           495      
000014B0                           496      
000014B0                           497  add
000014B0  13FC 0004 00002423       498      MOVE.B  #4,(OutputType)
000014B8  6100 0B86                499      BSR     OUTPUT
000014BC                           500  
000014BC  43F9 00002446            501      LEA    addout,A1
000014C2  13FC 0001 00002423       502      MOVE.B  #1,(OutputType)       
000014CA  6100 0B74                503      BSR    OUTPUT
000014CE                           504      
000014CE  3412                     505      MOVE.W (A2),D2
000014D0  0242 00C0                506      ANDI.W #%0000000011000000, D2 * set to only the size bits
000014D4  EC4A                     507      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000014D6                           508  
000014D6                           509  
000014D6                           510      
000014D6                           511      *now to print size  
000014D6  4879 000014F4            512      PEA op6
000014DC  B47C 0002                513      cmp #2,D2 *if the size is 2 branch to long
000014E0  6700 FE08                514      BEQ long
000014E4  B47C 0001                515      cmp #1,D2 *if the size is 1 branch to word
000014E8  6700 FDEA                516      BEQ word
000014EC  B47C 0000                517      cmp #0,D2 *if the size is 0 branch to byte
000014F0  6700 FDE2                518      BEQ word
000014F4                           519  op6
000014F4  6100 0668                520      BSR EA_GROUP1
000014F8  6000 FDC2                521      BRA return
000014FC                           522  
000014FC                           523  adda
000014FC                           524  
000014FC  13FC 0004 00002423       525      MOVE.B  #4,(OutputType)
00001504  6100 0B3A                526      BSR     OUTPUT
00001508                           527  
00001508  43F9 0000244A            528      LEA    addaout,A1
0000150E  13FC 0001 00002423       529      MOVE.B  #1,(OutputType)       
00001516  6100 0B28                530      BSR    OUTPUT
0000151A                           531      
0000151A  3412                     532      MOVE.W (A2),D2
0000151C  0242 0100                533      ANDI.W #%0000000100000000, D2 * set to only the size bit
00001520  E04A                     534      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
00001522                           535  
00001522                           536  
00001522                           537      
00001522                           538      *now to print size  
00001522  4879 00001538            539      PEA op7
00001528  B47C 0001                540      cmp #1,D2 *if the size is 1 branch to long
0000152C  6700 FDBC                541      BEQ long
00001530  B47C 0000                542      cmp #0,D2 *if the size is 0 branch to word
00001534  6700 FD9E                543      BEQ word
00001538                           544  op7
00001538  6100 06D0                545      BSR EA_GROUP4
0000153C  6000 FD7E                546      BRA return
00001540                           547  
00001540                           548      
00001540                           549  rts
00001540  13FC 0004 00002423       550      MOVE.B  #4,(OutputType)
00001548  6100 0AF6                551      BSR     OUTPUT
0000154C                           552  
0000154C  43F9 0000248F            553      LEA    rtsout,A1
00001552  13FC 0001 00002423       554      MOVE.B  #1,(OutputType)       
0000155A  6100 0AE4                555      BSR    OUTPUT
0000155E                           556      
0000155E  6100 0648                557      BSR EA_GROUP2
00001562  6000 FD58                558      BRA return
00001566                           559      
00001566                           560      
00001566                           561  jsr 
00001566  13FC 0004 00002423       562      MOVE.B  #4,(OutputType)
0000156E  6100 0AD0                563      BSR     OUTPUT
00001572                           564     
00001572  43F9 0000248B            565      LEA    jsrout,A1
00001578  13FC 0001 00002423       566      MOVE.B  #1,(OutputType)       
00001580  6100 0ABE                567      BSR    OUTPUT
00001584                           568      
00001584  6100 0622                569      BSR EA_GROUP2
00001588  6000 FD32                570      BRA return
0000158C                           571      
0000158C                           572      
0000158C                           573  not 
0000158C  13FC 0004 00002423       574      MOVE.B  #4,(OutputType)
00001594  6100 0AAA                575      BSR     OUTPUT
00001598                           576    
00001598  43F9 0000245C            577      LEA    notout,A1
0000159E  13FC 0001 00002423       578      MOVE.B  #1,(OutputType)       
000015A6  6100 0A98                579      BSR    OUTPUT
000015AA                           580      
000015AA  3412                     581      MOVE.W (A2),D2
000015AC  0242 00C0                582      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015B0  EC4A                     583      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015B2                           584  
000015B2                           585      *now to print size  
000015B2  4879 000015D0            586      PEA op8
000015B8  B47C 0002                587      cmp #2,D2 *if the size is 2 branch to long
000015BC  6700 FD2C                588      BEQ long
000015C0  B47C 0001                589      cmp #1,D2 *if the size is 1 branch to word
000015C4  6700 FD0E                590      BEQ word
000015C8  B47C 0000                591      cmp #0,D2 *if the size is 0 branch to byte
000015CC  6700 FCF0                592      BEQ byte
000015D0                           593  
000015D0                           594      
000015D0                           595  op8    
000015D0  6100 061C                596      BSR EA_GROUP3
000015D4                           597      
000015D4  6000 FCE6                598      BRA return
000015D8                           599  
000015D8                           600  lsl
000015D8  13FC 0004 00002423       601      MOVE.B  #4,(OutputType)
000015E0  6100 0A5E                602      BSR     OUTPUT
000015E4                           603  
000015E4  43F9 00002467            604      LEA    lslout,A1
000015EA  13FC 0001 00002423       605      MOVE.B  #1,(OutputType)       
000015F2  6100 0A4C                606      BSR    OUTPUT
000015F6                           607      
000015F6  3412                     608      MOVE.W (A2),D2
000015F8  0242 00C0                609      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015FC  EC4A                     610      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015FE                           611  
000015FE                           612  
000015FE                           613      
000015FE                           614      *now to print size 
000015FE  4879 0000161C            615      PEA op9 
00001604  B47C 0002                616      cmp #2,D2 *if the size is 2 branch to long
00001608  6700 FCE0                617      BEQ long
0000160C  B47C 0001                618      cmp #1,D2 *if the size is 1 branch to word
00001610  6700 FCC2                619      BEQ word
00001614  B47C 0000                620      cmp #0,D2 *if the size is 0 branch to byte
00001618  6700 FCA4                621      BEQ byte
0000161C                           622  op9
0000161C  6100 058A                623      BSR EA_GROUP2
00001620  6000 FC9A                624      BRA return
00001624                           625  
00001624                           626  lsr
00001624  13FC 0004 00002423       627      MOVE.B  #4,(OutputType)
0000162C  6100 0A12                628      BSR     OUTPUT
00001630                           629  
00001630  43F9 0000246B            630      LEA    lsrout,A1
00001636  13FC 0001 00002423       631      MOVE.B  #1,(OutputType)       
0000163E  6100 0A00                632      BSR    OUTPUT
00001642                           633      
00001642  3412                     634      MOVE.W (A2),D2
00001644  0242 00C0                635      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001648  EC4A                     636      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000164A                           637  
0000164A                           638  
0000164A                           639      
0000164A                           640      *now to print size 
0000164A  4879 00001668            641      PEA op10 
00001650  B47C 0002                642      cmp #2,D2 *if the size is 2 branch to long
00001654  6700 FC94                643      BEQ long
00001658  B47C 0001                644      cmp #1,D2 *if the size is 1 branch to word
0000165C  6700 FC76                645      BEQ word
00001660  B47C 0000                646      cmp #0,D2 *if the size is 0 branch to byte
00001664  6700 FC58                647      BEQ byte
00001668                           648  op10
00001668  6100 053E                649      BSR EA_GROUP2
0000166C  6000 FC4E                650      BRA return
00001670                           651  asl
00001670  13FC 0004 00002423       652      MOVE.B  #4,(OutputType)
00001678  6100 09C6                653      BSR     OUTPUT
0000167C                           654  
0000167C  43F9 0000246F            655      LEA    aslout,A1
00001682  13FC 0001 00002423       656      MOVE.B  #1,(OutputType)       
0000168A  6100 09B4                657      BSR    OUTPUT
0000168E                           658      
0000168E  3412                     659      MOVE.W (A2),D2
00001690  0242 00C0                660      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001694  EC4A                     661      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001696                           662  
00001696                           663  
00001696                           664      
00001696                           665      *now to print size 
00001696  4879 000016B4            666      PEA op11 
0000169C  B47C 0002                667      cmp #2,D2 *if the size is 2 branch to long
000016A0  6700 FC48                668      BEQ long
000016A4  B47C 0001                669      cmp #1,D2 *if the size is 1 branch to word
000016A8  6700 FC2A                670      BEQ word
000016AC  B47C 0000                671      cmp #0,D2 *if the size is 0 branch to byte
000016B0  6700 FC0C                672      BEQ byte
000016B4                           673  op11
000016B4  6100 04F2                674      BSR EA_GROUP2
000016B8  6000 FC02                675      BRA return
000016BC                           676  
000016BC                           677  asr
000016BC  13FC 0004 00002423       678      MOVE.B  #4,(OutputType)
000016C4  6100 097A                679      BSR     OUTPUT
000016C8                           680  
000016C8  43F9 00002473            681      LEA    asrout,A1
000016CE  13FC 0001 00002423       682      MOVE.B  #1,(OutputType)       
000016D6  6100 0968                683      BSR    OUTPUT
000016DA                           684      
000016DA  3412                     685      MOVE.W (A2),D2
000016DC  0242 00C0                686      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016E0  EC4A                     687      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016E2                           688  
000016E2                           689  
000016E2                           690      
000016E2                           691       *now to print size 
000016E2  4879 00001700            692      PEA op12 
000016E8  B47C 0002                693      cmp #2,D2 *if the size is 2 branch to long
000016EC  6700 FBFC                694      BEQ long
000016F0  B47C 0001                695      cmp #1,D2 *if the size is 1 branch to word
000016F4  6700 FBDE                696      BEQ word
000016F8  B47C 0000                697      cmp #0,D2 *if the size is 0 branch to byte
000016FC  6700 FBC0                698      BEQ byte
00001700                           699  op12
00001700  6100 04A6                700      BSR EA_GROUP2
00001704  6000 FBB6                701      BRA return
00001708                           702      
00001708                           703  rol
00001708  13FC 0004 00002423       704      MOVE.B  #4,(OutputType)
00001710  6100 092E                705      BSR     OUTPUT
00001714                           706  
00001714  43F9 00002477            707      LEA    rolout,A1
0000171A  13FC 0001 00002423       708      MOVE.B  #1,(OutputType)       
00001722  6100 091C                709      BSR    OUTPUT
00001726                           710      
00001726  3412                     711      MOVE.W (A2),D2
00001728  0242 00C0                712      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000172C  EC4A                     713      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000172E                           714  
0000172E                           715  
0000172E                           716      
0000172E                           717     *now to print size 
0000172E  4879 0000174C            718      PEA op13 
00001734  B47C 0002                719      cmp #2,D2 *if the size is 2 branch to long
00001738  6700 FBB0                720      BEQ long
0000173C  B47C 0001                721      cmp #1,D2 *if the size is 1 branch to word
00001740  6700 FB92                722      BEQ word
00001744  B47C 0000                723      cmp #0,D2 *if the size is 0 branch to byte
00001748  6700 FB74                724      BEQ byte
0000174C                           725  op13
0000174C  6100 045A                726      BSR EA_GROUP2
00001750  6000 FB6A                727      BRA return
00001754                           728  
00001754                           729  ror
00001754  13FC 0004 00002423       730      MOVE.B  #4,(OutputType)
0000175C  6100 08E2                731      BSR     OUTPUT
00001760                           732  
00001760  43F9 0000247B            733      LEA    rorout,A1
00001766  13FC 0001 00002423       734      MOVE.B  #1,(OutputType)       
0000176E  6100 08D0                735      BSR    OUTPUT
00001772                           736      
00001772  3412                     737      MOVE.W (A2),D2
00001774  0242 00C0                738      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001778  EC4A                     739      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000177A                           740  
0000177A                           741  
0000177A                           742     *now to print size 
0000177A  4879 00001798            743      PEA op14 
00001780  B47C 0002                744      cmp #2,D2 *if the size is 2 branch to long
00001784  6700 FB64                745      BEQ long
00001788  B47C 0001                746      cmp #1,D2 *if the size is 1 branch to word
0000178C  6700 FB46                747      BEQ word
00001790  B47C 0000                748      cmp #0,D2 *if the size is 0 branch to byte
00001794  6700 FB28                749      BEQ byte
00001798                           750  op14
00001798  6100 040E                751      BSR EA_GROUP2
0000179C  6000 FB1E                752      BRA return
000017A0                           753      
000017A0                           754      
000017A0                           755  
000017A0                           756  lea
000017A0  13FC 0004 00002423       757      MOVE.B  #4,(OutputType)
000017A8  6100 0896                758      BSR     OUTPUT
000017AC                           759  
000017AC  43F9 00002454            760      LEA    leaout,A1
000017B2  13FC 0001 00002423       761      MOVE.B  #1,(OutputType)       
000017BA  6100 0884                762      BSR    OUTPUT
000017BE  6100 044A                763      BSR EA_GROUP4
000017C2  6000 FAF8                764      BRA return
000017C6                           765      
000017C6                           766  or
000017C6  13FC 0004 00002423       767      MOVE.B  #4,(OutputType)
000017CE  6100 0870                768      BSR     OUTPUT
000017D2                           769  
000017D2  43F9 00002460            770      LEA    orout,A1
000017D8  13FC 0001 00002423       771      MOVE.B  #1,(OutputType)       
000017E0  6100 085E                772      BSR    OUTPUT
000017E4                           773      
000017E4                           774          
000017E4  3412                     775      MOVE.W (A2),D2
000017E6  0242 00C0                776      ANDI.W #%0000000011000000, D2 * set to only the size bits
000017EA  EC4A                     777      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000017EC                           778  
000017EC                           779        *now to print size 
000017EC  4879 0000180A            780      PEA op15 
000017F2  B47C 0002                781      cmp #2,D2 *if the size is 2 branch to long
000017F6  6700 FAF2                782      BEQ long
000017FA  B47C 0001                783      cmp #1,D2 *if the size is 1 branch to word
000017FE  6700 FAD4                784      BEQ word
00001802  B47C 0000                785      cmp #0,D2 *if the size is 0 branch to byte
00001806  6700 FAB6                786      BEQ byte
0000180A                           787  op15    
0000180A  6100 0352                788      BSR EA_GROUP1
0000180E  6000 FAAC                789      BRA return
00001812                           790      
00001812                           791  and
00001812  13FC 0004 00002423       792      MOVE.B  #4,(OutputType)
0000181A  6100 0824                793      BSR     OUTPUT
0000181E                           794  
0000181E  43F9 00002463            795      LEA    andout,A1
00001824  13FC 0001 00002423       796      MOVE.B  #1,(OutputType)       
0000182C  6100 0812                797      BSR    OUTPUT
00001830                           798      
00001830                           799          
00001830  3412                     800      MOVE.W (A2),D2
00001832  0242 00C0                801      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001836  EC4A                     802      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001838                           803  
00001838                           804      *now to print size 
00001838  4879 00001856            805      PEA op16 
0000183E  B47C 0002                806      cmp #2,D2 *if the size is 2 branch to long
00001842  6700 FAA6                807      BEQ long
00001846  B47C 0001                808      cmp #1,D2 *if the size is 1 branch to word
0000184A  6700 FA88                809      BEQ word
0000184E  B47C 0000                810      cmp #0,D2 *if the size is 0 branch to byte
00001852  6700 FA6A                811      BEQ byte
00001856                           812  op16
00001856  6100 0306                813      BSR EA_GROUP1
0000185A  6000 FA60                814      BRA return    
0000185E                           815  
0000185E                           816  bcc
0000185E  4243                     817      CLR D3
00001860  3612                     818      MOVE.W (A2), D3
00001862                           819      
00001862  0243 0F00                820      ANDI.W #%0000111100000000,D3 * bits [11-8]
00001866  E04B                     821      LSR.W #8,D3
00001868  B67C 000E                822      CMP #%1110, D3 * BGT compare
0000186C  6700 0016                823      BEQ bgt
00001870  B67C 000F                824      CMP #%1111, D3 * BLE compare
00001874  6700 0030                825      BEQ ble
00001878  B67C 0007                826      CMP #%0111, D3 * BEQ compare
0000187C  6700 004A                827      BEQ beq
00001880  6000 008A                828      BRA data * goto data if doesn't work
00001884                           829  
00001884                           830  bgt
00001884  13FC 0004 00002423       831      MOVE.B  #4,(OutputType)
0000188C  6100 07B2                832      BSR     OUTPUT
00001890                           833  
00001890  43F9 0000247F            834      LEA    bgtout,A1
00001896  13FC 0001 00002423       835      MOVE.B  #1,(OutputType)       
0000189E  6100 07A0                836      BSR    OUTPUT
000018A2  6000 FA18                837      BRA return
000018A6                           838  
000018A6                           839  ble
000018A6  13FC 0004 00002423       840      MOVE.B  #4,(OutputType)
000018AE  6100 0790                841      BSR     OUTPUT
000018B2                           842  
000018B2  43F9 00002483            843      LEA    bleout,A1
000018B8  13FC 0001 00002423       844      MOVE.B  #1,(OutputType)       
000018C0  6100 077E                845      BSR    OUTPUT
000018C4  6000 F9F6                846      BRA return
000018C8                           847  beq
000018C8  13FC 0004 00002423       848      MOVE.B  #4,(OutputType)
000018D0  6100 076E                849      BSR     OUTPUT
000018D4                           850  
000018D4  43F9 00002487            851      LEA    beqout,A1
000018DA  13FC 0001 00002423       852      MOVE.B  #1,(OutputType)       
000018E2  6100 075C                853      BSR    OUTPUT
000018E6  6000 F9D4                854      BRA return
000018EA                           855  
000018EA                           856  bra
000018EA  13FC 0004 00002423       857      MOVE.B  #4,(OutputType)
000018F2  6100 074C                858      BSR     OUTPUT
000018F6                           859  
000018F6  43F9 00002495            860      LEA    braout,A1
000018FC  13FC 0001 00002423       861      MOVE.B  #1,(OutputType)       
00001904  6100 073A                862      BSR    OUTPUT
00001908  6000 F9B2                863      BRA return
0000190C                           864  
0000190C                           865  data
0000190C  13FC 0004 00002423       866      MOVE.B  #4,(OutputType)
00001914  6100 072A                867      BSR     OUTPUT
00001918                           868  
00001918  43F9 00002499            869      LEA    dataout,A1
0000191E  13FC 0001 00002423       870      MOVE.B  #1,(OutputType)       
00001926  6100 0718                871      BSR    OUTPUT
0000192A                           872      
0000192A  13FC 0003 00002423       873      MOVE.B  #3,(OutputType)       
00001932  6100 070C                874      BSR    OUTPUT     
00001936  6000 F984                875      BRA return
0000193A                           876  
0000193A                           877  
0000193A                           878  **********************************************************
0000193A                           879  *Subroutine: USERINPUT
0000193A                           880  *What it does: Takes in user input, rejects bad input
0000193A                           881  *Registers: Uses register A1, D0, D5
0000193A                           882  *A1: Stores messages and user input
0000193A                           883  *D0: Used for TRAP #15
0000193A                           884  *D5: Temporaraly stores user input to be masked then transfered
0000193A                           885  *Paramemeters: No parameters
0000193A                           886  **********************************************************
0000193A                           887  USERINPUT:
0000193A  4281                     888      CLR.L   D1
0000193C  4282                     889      CLR.L   D2
0000193E  4283                     890      CLR.L   D3
00001940  4284                     891      CLR.L   D4
00001942  4285                     892      CLR.L   D5
00001944  0C39 0000 00002424       893      CMP.B   #0,(RepeatFlag)
0000194C  6700 001A                894      BEQ     welcomeExplanation
00001950  6000 0030                895      BRA     firstInput
00001954  02B9 00000000 00008000   896      AND.L   #$00000000,(Input1)
0000195E  02B9 00000000 00008004   897      AND.L   #$00000000,(Input2)
00001968                           898      
00001968                           899  welcomeExplanation
00001968  43F9 00002196            900      LEA     STARTMESSAGE,A1         
0000196E  103C 000E                901      MOVE.B  #14,D0
00001972  4E4F                     902      TRAP    #15
00001974                           903      
00001974  5039 00002422            904      ADD.B   #8,(LineCounter)
0000197A  13FC 0001 00002424       905      MOVE.B  #1,(RepeatFlag)
00001982                           906  
00001982                           907  firstInput
00001982  43F9 00002308            908      LEA     INPUT1MESSAGE,A1        
00001988  103C 000E                909      MOVE.B  #14,D0                  
0000198C  4E4F                     910      TRAP    #15                     Asks user for first input
0000198E  5239 00002422            911      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001994                           912      
00001994  43F9 00008008            913      LEA     userInputStored,A1
0000199A  103C 0002                914      MOVE.B  #2,D0                   
0000199E  4E4F                     915      TRAP    #15                     User can input string for address
000019A0  5239 00002422            916      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000019A6                           917  
000019A6                           918      
000019A6  6100 0104                919      BSR     CONVERTATOH                 String converted to hex address
000019AA                           920      
000019AA  0C39 0000 00002421       921      CMP.B   #0,(InputQuality)       Checks if bad input flag set
000019B2  6700 0014                922      BEQ     throwInput1CharError
000019B6                           923  
000019B6                           924      
000019B6  CABC 00FFFFFF            925      AND.L   #$00FFFFFF,D5           
000019BC  23C5 00008000            926      MOVE.L  D5,input1               Moves result into input 1 memory location
000019C2  4285                     927      CLR.L   D5                      Clears D5 for future use
000019C4  6000 0020                928      BRA     secondInput
000019C8                           929      
000019C8                           930      
000019C8                           931  throwInput1CharError
000019C8  43F9 00002354            932      LEA     INPUTERRORBADCHAR,A1
000019CE  103C 000E                933      MOVE.B  #14,D0
000019D2  4E4F                     934      TRAP    #15                     Outputs bad character error message
000019D4  5639 00002422            935      ADD.B   #3,(LineCounter)        Adds 2 to line counter
000019DA                           936      
000019DA  13FC 0001 00002421       937      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
000019E2  4285                     938      CLR.L   D5                      Clears D5 for future use
000019E4                           939      
000019E4                           940      
000019E4                           941      
000019E4  609C                     942      BRA     firstInput              Tries again for input1
000019E6                           943  
000019E6                           944      
000019E6                           945  secondInput
000019E6  43F9 0000232E            946      LEA     INPUT2MESSAGE,A1        
000019EC  103C 000E                947      MOVE.B  #14,D0                  
000019F0  4E4F                     948      TRAP    #15                     Asks user for second input
000019F2  5239 00002422            949      ADD.B   #1,(LineCounter)
000019F8                           950      
000019F8  43F9 00008008            951      LEA     userInputStored,A1
000019FE  103C 0002                952      MOVE.B  #2,D0                   
00001A02  4E4F                     953      TRAP    #15                     User can input string for address
00001A04  5239 00002422            954      ADD.B   #1,(LineCounter)
00001A0A                           955  
00001A0A                           956      
00001A0A  6100 00A0                957      BSR     CONVERTATOH                 String converted to hex address
00001A0E                           958  
00001A0E  0C39 0000 00002421       959      CMP.B   #0,(InputQuality)       
00001A16  6700 001E                960      BEQ     throwInput2CharError    Checks if bad input flag set
00001A1A                           961      
00001A1A  CABC 00FFFFFF            962      AND.L   #$00FFFFFF,D5
00001A20  BAB9 00008000            963      CMP.L   (input1),D5
00001A26  6D00 002A                964      BLT     throwInput2LowerError
00001A2A  23C5 00008004            965      MOVE.L  D5,input2               Moves result into input 2 memory location
00001A30  4285                     966      CLR.L   D5                      Clears D5 for future use
00001A32  6000 0032                967      BRA     oddnumberchecker1
00001A36                           968  
00001A36                           969  
00001A36                           970      
00001A36                           971  throwInput2CharError
00001A36  43F9 00002354            972      LEA     INPUTERRORBADCHAR,A1    
00001A3C  103C 000E                973      MOVE.B  #14,D0
00001A40  4E4F                     974      TRAP    #15                     Outputs bad character error message
00001A42                           975      
00001A42  5639 00002421            976      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
00001A48  4285                     977      CLR.L   D5                      Clears D5 for future use
00001A4A                           978      
00001A4A  5639 00002422            979      ADD.B   #3,(LineCounter)
00001A50                           980      
00001A50  6094                     981      BRA     secondInput             Tries again for input2
00001A52                           982      
00001A52                           983  throwInput2LowerError
00001A52  43F9 00002372            984      LEA     INPUTERROR2SMALLER,A1
00001A58  103C 000E                985      MOVE.B  #14,D0
00001A5C  4E4F                     986      TRAP    #15
00001A5E                           987      
00001A5E  5639 00002422            988      ADD.B   #3,(LineCounter)
00001A64                           989      
00001A64  6080                     990      BRA     secondInput
00001A66                           991      
00001A66                           992  oddnumberchecker1
00001A66                           993  
00001A66  2C39 00008000            994      MOVE.L  (input1),D6
00001A6C  CCBC 0000000F            995      AND.L   #$0000000F,D6
00001A72  CC3C 0001                996      AND.B   #%0001,D6
00001A76  BC3C 0001                997      CMP.B   #%0001,D6
00001A7A  6700 0006                998      BEQ     oddnumber1
00001A7E  6000 000A                999      BRA     oddnumberchecker2
00001A82                          1000      
00001A82                          1001  oddnumber1    
00001A82  52B9 00008000           1002      ADD.L   #1,(input1)  
00001A88  4285                    1003      CLR.L   D5
00001A8A                          1004  
00001A8A                          1005  oddnumberchecker2
00001A8A  2C39 00008004           1006      MOVE.L  (input2),D6
00001A90  CCBC 0000000F           1007      AND.L   #$0000000F,D6
00001A96  CC3C 0001               1008      AND.B   #%0001,D6
00001A9A  BC3C 0001               1009      CMP.B   #%0001,D6
00001A9E  6700 0002               1010      BEQ     oddnumber2 
00001AA2                          1011  
00001AA2                          1012  oddnumber2
00001AA2  52B9 00008004           1013      ADD.L   #1,(input2)
00001AA8  4285                    1014      CLR.L   D5
00001AAA  4E75                    1015      RTS
00001AAC                          1016    
00001AAC                          1017         
00001AAC                          1018  
00001AAC                          1019  
00001AAC                          1020  
00001AAC                          1021  **********************************************************
00001AAC                          1022  *Subroutine: CONVERTATOH
00001AAC                          1023  *What it does: Converts user input to hex code
00001AAC                          1024  *Registers: Uses register A1, D2, D5
00001AAC                          1025  *Paramemeters: User input stored in (A1)
00001AAC                          1026  ********************************************************** 
00001AAC                          1027  CONVERTATOH:
00001AAC                          1028      
00001AAC                          1029  AtoH
00001AAC  1419                    1030      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
00001AAE                          1031      
00001AAE  B43C 0000               1032      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
00001AB2  6700 004C               1033      BEQ     Finish                  Moves to finish if they are equal (no more input)
00001AB6                          1034      
00001AB6  E985                    1035      ASL.L   #4,D5
00001AB8                          1036      
00001AB8  B43C 0030               1037      CMP.B   #$30,D2
00001ABC  6D00 0044               1038      BLT     inputError
00001AC0                          1039      
00001AC0  B43C 0039               1040      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
00001AC4  6E00 000A               1041      BGT     upperCase               Branches if greater, may or may not be a letter in hex
00001AC8                          1042      
00001AC8  0402 0030               1043      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
00001ACC  DA02                    1044      ADD.B   D2,D5
00001ACE                          1045      
00001ACE  60DC                    1046      BRA     AtoH
00001AD0                          1047  
00001AD0                          1048          
00001AD0                          1049  upperCase   
00001AD0  B43C 0041               1050      CMP.B   #$41,D2
00001AD4  6D00 002C               1051      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
00001AD8                          1052      
00001AD8  B43C 0046               1053      CMP.B   #$46,D2                 
00001ADC  6E00 000A               1054      BGT     lowerCase               Greater than 46 may be hex code in lowercase
00001AE0                          1055      
00001AE0  0402 0037               1056      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
00001AE4  DA02                    1057      ADD.B   D2,D5
00001AE6  60C4                    1058      BRA     AtoH
00001AE8                          1059  
00001AE8                          1060  lowerCase
00001AE8  B43C 0061               1061      CMP.B   #$61,D2
00001AEC  6D00 0014               1062      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001AF0                          1063      
00001AF0  B43C 0066               1064      CMP.B   #$66,D2
00001AF4  6E00 000C               1065      BGT     InputError              Greater than 66 is not part of hex code
00001AF8                          1066      
00001AF8  0402 0057               1067      SUBI.B  #$57,D2
00001AFC  DA02                    1068      ADD.B   D2,D5
00001AFE  60AC                    1069      BRA     AtoH
00001B00                          1070          
00001B00                          1071  Finish
00001B00  4E75                    1072      RTS                             Return from CONVERT
00001B02                          1073      
00001B02                          1074  inputError
00001B02  13FC 0000 00002421      1075      MOVE.B  #0,(InputQuality)
00001B0A  4E75                    1076      RTS
00001B0C                          1077  
00001B0C                          1078  *********************************************************************
00001B0C                          1079  *Subroutine: EA
00001B0C                          1080  *What it does: Outputs parts of opword, moves to new screen if needed
00001B0C                          1081  *Registers: Uses register A1, D0,
00001B0C                          1082  *A1: Used to store messages and single char
00001B0C                          1083  *Paramemeters: A1
00001B0C                          1084  *A1: Stores what should be used--++
00001B0C                          1085  *********************************************************************  
00001B0C  =0000003F               1086  BITS0TO5_MASK   EQU %00111111
00001B0C  =000000C0               1087  BITS7TO8_MASK   EQU %11000000
00001B0C  =00000E00               1088  BITS9TO11_MASK  EQU %00000111000000000
00001B0C                          1089  
00001B0C  1E3C 000A               1090  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001B10  BC7C 0000               1091                          CMP     #0,D6
00001B14  6700 0006               1092                          BEQ     IMMEDIATE0
00001B18  6000 0004               1093                          BRA     IMMEDIATE_END
00001B1C  7C08                    1094  IMMEDIATE0              MOVEQ   #8,D6
00001B1E                          1095  
00001B1E  4E75                    1096  IMMEDIATE_END           RTS
00001B20                          1097  
00001B20  3212                    1098  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001B22  0201 003F               1099                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001B26  0001 00C0               1100                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
00001B2A  1C01                    1101                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001B2C  3212                    1102                  MOVE.W  (A2),D1         
00001B2E  3412                    1103                  MOVE.W  (A2),D2 
00001B30  0241 0E00               1104                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001B34  163C 0009               1105                  MOVE.B  #9,D3                   * Prepare shift count
00001B38  E669                    1106                  LSR.W   D3,D1                   * Move destination register bits right
00001B3A  0242 01C0               1107                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001B3E  E64A                    1108                  LSR.W   #3,D2                  * Move destination mode bits right
00001B40  8242                    1109                  OR.W    D2,D1
00001B42  1A01                    1110                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001B44  1206                    1111                  MOVE.B  D6,D1               * Pass source into subroutine
00001B46  4EB9 00001D08           1112                  JSR     CHECK_VALID_EA
00001B4C  1205                    1113                  MOVE.B  D5,D1               * Pass destination into subroutine
00001B4E  4EB9 00001D08           1114                  JSR     CHECK_VALID_EA
00001B54  6100 01F6               1115                  BSR print_EA
00001B58  6100 0496               1116                  BSR print_NEWLINE
00001B5C                          1117                  
00001B5C  4E75                    1118                  RTS
00001B5E                          1119  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001B5E  3212                    1120  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001B60  3412                    1121          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001B62  0201 003F               1122          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001B66                          1123          
00001B66  0242 0E00               1124          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001B6A  163C 0009               1125          MOVE.B  #9,D3                   * Prepare shift count
00001B6E  E66A                    1126          LSR.W   D3,D2                   * Move register bits right
00001B70  0202 00C7               1127          ANDI.B  #%11000111,D2           * Set EA mode
00001B74  3612                    1128          MOVE.W  (A2),D3
00001B76  0803 0008               1129          BTST    #8,D3                   * Check opmode
00001B7A  6700 000A               1130          BEQ     EA1_MODE_ZERO           * Check opmode
00001B7E                          1131          
00001B7E  3A01                    1132  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001B80  3C02                    1133                  MOVE.W  D2,D6           * Set register as source
00001B82  6000 0006               1134                  BRA EA1_END             * Complete subroutine
00001B86                          1135          
00001B86  3C01                    1136  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001B88  3A02                    1137                  MOVE.W  D2,D5           * Set register as destination
00001B8A                          1138  
00001B8A  0006 00C0               1139  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001B8E  1206                    1140                  MOVE.B  D6,D1               * Pass source into subroutine
00001B90  4EB9 00001D08           1141                  JSR     CHECK_VALID_EA
00001B96  1205                    1142                  MOVE.B  D5,D1               * Pass destination into subroutine
00001B98  4EB9 00001D08           1143                  JSR     CHECK_VALID_EA
00001B9E  6100 01AC               1144                  BSR print_EA
00001BA2  6100 044C               1145                  BSR print_NEWLINE
00001BA6                          1146  
00001BA6  4E75                    1147                  RTS
00001BA8                          1148  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001BA8  3C12                    1149  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001BAA  0246 0E00               1150                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001BAE  163C 0009               1151                  MOVE.B  #9,D3                   * Prepare shift count
00001BB2  E66E                    1152                  LSR.W   D3,D6                   * Move register bits right
00001BB4  3612                    1153                  MOVE.W  (A2),D3
00001BB6  0803 0005               1154                  BTST    #5,D3           * Check whether shift count is immediate
00001BBA  6700 000A               1155                  BEQ     EA2_IMMEDIATE
00001BBE                          1156   
00001BBE  0006 00C0               1157  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001BC2  6000 000A               1158                  BRA     EA2_END         * Complete subroutine
00001BC6                          1159                  
00001BC6  1E3C 000A               1160  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001BCA  4EB8 1B0C               1161                  JSR     FORMAT_IMMEDIATE_DATA
00001BCE                          1162                  
00001BCE  3A12                    1163  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001BD0  CA3C 0007               1164                  AND.B   #%00000111,D5
00001BD4  1206                    1165                  MOVE.B  D6,D1               * Pass source into subroutine
00001BD6  4EB9 00001D08           1166                  JSR     CHECK_VALID_EA
00001BDC  1205                    1167                  MOVE.B  D5,D1               * Pass destination into subroutine
00001BDE  4EB9 00001D08           1168                  JSR     CHECK_VALID_EA
00001BE4  6100 0166               1169                  BSR print_EA
00001BE8  6100 0406               1170                  BSR print_NEWLINE
00001BEC  4E75                    1171                  RTS   
00001BEE                          1172  
00001BEE                          1173  
00001BEE                          1174  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001BEE  3C12                    1175  EA_GROUP3     MOVE.W  (A2),D6
00001BF0  0206 003F               1176          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001BF4  0006 0080               1177          ORI.B   #%10000000,D6
00001BF8  1206                    1178          MOVE.B  D6,D1               * Pass source into subroutine
00001BFA  4EB9 00001D08           1179          JSR     CHECK_VALID_EA
00001C00  6100 014A               1180          BSR print_EA
00001C04  6100 03EA               1181          BSR print_NEWLINE
00001C08  4E75                    1182          RTS
00001C0A                          1183  
00001C0A                          1184  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001C0A  3212                    1185  EA_GROUP4     MOVE.W  (A2),D1         
00001C0C  0201 003F               1186          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001C10  0001 00C0               1187          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001C14  1C01                    1188          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001C16  3212                    1189          MOVE.W  (A2),D1         
00001C18                          1190          
00001C18  0241 0E00               1191          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001C1C  143C 0009               1192          MOVE.B  #9,D2                   * Prepare shift count
00001C20  E469                    1193          LSR.W   D2,D1                   * Move register bits right
00001C22  0201 00CF               1194          ANDI.B  #%11001111,D1           * Set destination mode
00001C26  0001 0008               1195          ORI.B   #%00001000,D1           * Set destination mode
00001C2A  1A01                    1196          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001C2C  1206                    1197          MOVE.B  D6,D1               * Pass source into subroutine
00001C2E  4EB9 00001D08           1198          JSR     CHECK_VALID_EA
00001C34  1205                    1199          MOVE.B  D5,D1               * Pass destination into subroutine
00001C36  4EB9 00001D08           1200          JSR     CHECK_VALID_EA
00001C3C  6100 010E               1201          BSR print_EA
00001C40  6100 03AE               1202          BSR print_NEWLINE
00001C44  4E75                    1203          RTS
00001C46                          1204          
00001C46  3C12                    1205  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001C48  0246 0E00               1206          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001C4C  163C 0009               1207          MOVE.B  #9,D3                   * Prepare shift count
00001C50  E66E                    1208          LSR.W   D3,D6                  * Move source data bits right            !---
00001C52  3A12                    1209          MOVE.W  (A2),D5                 * Prepare destination bits
00001C54  0205 003F               1210          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001C58  4EB8 1B0C               1211          JSR     FORMAT_IMMEDIATE_DATA
00001C5C  1206                    1212          MOVE.B  D6,D1               * Pass source into subroutine
00001C5E  4EB9 00001D08           1213          JSR     CHECK_VALID_EA
00001C64  1205                    1214          MOVE.B  D5,D1               * Pass destination into subroutine
00001C66  4EB9 00001D08           1215          JSR     CHECK_VALID_EA
00001C6C  4E75                    1216          RTS                                    !---
00001C6E                          1217          
00001C6E  3C12                    1218  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001C70  CC7C 00FF               1219              AND.W   #$00FF,D6                                                   !---
00001C74  3A12                    1220              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001C76  0245 0E00               1221              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001C7A  163C 0009               1222              MOVE.B  #9,D3                   * Prepare shift count
00001C7E  E66D                    1223              LSR.W   D3,D5                   * Move destination register bits right
00001C80  1E3C 000A               1224              MOVE.B  #10,D7
00001C84  1206                    1225              MOVE.B  D6,D1               * Pass source into subroutine
00001C86  4EB9 00001D08           1226              JSR     CHECK_VALID_EA
00001C8C  1205                    1227              MOVE.B  D5,D1               * Pass destination into subroutine
00001C8E  4EB9 00001D08           1228              JSR     CHECK_VALID_EA
00001C94  4E75                    1229              RTS                                 !---
00001C96                          1230  
00001C96                          1231  
00001C96                          1232  
00001C96                          1233  
00001C96  3412                    1234  MOVEM_EA   MOVE.W (A2),D2
00001C98  0802 000A               1235             BTST    #10, D2
00001C9C  6700 003E               1236             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001CA0                          1237            
00001CA0                          1238             
00001CA0                          1239                  
00001CA0                          1240  *ELSE IT IS  memory-to-register transfers
00001CA0                          1241  
00001CA0                          1242  
00001CA0                          1243  
00001CA0                          1244  
00001CA0                          1245     
00001CA0  E68A                    1246  Memory_to_Register LSR.L #3, D2
00001CA2  C43C 0007               1247                     AND.B #$07, D2
00001CA6  B43C 0002               1248                     CMP.B #$2,D2
00001CAA  6700 0022               1249                     BEQ   MODE_010
00001CAE  B43C 0003               1250                     CMP.B #$03, D2
00001CB2  6700 001A               1251                     BEQ   MODE_010  
00001CB6  B43C 0007               1252                     CMP.B #$07,D2
00001CBA  6700 0012               1253                     BEQ   MODE_010  
00001CBE  4EF9 00001CC4           1254                     JMP   WRONG_INSTRUCTION    
00001CC4                          1255     
00001CC4  1E3C 0005               1256  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001CC8  2C4A                    1257                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001CCA  3C12                    1258                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001CCC  4E75                    1259                               RTS 
00001CCE                          1260             
00001CCE  3412                    1261  MODE_010  MOVE.W    (A2),D2
00001CD0  C43C 003F               1262            AND.B     #$3F,D2
00001CD4  08C2 0007               1263            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001CD8  1C02                    1264            MOVE.B    D2,D6
00001CDA  4E75                    1265            RTS
00001CDC                          1266  
00001CDC  3412                    1267  Register_to_memory MOVE.W (A2),D2
00001CDE  E68A                    1268                     LSR.L #3, D2
00001CE0  C43C 0007               1269                     AND.B #$07, D2
00001CE4  B43C 0002               1270                     CMP.B #$2,D2
00001CE8  6700 0016               1271                     BEQ   MODE_01_0
00001CEC  B43C 0004               1272                     CMP.B #$04, D2
00001CF0  6700 000E               1273                     BEQ   MODE_01_0 
00001CF4  B43C 0007               1274                     CMP.B #$07,D2
00001CF8  6700 0006               1275                     BEQ   MODE_01_0 
00001CFC  4EF8 1CC4               1276                     JMP   WRONG_INSTRUCTION
00001D00                          1277                     
00001D00                          1278  
00001D00  3C12                    1279  MODE_01_0       MOVE.W  (A2),D6
00001D02  0206 003F               1280                  ANDI.B  #$3F,D6
00001D06  4E75                    1281                  RTS
00001D08                          1282           
00001D08  1001                    1283  CHECK_VALID_EA  MOVE.B  D1,D0
00001D0A  0200 0038               1284                  ANDI.B  #%111000,D0
00001D0E  E648                    1285                  LSR     #3,D0
00001D10  B03C 0005               1286                  CMP.B   #%00000101,D0
00001D14  6700 002C               1287                  BEQ     INVALID_EA
00001D18  B03C 0006               1288                  CMP.B   #%00000110,D0
00001D1C  6700 0024               1289                  BEQ     INVALID_EA
00001D20  B03C 0007               1290                  CMP.B   #%00000111,D0
00001D24  6700 0004               1291                  BEQ     VALID_EA_PC
00001D28  4E75                    1292                  RTS
00001D2A                          1293                  
00001D2A                          1294                  
00001D2A  1001                    1295  VALID_EA_PC     MOVE.B  D1,D0
00001D2C  0200 0007               1296                  ANDI.B  #%000111,D0
00001D30  B03C 0010               1297                  CMP.B   #%00010000,D0
00001D34  6700 000C               1298                  BEQ     INVALID_EA
00001D38  B03C 0018               1299                  CMP.B   #%00011000,D0
00001D3C  6700 0004               1300                  BEQ     INVALID_EA
00001D40  4E75                    1301                  RTS
00001D42                          1302                  
00001D42  4EB8 1CC4               1303  INVALID_EA      JSR     WRONG_INSTRUCTION
00001D46  3A7C 0005               1304                  MOVE.W  #5, A5
00001D4A  4E75                    1305                  RTS
00001D4C                          1306                  
00001D4C  48E7 FFDE               1307  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001D50  163C 0038               1308                  MOVE.B  #$38,D3
00001D54  C604                    1309                  AND.B   D4,D3
00001D56  C83C 0007               1310                  AND.B   #$7, D4
00001D5A                          1311                  
00001D5A  B63C 0000               1312                  CMP.B   #$0, D3
00001D5E  6600 0014               1313                  BNE     CHECK_EA_AR
00001D62  0604 00D0               1314                  ADD.B   #$D0, D4
00001D66  4281                    1315                  CLR.L   D1
00001D68  1204                    1316                  MOVE.B  D4, D1
00001D6A  4EB9 00001F16           1317                  JSR     PRINT_REGISTOR              * DATA REG
00001D70  6000 0114               1318                  BRA     PRINT_EA_RETURN
00001D74                          1319  
00001D74  B63C 0008               1320  CHECK_EA_AR         CMP.B   #$8, D3
00001D78  6600 0014               1321                      BNE     CHECK_EA_INDIRECT
00001D7C  0604 00A0               1322                      ADD.B   #$A0, D4
00001D80  4281                    1323                      CLR.L   D1
00001D82  1204                    1324                      MOVE.B  D4, D1
00001D84  4EB9 00001F16           1325                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001D8A  6000 00FA               1326                      BRA     PRINT_EA_RETURN
00001D8E                          1327                      
00001D8E  B63C 0010               1328  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001D92  6600 0020               1329                          BNE     CHECK_EA_POST
00001D96  4EB9 00001F6A           1330                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001D9C  0604 00A0               1331                          ADD.B   #$A0, D4
00001DA0  4281                    1332                          CLR.L   D1
00001DA2  1204                    1333                          MOVE.B  D4, D1
00001DA4  4EB9 00001F16           1334                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001DAA  4EB9 00001F7E           1335                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001DB0  6000 00D4               1336                          BRA     PRINT_EA_RETURN
00001DB4                          1337                          
00001DB4  B63C 0018               1338  CHECK_EA_POST   CMP.B   #$18,D3
00001DB8  6600 0026               1339                  BNE     CHECK_EA_PRE
00001DBC  4EB9 00001F6A           1340                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001DC2  0604 00A0               1341                  ADD.B   #$A0, D4
00001DC6  4281                    1342                  CLR.L   D1
00001DC8  1204                    1343                  MOVE.B  D4, D1
00001DCA  4EB9 00001F16           1344                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001DD0  4EB9 00001F7E           1345                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001DD6  4EB9 00001F96           1346                  JSR     PRINT_PLUS                  * +
00001DDC  6000 00A8               1347                  BRA     PRINT_EA_RETURN
00001DE0                          1348  
00001DE0  B63C 0020               1349  CHECK_EA_PRE        CMP.B   #$20,D3
00001DE4  6600 0026               1350                      BNE     CHECK_EA_AB_W
00001DE8  4EB9 00001FAA           1351                      JSR     PRINT_MINUS                 * -
00001DEE  4EB9 00001F6A           1352                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001DF4  0604 00A0               1353                      ADD.B   #$A0, D4
00001DF8  4281                    1354                      CLR.L   D1
00001DFA  1204                    1355                      MOVE.B  D4, D1
00001DFC  4EB9 00001F16           1356                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001E02  4EB9 00001F7E           1357                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001E08  6000 007C               1358                      BRA     PRINT_EA_RETURN
00001E0C                          1359  
00001E0C  D604                    1360  CHECK_EA_AB_W           ADD.B   D4,D3
00001E0E  B63C 0038               1361                          CMP.B   #$38,D3     
00001E12  6600 0018               1362                          BNE     CHECK_EA_AB_L
00001E16  4EB9 00002018           1363                          JSR     PRINT_DOLLAR        * $
00001E1C  3A1A                    1364                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001E1E  163C 0002               1365                          MOVE.B  #2,D3
00001E22  4EB9 00001EAE           1366                          JSR     PRINT_HEX
00001E28  6000 005C               1367                          BRA     PRINT_EA_RETURN
00001E2C                          1368                          
00001E2C  B63C 0039               1369  CHECK_EA_AB_L       CMP.B   #$39, D3
00001E30  6600 0018               1370                      BNE     CHECK_EA_IMM
00001E34  4EB9 00002018           1371                      JSR     PRINT_DOLLAR        * $
00001E3A  2A1A                    1372                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001E3C  163C 0004               1373                      MOVE.B  #4,D3
00001E40  4EB9 00001EAE           1374                      JSR     PRINT_HEX
00001E46  6000 003E               1375                      BRA     PRINT_EA_RETURN
00001E4A                          1376                      
00001E4A  BE3C 0004               1377  CHECK_EA_IMM        CMP.B   #4,D7
00001E4E  6600 001E               1378                      BNE     READ_WORD_IMM
00001E52  4EB9 00002004           1379                      JSR     PRINT_HASH_SIGN     * #
00001E58  4EB9 00002018           1380                      JSR     PRINT_DOLLAR        * $
00001E5E  2A1A                    1381                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001E60  163C 0004               1382                      MOVE.B  #4,D3
00001E64  4EB9 00001EAE           1383                      JSR     PRINT_HEX
00001E6A  6000 001A               1384                      BRA     PRINT_EA_RETURN
00001E6E                          1385                      
00001E6E  4EB9 00002004           1386  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001E74  4EB9 00002018           1387                      JSR     PRINT_DOLLAR        * $
00001E7A  3A1A                    1388                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001E7C  163C 0002               1389                      MOVE.B  #2,D3
00001E80  4EB9 00001EAE           1390                      JSR     PRINT_HEX
00001E86                          1391  
00001E86  4CDF 7BFF               1392  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001E8A  4E75                    1393                      RTS
00001E8C                          1394  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001E8C                          1395  PRINT_BUFFER    DS.B    10
00001E96= 30 30 30 30 30 30 ...   1396  IPUT_BUFFER_EX  DC.B    '00000000'
00001E9E                          1397  INPUT_BUFFER    DS.B    15                    
00001EAE  48E7 FFFE               1398  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001EB2  43F8 1E8C               1399                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001EB6  D3FC 0000000A           1400                  ADD.L       #10,A1
00001EBC  133C 0000               1401                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001EC0  6000 000E               1402                  BRA         POPULATE_BUFFER
00001EC4                          1403                  
00001EC4  103C 000E               1404  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001EC8  4E4F                    1405                      TRAP        #15
00001ECA  4CDF 7FFF               1406                      MOVEM.L     (SP)+,ALL_REG
00001ECE  4E75                    1407                      RTS
00001ED0                          1408                 
00001ED0  B63C 0000               1409  POPULATE_BUFFER     CMP.B       #0,D3
00001ED4  67EE                    1410                      BEQ         PRINT_HEX_RETURN
00001ED6  183C 000F               1411                      MOVE.B      #$0F,D4
00001EDA  C805                    1412                      AND.B       D5,D4
00001EDC  E81D                    1413                      ROR.B       #4,D5
00001EDE  4EB9 00001EFA           1414                      JSR         HEX_TO_ASCII
00001EE4  1304                    1415                      MOVE.B      D4,-(A1)
00001EE6  1805                    1416                      MOVE.B      D5,D4
00001EE8  C83C 000F               1417                      AND.B       #$0F,D4
00001EEC  4EB9 00001EFA           1418                      JSR         HEX_TO_ASCII
00001EF2  1304                    1419                      MOVE.B      D4,-(A1)
00001EF4  E08D                    1420                      LSR.L       #8,D5
00001EF6  5303                    1421                      SUB.B       #1,D3
00001EF8  60D6                    1422                      BRA         POPULATE_BUFFER
00001EFA                          1423  
00001EFA  48E7 E7FE               1424  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001EFE  B83C 0009               1425                          CMP.B       #9,D4
00001F02  6F00 000C               1426                          BLE         NUMBER_TO_ASCII
00001F06  0604 0037               1427                          ADD.B       #$37,D4
00001F0A  4CDF 7FE7               1428  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001F0E  4E75                    1429                          RTS
00001F10                          1430                  
00001F10  0604 0030               1431  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001F14  60F4                    1432                      BRA     HEX_TO_ASCII_RETURN                    
00001F16                          1433                      
00001F16  48E7 FFFE               1434  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001F1A  3F3C 0000               1435                      MOVE.W      #00,-(SP)           *for printing purpose
00001F1E  343C 00F0               1436                      MOVE.W      #$f0,D2             *manipulating each digit
00001F22  C441                    1437                      AND.W       D1,D2
00001F24  E842                    1438                      ASR.W       #4,D2
00001F26  4EB9 00001F4C           1439                      JSR         TO_STRING           * converts to the string ASCII val
00001F2C  E142                    1440                      ASL.W       #8,D2
00001F2E                          1441                      
00001F2E  C27C 000F               1442                      AND.W       #$F,D1              * the last digit
00001F32  1401                    1443                      MOVE.B      D1,D2               
00001F34  4EB9 00001F4C           1444                      JSR         TO_STRING
00001F3A  3F02                    1445                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001F3C                          1446                      
00001F3C  224F                    1447                      MOVE.L      SP,A1               * printing
00001F3E  103C 000E               1448                      MOVE.B      #14,D0
00001F42  4E4F                    1449                      TRAP        #15
00001F44  2A1F                    1450                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001F46                          1451  
00001F46  4CDF 7FFF               1452  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001F4A  4E75                    1453                                  RTS
00001F4C                          1454                                  
00001F4C  B43C 0009               1455  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001F50  6E00 0008               1456              BGT     LETTERS     
00001F54  0602 0030               1457              ADD.B   #$30,D2             * offseting digit
00001F58  4E75                    1458              RTS
00001F5A  0602 0037               1459  LETTERS     ADD.B   #$37,D2             * offseting leter
00001F5E  4E75                    1460              RTS   
00001F60                          1461  
00001F60                          1462  *________________________________________________________________________________________
00001F60                          1463  
00001F60                          1464  
00001F60                          1465  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001F60                          1466          *PARAMENTER     NO PARAMETER NEEDED
00001F60= 28 00                   1467  OPEN_PAR_TAG        DC.B    '(',0  
00001F62= 29 00                   1468  CLOSED_PAR_TAG      DC.B    ')',0
00001F64= 23 00                   1469  HASH_SIGN_TAG       DC.B    '#',0
00001F66= 24 00                   1470  DOLLAR_TAG          DC.B    '$',0
00001F68= 2F 00                   1471  FORWARD_SLASH_TAG   DC.B    '/',0      
00001F6A  48E7 FFFE               1472  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001F6E  43F8 1F60               1473                          LEA         OPEN_PAR_TAG, A1
00001F72  103C 000E               1474                          MOVE.B      #14,D0
00001F76  4E4F                    1475                          TRAP        #15
00001F78  4CDF 7FFF               1476                          MOVEM.L     (SP)+,ALL_REG
00001F7C  4E75                    1477                          RTS
00001F7E                          1478  *_________________________________________________________________________________
00001F7E                          1479  
00001F7E                          1480  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001F7E                          1481          *PARAMENTER     NO PARAMETER NEEDED
00001F7E                          1482          
00001F7E  48E7 FFFE               1483  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001F82  43F8 1F62               1484                              LEA         CLOSED_PAR_TAG, A1
00001F86  103C 000E               1485                              MOVE.B      #14,D0
00001F8A  4E4F                    1486                              TRAP        #15
00001F8C  4CDF 7FFF               1487                              MOVEM.L     (SP)+,ALL_REG
00001F90  4E75                    1488                              RTS
00001F92                          1489  *__________________________________________________________________________________
00001F92                          1490  
00001F92                          1491  *________________ PRINT PLUS SIGN _________________________________________________
00001F92                          1492          *PARAMENTER     NO PARAMETER NEEDED
00001F92= 2B 00                   1493  PLUS_TAG            DC.B    '+',0
00001F94= 2D 00                   1494  MINUS_TAG           DC.B    '-',0        
00001F96  48E7 FFFE               1495  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001F9A  43F8 1F92               1496                  LEA         PLUS_TAG, A1
00001F9E  103C 000E               1497                  MOVE.B      #14,D0
00001FA2  4E4F                    1498                  TRAP        #15
00001FA4  4CDF 7FFF               1499                  MOVEM.L     (SP)+,ALL_REG
00001FA8  4E75                    1500                  RTS
00001FAA                          1501  *_________________________________________________________________________________
00001FAA                          1502  
00001FAA                          1503  *________________ PRINT MINUS SIGN _______________________________________________
00001FAA                          1504          *PARAMENTER     NO PARAMETER NEEDED
00001FAA                          1505          
00001FAA  48E7 FFFE               1506  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001FAE  43F8 1F94               1507                      LEA         MINUS_TAG, A1
00001FB2  103C 000E               1508                      MOVE.B      #14,D0
00001FB6  4E4F                    1509                      TRAP        #15
00001FB8  4CDF 7FFF               1510                      MOVEM.L     (SP)+,ALL_REG
00001FBC  4E75                    1511                      RTS
00001FBE                          1512  *_________________________________________________________________________________
00001FBE                          1513  
00001FBE                          1514  *________________ PRINT COMMA ____________________________________________________
00001FBE                          1515          *PARAMENTER     NO PARAMETER NEEDED
00001FBE= 09 00                   1516  TAB_TAG         DC.B    $9,0
00001FC0= 20 00                   1517  SPACE_TAG       DC.B    ' ',0
00001FC2= 2C 00                   1518  COMMA_TAG       DC.B    ',',0        
00001FC4  48E7 FFFE               1519  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001FC8  43F8 1FC2               1520                      LEA         COMMA_TAG, A1
00001FCC  103C 000E               1521                      MOVE.B      #14,D0
00001FD0  4E4F                    1522                      TRAP        #15
00001FD2  4CDF 7FFF               1523                      MOVEM.L     (SP)+,ALL_REG
00001FD6  4E75                    1524                      RTS
00001FD8                          1525  *_________________________________________________________________________________
00001FD8                          1526  
00001FD8                          1527  *________________ PRINT TAB ______________________________________________________
00001FD8                          1528          *PARAMENTER     NO PARAMETER NEEDED
00001FD8                          1529          
00001FD8  48E7 FFFE               1530  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001FDC  43F8 1FBE               1531                  LEA         TAB_TAG, A1
00001FE0  103C 000E               1532                  MOVE.B      #14,D0
00001FE4  4E4F                    1533                  TRAP        #15
00001FE6  4CDF 7FFF               1534                  MOVEM.L     (SP)+,ALL_REG
00001FEA  4E75                    1535                  RTS
00001FEC                          1536  *_________________________________________________________________________________
00001FEC                          1537  
00001FEC                          1538  
00001FEC                          1539  *_______________    PRINT NEWLINE   ________________________________________________
00001FEC                          1540          *PARAMETER NO PARAMETER NEEDED
00001FEC= 0D 0A 00                1541  NEWLINE_TAG         DC.B    CR,LF,0        
00001FF0  48E7 FFFE               1542  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001FF4  43F8 1FEC               1543                      LEA         NEWLINE_TAG, A1
00001FF8  103C 000E               1544                      MOVE.B      #14,D0
00001FFC  4E4F                    1545                      TRAP        #15
00001FFE  4CDF 7FFF               1546                      MOVEM.L     (SP)+,ALL_REG
00002002  4E75                    1547                      RTS
00002004                          1548  
00002004                          1549  *___________________________________________________________________________________
00002004                          1550  
00002004                          1551  
00002004                          1552  *_______________    PRINT HASH SIGN   ________________________________________________
00002004                          1553          *PARAMETER NO PARAMETER NEEDED
00002004                          1554          
00002004  48E7 FFFE               1555  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00002008  43F8 1F64               1556                      LEA         HASH_SIGN_TAG, A1
0000200C  103C 000E               1557                      MOVE.B      #14,D0
00002010  4E4F                    1558                      TRAP        #15
00002012  4CDF 7FFF               1559                      MOVEM.L     (SP)+,ALL_REG
00002016  4E75                    1560                      RTS
00002018                          1561  
00002018                          1562  *___________________________________________________________________________________
00002018                          1563  
00002018                          1564  
00002018                          1565  
00002018                          1566  *_______________    PRINT DOLLAR   ________________________________________________
00002018                          1567          *PARAMETER NO PARAMETER NEEDED
00002018                          1568          
00002018  48E7 FFFE               1569  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
0000201C  43F8 1F66               1570                      LEA         DOLLAR_TAG, A1
00002020  103C 000E               1571                      MOVE.B      #14,D0
00002024  4E4F                    1572                      TRAP        #15
00002026  4CDF 7FFF               1573                      MOVEM.L     (SP)+,ALL_REG
0000202A  4E75                    1574                      RTS
0000202C                          1575  
0000202C                          1576  *___________________________________________________________________________________
0000202C                          1577  
0000202C                          1578  
0000202C                          1579  
0000202C                          1580  *_______________    PRINT FORWARD SLASH   ________________________________________________
0000202C                          1581          *PARAMETER NO PARAMETER NEEDED
0000202C                          1582          
0000202C  48E7 FFFE               1583  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00002030  43F8 1F68               1584                          LEA         FORWARD_SLASH_TAG, A1
00002034  103C 000E               1585                          MOVE.B      #14,D0
00002038  4E4F                    1586                          TRAP        #15
0000203A  4CDF 7FFF               1587                          MOVEM.L     (SP)+,ALL_REG
0000203E  4E75                    1588                          RTS
00002040                          1589  
00002040                          1590  
00002040                          1591     
00002040                          1592  *********************************************************************
00002040                          1593  *Subroutine: OUTPUT
00002040                          1594  *What it does: Outputs parts of opword, moves to new screen if needed
00002040                          1595  *Registers: Uses register A1, D0,
00002040                          1596  *A1: Used to store messages and single char
00002040                          1597  *Paramemeters: A1, A2
00002040                          1598  *A1: Stores what should be used
00002040                          1599  *********************************************************************  
00002040                          1600  
00002040                          1601       OUTPUT:
00002040                          1602       
00002040  0C39 0001 00002423      1603       CMP.B  #1,(OutputType)
00002048  6700 0026               1604       BEQ    outputOpcode
0000204C  0C39 0002 00002423      1605       CMP.B  #2,(OutputType)
00002054  6700 0066               1606       BEQ    OutputSize
00002058  0C39 0003 00002423      1607       CMP.B  #3,(OutputType)
00002060  6700 0062               1608       BEQ    OutputData
00002064  0C39 0004 00002423      1609       CMP.B  #4,(OutputType)
0000206C  6700 00AC               1610       BEQ    OutputAddress
00002070                          1611       
00002070                          1612  outputOpcode    
00002070  0C39 001E 00002422      1613       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00002078  6C00 0010               1614       BGE    outputOpcodeNewScreen
0000207C                          1615       
0000207C  103C 000E               1616       MOVE.B #14,D0
00002080  4E4F                    1617       TRAP   #15
00002082                          1618       
00002082  5239 00002422           1619       ADD.B  #1,(LineCounter)
00002088                          1620       
00002088  4E75                    1621       RTS
0000208A                          1622       
0000208A                          1623       
0000208A                          1624  outputOpcodeNewScreen
0000208A  2F09                    1625       MOVE.L A1,-(SP)                Storing last message to be used later
0000208C                          1626       
0000208C  43F9 000023F8           1627       LEA    OUTPUTNEWSCREEN,A1         
00002092  103C 000E               1628       MOVE.B #14,D0
00002096  4E4F                    1629       TRAP   #15
00002098                          1630       
00002098  43F9 00008008           1631       LEA    userInputStored,A1         Pauses program to show screen full of data
0000209E  103C 0002               1632       MOVE.B #2,D0
000020A2  4E4F                    1633       TRAP   #15
000020A4                          1634       
000020A4  13FC 0000 00002422      1635       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
000020AC                          1636       
000020AC  225F                    1637       MOVE.L (SP)+,A1                Retriving message to be used
000020AE                          1638       
000020AE  103C 000E               1639       MOVE.B #14,D0                  Outputting decoded message
000020B2  4E4F                    1640       TRAP   #15
000020B4                          1641       
000020B4  5239 00002422           1642       ADD.B  #1,(LineCounter)        Add to line counter for new screen
000020BA                          1643       
000020BA  4E75                    1644       RTS
000020BC                          1645       
000020BC                          1646  outputSize
000020BC  103C 000E               1647      MOVE.B  #14,D0
000020C0  4E4F                    1648      TRAP    #15
000020C2  4E75                    1649      RTS
000020C4                          1650  outputData
000020C4  267C 00000800           1651      MOVE.L   #$800,A3
000020CA  3692                    1652      MOVE.W  (A2),(A3)
000020CC  2F06                    1653      MOVE.L  D6,-(SP)
000020CE  103C 0000               1654      MOVE.B  #0,D0
000020D2  43F9 00009005           1655      LEA     addressOutput,A1
000020D8                          1656  
000020D8                          1657  outputDataLoop
000020D8                          1658  *check if loop has run 4 times
000020D8  B03C 0002               1659      CMP.B   #2,D0
000020DC  6700 001C               1660      BEQ     outputDataLoopEnd
000020E0                          1661      *Grab byte from address, dont increment
000020E0  1C13                    1662      MOVE.B  (A3),D6
000020E2                          1663      *LSR to isolate left bit
000020E2  E80E                    1664      LSR.B   #4,D6
000020E4                          1665      *Call converthtoa
000020E4  6100 008A               1666      BSR     CONVERTHTOA
000020E8  12C6                    1667      MOVE.B  D6,(A1)+   
000020EA                          1668      *Grab bye from address, increment
000020EA  1C1B                    1669      MOVE.B  (A3)+,D6
000020EC                          1670      *AND Mask second digit
000020EC  CC3C 000F               1671      AND.B   #$0F,D6
000020F0  6100 007E               1672      BSR     CONVERTHTOA
000020F4  12C6                    1673      MOVE.B  D6,(A1)+
000020F6  5200                    1674      ADD.B   #1,D0
000020F8  60DE                    1675      BRA     outputDataLoop
000020FA                          1676      
000020FA                          1677  outputDataLoopEnd
000020FA  12BC 0000               1678      MOVE.B  #$00,(A1)
000020FE  2C1F                    1679      MOVE.L  (SP)+,D6
00002100  43F9 00009005           1680      LEA     addressOutput,A1
00002106  103C 000E               1681      MOVE.B  #14,D0
0000210A  4E4F                    1682      TRAP    #15
0000210C                          1683      
0000210C  43F9 0000241B           1684      LEA     NEWLINE,A1
00002112  103C 000E               1685      MOVE.B  #14,D0
00002116  4E4F                    1686      TRAP    #15
00002118                          1687  
00002118  4E75                    1688      RTS
0000211A                          1689   
0000211A                          1690      
0000211A                          1691  outputAddress
0000211A  267C 00000800           1692      MOVE.L  #$800,A3
00002120  268A                    1693      MOVE.L  A2,(A3)
00002122  2F06                    1694      MOVE.L  D6,-(SP)
00002124  103C 0000               1695      MOVE.B  #0,D0
00002128  43F9 00009005           1696      LEA     addressOutput,A1
0000212E                          1697  outputAddressLoop
0000212E                          1698      *check if loop has run 4 times
0000212E  B03C 0004               1699      CMP.B   #4,D0
00002132  6700 001C               1700      BEQ     outputAddressLoopEnd
00002136                          1701      *Grab byte from address, dont increment
00002136  1C13                    1702      MOVE.B  (A3),D6
00002138                          1703      *LSR to isolate left bit
00002138  E80E                    1704      LSR.B   #4,D6
0000213A                          1705      *Call converthtoa
0000213A  6100 0034               1706      BSR     CONVERTHTOA
0000213E  12C6                    1707      MOVE.B  D6,(A1)+   
00002140                          1708      *Grab bye from address, increment
00002140  1C1B                    1709      MOVE.B  (A3)+,D6
00002142                          1710      *AND Mask second digit
00002142  CC3C 000F               1711      AND.B   #$0F,D6
00002146  6100 0028               1712      BSR     CONVERTHTOA
0000214A  12C6                    1713      MOVE.B  D6,(A1)+
0000214C  5200                    1714      ADD.B   #1,D0
0000214E  60DE                    1715      BRA     outputAddressLoop
00002150                          1716      
00002150                          1717      
00002150                          1718  outputAddressLoopEnd
00002150  12BC 0000               1719      MOVE.B  #$00,(A1)
00002154  2C1F                    1720      MOVE.L  (SP)+,D6
00002156  43F9 00009005           1721      LEA     addressOutput,A1
0000215C                          1722      
0000215C  103C 000E               1723      MOVE.B  #14,D0
00002160  4E4F                    1724      TRAP    #15
00002162                          1725      
00002162  43F9 0000241E           1726      LEA     spaces,A1
00002168  103C 000E               1727      MOVE.B  #14,D0
0000216C  4E4F                    1728      TRAP    #15
0000216E                          1729  
0000216E                          1730  
0000216E  4E75                    1731      RTS
00002170                          1732  
00002170                          1733  *********************************************************************
00002170                          1734  *Subroutine: CONVERTHTOA
00002170                          1735  *What it does: Converts HEX to ASCII
00002170                          1736  *Registers: Uses register D6,D0
00002170                          1737  *D6: Stores hex character to be converted
00002170                          1738  *Paramemeters: D6
00002170                          1739  *D6: Stores hex characcter to be converted
00002170                          1740  *********************************************************************
00002170                          1741      CONVERTHTOA:
00002170                          1742      
00002170  BC3C 0009               1743      CMP.B   #9,D6
00002174  6F00 0006               1744      BLE     zerotonine
00002178  6000 000A               1745      BRA     AtoF
0000217C                          1746      
0000217C                          1747  zerotonine    
0000217C  0686 00000030           1748      ADD.L   #$30,D6
00002182  4E75                    1749      RTS
00002184                          1750  AtoF
00002184  0686 00000037           1751      ADD.L   #$37,D6
0000218A  4E75                    1752      RTS
0000218C                          1753      
0000218C                          1754  END_SIMULATION:
0000218C                          1755          
0000218C  103C 0009               1756      MOVE.B  #9,D0
00002190  4E4F                    1757      TRAP    #15
00002192                          1758  
00002192  FFFF FFFF               1759      SIMHALT             ; halt simulator
00002196                          1760  
00002196                          1761  * Put variables and constants here
00002196= 57 65 6C 63 6F 6D ...   1762  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
000021BC= 53 6F 6D 65 20 71 ...   1763                  DC.B    'Some quick rules:',CR,LF
000021CF= 31 29 20 4F 6E 6C ...   1764                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
0000220B= 32 29 20 54 68 65 ...   1765                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
00002256= 33 29 20 41 6E 79 ...   1766                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
0000229A= 20 20 20 77 69 6C ...   1767                  DC.B    '   will be rejected',CR,LF
000022AF= 34 29 20 54 68 65 ...   1768                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
000022F2= 20 20 20 77 69 6C ...   1769                  DC.B    '   will be rejected',CR,LF,0      
00002308= 50 6C 65 61 73 65 ...   1770  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
0000232E= 50 6C 65 61 73 65 ...   1771  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
00002354                          1772  
00002354= 0D 0A 54 68 69 73 ...   1773  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
00002372= 0D 0A 49 6E 70 75 ...   1774  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
000023AE                          1775  
000023AE= 54 6F 20 72 65 70 ...   1776  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
000023F8                          1777  
000023F8= 50 6C 65 61 73 65 ...   1778  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
0000241B                          1779  
0000241B= 0D 0A 00                1780  NEWLINE     DC.B    CR,LF,0
0000241E= 20 20 00                1781  SPACES      DC.B    '  ',0
00002421                          1782  
00002421= 01                      1783  InputQuality    DC.B    1       Set to 1 for default good
00002422= 00                      1784  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
00002423= 00                      1785  OutputType      DC.B    0      To track what type is being output
00002424= 00                      1786  RepeatFlag      DC.B    0
00002425                          1787  
00002425= 4E 4F 50 0D 0A 00       1788  nopout  DC.B    'NOP',CR,LF,0
0000242B= 4D 4F 56 45 00          1789  moveout  DC.B    'MOVE',0
00002430= 4D 4F 56 45 41 00       1790  moveaout DC.B      'MOVEA',0
00002436= 4D 4F 56 45 51 00       1791  moveqout DC.B   'MOVEQ',0
0000243C= 4D 4F 56 45 4D 00       1792  movemout DC.B   'MOVEM',0
00002442                          1793  
00002442= 53 55 42 00             1794  subout    DC.B  'SUB',0
00002446= 41 44 44 00             1795  addout    DC.B 'ADD',0
0000244A= 41 44 44 41 00          1796  addaout    DC.B 'ADDA',0
0000244F= 41 44 44 51 00          1797  addqout    DC.B 'ADDQ',0
00002454                          1798  
00002454= 4C 45 41 20 20 20 ...   1799  leaout    DC.B  'LEA    ',0
0000245C                          1800  
0000245C= 4E 4F 54 00             1801  notout    DC.B  'NOT',0
00002460= 4F 52 00                1802  orout DC.B     'OR',0
00002463= 41 4E 44 00             1803  andout DC.B     'AND',0
00002467                          1804  
00002467                          1805  
00002467= 4C 53 4C 00             1806  lslout    DC.B  'LSL',0
0000246B= 4C 53 52 00             1807  lsrout    DC.B  'LSR',0
0000246F= 41 53 4C 00             1808  aslout    DC.B  'ASL',0
00002473= 41 53 52 00             1809  asrout    DC.B  'ASR',0
00002477                          1810  
00002477= 52 4F 4C 00             1811  rolout    DC.B  'ROL',0
0000247B= 52 4F 52 00             1812  rorout    DC.B  'ROR',0
0000247F                          1813  
0000247F= 42 47 54 00             1814  bgtout DC.B     'BGT',0
00002483= 42 4C 45 00             1815  bleout DC.B     'BLE',0
00002487= 42 45 51 00             1816  beqout DC.B     'BEQ',0
0000248B                          1817  
0000248B= 4A 53 52 00             1818  jsrout DC.B     'JSR',0
0000248F= 52 54 53 0D 0A 00       1819  rtsout DC.B     'RTS',CR,LF,0
00002495= 42 52 41 00             1820  braout DC.B     'BRA',0
00002499                          1821  
00002499= 44 41 54 41 20 20 ...   1822  dataout DC.B    'DATA   ',0
000024A1                          1823  
000024A1                          1824  
000024A1                          1825  
000024A1= 2E 42 20 20 20 20 00    1826  byteout  DC.B    '.B    ',0
000024A8= 2E 57 20 20 20 20 00    1827  wordout  DC.B    '.W    ',0
000024AF= 2E 4C 20 20 20 20 00    1828  longout  DC.B    '.L    ',0
000024B6= 20 20 20 20 20 20 ...   1829  nosizeout DC.B   '       ',0
000024BE                          1830  
000024BE= 0D 0A 00                1831  empty    DC.B    '',CR,LF,0
000024C1                          1832  
000024C1  =0000000D               1833  CR  EQU $0D
000024C1  =0000000A               1834  LF  EQU $0A
000024C1                          1835  
000024C1                          1836  
000024C1                          1837      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 14B0
ADDA                14FC
ADDAOUT             244A
ADDOUT              2446
ADDQ                1464
ADDQOUT             244F
ADDQ_EA             1C46
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 1812
ANDOUT              2463
ASL                 1670
ASLOUT              246F
ASR                 16BC
ASROUT              2473
ATOF                2184
ATOH                1AAC
BCC                 185E
BEQ                 18C8
BEQOUT              2487
BGT                 1884
BGTOUT              247F
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 18A6
BLEOUT              2483
BRA                 18EA
BRAOUT              2495
BYTE                12BE
BYTEOUT             24A1
CHECK_EA_AB_L       1E2C
CHECK_EA_AB_W       1E0C
CHECK_EA_AR         1D74
CHECK_EA_IMM        1E4A
CHECK_EA_INDIRECT   1D8E
CHECK_EA_POST       1DB4
CHECK_EA_PRE        1DE0
CHECK_VALID_EA      1D08
CLOSED_PAR_TAG      1F62
COMMA_TAG           1FC2
CONVERTATOH         1AAC
CONVERTHTOA         2170
CR                  D
DATA                190C
DATAOUT             2499
DOLLAR_TAG          1F66
EA1_END             1B8A
EA1_MODE_ONE        1B7E
EA1_MODE_ZERO       1B86
EA2_END             1BCE
EA2_IMMEDIATE       1BC6
EA2_REGISTER        1BBE
EA_GROUP1           1B5E
EA_GROUP2           1BA8
EA_GROUP3           1BEE
EA_GROUP4           1C0A
EMPTY               24BE
END_SIMULATION      218C
FINISH              1B00
FIRSTINPUT          1982
FORMAT_IMMEDIATE_DATA  1B0C
FORWARD_SLASH_TAG   1F68
HASH_SIGN_TAG       1F64
HERE                1026
HEX_TO_ASCII        1EFA
HEX_TO_ASCII_RETURN  1F0A
IMMEDIATE0          1B1C
IMMEDIATE_END       1B1E
INPUT1              8000
INPUT1MESSAGE       2308
INPUT2              8004
INPUT2MESSAGE       232E
INPUTERROR          1B02
INPUTERROR2SMALLER  2372
INPUTERRORBADCHAR   2354
INPUTQUALITY        2421
INPUTREPEAT         23AE
INPUT_BUFFER        1E9E
INVALID_EA          1D42
IPUT_BUFFER_EX      1E96
JSR                 1566
JSROUT              248B
LEA                 17A0
LEAOUT              2454
LETSGO              105E
LETTERS             1F5A
LF                  A
LINECOUNTER         2422
LONG                12EA
LONGOUT             24AF
LOWERCASE           1AE8
LSL                 15D8
LSLOUT              2467
LSR                 1624
LSROUT              246B
MEMORY_TO_REGISTER  1CA0
MINUS_TAG           1F94
MODE_010            1CCE
MODE_01_0           1D00
MOVE                1320
MOVEA               1372
MOVEAOUT            2430
MOVEM               13D4
MOVEMOUT            243C
MOVEM_EA            1C96
MOVEOUT             242B
MOVEQ               13AE
MOVEQOUT            2436
MOVEQ_EA            1C6E
MOVE_MOVEA_EA       1B20
NEWLINE             241B
NEWLINE_TAG         1FEC
NOP                 1300
NOPOUT              2425
NOSIZEOUT           24B6
NOT                 158C
NOTOUT              245C
NUMBER_TO_ASCII     1F10
ODDNUMBER1          1A82
ODDNUMBER2          1AA2
ODDNUMBERCHECKER1   1A66
ODDNUMBERCHECKER2   1A8A
OP1                 136A
OP10                1668
OP11                16B4
OP12                1700
OP13                174C
OP14                1798
OP15                180A
OP16                1856
OP2                 13A6
OP3                 1410
OP4                 145C
OP5                 14A8
OP6                 14F4
OP7                 1538
OP8                 15D0
OP9                 161C
OPCODE              11B8
OPEN_PAR_TAG        1F60
OR                  17C6
OROUT               2460
OUTPUT              2040
OUTPUTADDRESS       211A
OUTPUTADDRESSLOOP   212E
OUTPUTADDRESSLOOPEND  2150
OUTPUTDATA          20C4
OUTPUTDATALOOP      20D8
OUTPUTDATALOOPEND   20FA
OUTPUTNEWSCREEN     23F8
OUTPUTOPCODE        2070
OUTPUTOPCODENEWSCREEN  208A
OUTPUTSIZE          20BC
OUTPUTTYPE          2423
PLUS_TAG            1F92
POPULATE_BUFFER     1ED0
PRINT_BUFFER        1E8C
PRINT_CLOSED_PARENTHESIS  1F7E
PRINT_COMMA         1FC4
PRINT_DOLLAR        2018
PRINT_EA            1D4C
PRINT_EA_RETURN     1E86
PRINT_FORWARD_SLASH  202C
PRINT_HASH_SIGN     2004
PRINT_HEX           1EAE
PRINT_HEX_RETURN    1EC4
PRINT_MINUS         1FAA
PRINT_NEWLINE       1FF0
PRINT_OPEN_PARENTHESIS  1F6A
PRINT_PLUS          1F96
PRINT_REGISTOR      1F16
PRINT_REGISTOR_RETURN  1F46
PRINT_TAB           1FD8
READ_WORD_IMM       1E6E
REGISTER_TO_MEMORY  1CDC
REPEATFLAG          2424
RETURN              12BC
ROL                 1708
ROLOUT              2477
ROR                 1754
ROROUT              247B
RTS                 1540
RTSOUT              248F
SECONDINPUT         19E6
SPACES              241E
SPACE_TAG           1FC0
START               1000
STARTMESSAGE        2196
SUB                 1418
SUBOUT              2442
TAB_TAG             1FBE
THERE               118C
THROWINPUT1CHARERROR  19C8
THROWINPUT2CHARERROR  1A36
THROWINPUT2LOWERERROR  1A52
TO_STRING           1F4C
UPPERCASE           1AD0
USERINPUT           193A
USERINPUTREPEAT     118E
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1D2A
WELCOMEEXPLANATION  1968
WORD                12D4
WORDOUT             24A8
WRONG_INSTRUCTION   1CC4
ZEROTONINE          217C
