00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/11/2022 4:33:23 AM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 0000241C        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 092A                 15      BSR     USERINPUT
0000100C                            16      *MOVE.L  (input1),A2
0000100C                            17  *memoryLoop
0000100C                            18  *    BSR     OPCODE
0000100C                            19  *    ADD.L   #2,A2
0000100C                            20  *    CMP.B   A2,(input2)
0000100C                            21  *    BGE     userInputRepeat
0000100C                            22  *    BRA     memoryLoop
0000100C                            23  
0000100C                            24      
0000100C                            25  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 26      MOVE.B #$04, D6
00001010  347C 1004                 27      MOVE.W #$1004, A2
00001014  7C0A                      28      MOVEQ #10, D6
00001016  264A                      29      MOVEA.L A2, A3
00001018  B641                      30      CMP D1,D3
0000101A  9C82                      31      SUB.L D2, D6
0000101C                            32  
0000101C  6000 0002                 33      BRA here
00001020                            34  here
00001020  4EB9 00001186             35      JSR there
00001026  4693                      36      NOT.L (A3)
00001028  47D1                      37      LEA (A1),A3
0000102A  8AB9 00008000             38      OR.L input1, D5
00001030  48E7 FFFE                 39      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      40      AND.B D1,D6
00001036  D803                      41      ADD.B D3,D4
00001038  D4C9                      42      ADDA.W A1,A2
0000103A  5E81                      43      ADDQ.L #7,D1
0000103C  E709                      44      LSL.B #3,D1
0000103E  E449                      45      lSR.W #2,D1
00001040  ED02                      46      ASL.B #6,D2
00001042  EA42                      47      ASR.W #5,D2
00001044  EB1B                      48      ROL.B #5,D3
00001046  E85B                      49      ROR.W #4,D3
00001048  6E00 000E                 50      BGT letsgo
0000104C  B67C 0004                 51      CMP #4,D3 
00001050  6700 0006                 52      BEQ letsgo
00001054  6F00 0002                 53      BLE letsgo
00001058                            54     
00001058                            55  letsgo
00001058                            56      
00001058                            57  * calls-------------------------------------------------------
00001058  347C 100C                 58      MOVE.W #$100C, A2
0000105C  6100 0154                 59      BSR     OPCODE * test MOVE.B
00001060                            60  
00001060  347C 1010                 61      MOVE.W #$1010, A2
00001064  6100 014C                 62      BSR     OPCODE * test MOVEA.W
00001068                            63      
00001068  347C 1014                 64      MOVE.W #$1014, A2
0000106C  6100 0144                 65      BSR     OPCODE * test MOVEQ
00001070                            66     
00001070  347C 1016                 67      MOVE.W #$1016, A2
00001074  6100 013C                 68      BSR     OPCODE *test MOVEA.L
00001078                            69      
00001078  347C 1018                 70      MOVE.W #$1018, A2
0000107C  6100 0134                 71      BSR     OPCODE *test DATA
00001080                            72      
00001080                            73      
00001080  347C 101A                 74      MOVE.W #$101A, A2
00001084  6100 012C                 75      BSR     OPCODE *test SUB.L
00001088                            76      
00001088  347C 101C                 77      MOVE.W #$101C, A2
0000108C  6100 0124                 78      BSR     OPCODE *test BRA
00001090                            79      
00001090  347C 1020                 80      MOVE.W #$1020, A2
00001094  6100 011C                 81      BSR     OPCODE *test JSR
00001098                            82      
00001098                            83      
00001098  43F9 000024B4             84      LEA empty,A1
0000109E  13FC 0001 0000241D        85      MOVE.B  #1,(OutputType)       
000010A6  6100 0F92                 86      BSR    OUTPUT
000010AA                            87  
000010AA                            88      
000010AA  347C 1026                 89      MOVE.W #$1026, A2
000010AE  6100 0102                 90      BSR     OPCODE *test NOT
000010B2                            91      
000010B2  347C 1028                 92      MOVE.W #$1028, A2
000010B6  6100 00FA                 93      BSR     OPCODE *test LEA
000010BA                            94      
000010BA  347C 102A                 95      MOVE.W #$102A, A2
000010BE  6100 00F2                 96      BSR     OPCODE *test OR
000010C2                            97      
000010C2  43F9 000024B4             98       LEA empty,A1
000010C8  13FC 0001 0000241D        99      MOVE.B  #1,(OutputType)       
000010D0  6100 0F68                100      BSR    OUTPUT
000010D4                           101  
000010D4                           102      
000010D4  347C 1030                103      MOVE.W #$1030, A2
000010D8  6100 00D8                104      BSR     OPCODE *test MOVEM
000010DC                           105  
000010DC  347C 1034                106      MOVE.W #$1034, A2
000010E0  6100 00D0                107      BSR     OPCODE *test AND
000010E4                           108      
000010E4  347C 1036                109      MOVE.W #$1036, A2
000010E8  6100 00C8                110      BSR     OPCODE *test ADD
000010EC                           111      
000010EC  43F9 000024B4            112      LEA empty,A1
000010F2  13FC 0001 0000241D       113      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0F3E                114      BSR    OUTPUT
000010FE                           115  
000010FE  347C 1038                116      MOVE.W #$1038, A2
00001102  6100 00AE                117      BSR     OPCODE *test ADDA
00001106                           118      
00001106  347C 103A                119      MOVE.W #$103A, A2
0000110A  6100 00A6                120      BSR     OPCODE *test ADDQ
0000110E                           121      
0000110E  347C 103C                122      MOVE.W #$103C, A2
00001112  6100 009E                123      BSR     OPCODE *test LSL
00001116                           124  
00001116  347C 103E                125      MOVE.W #$103E, A2
0000111A  6100 0096                126      BSR     OPCODE *test LSR
0000111E                           127      
0000111E  347C 1040                128      MOVE.W #$1040, A2
00001122  6100 008E                129      BSR     OPCODE *test ASL
00001126                           130      
00001126  43F9 000024B4            131      LEA empty,A1
0000112C  13FC 0001 0000241D       132      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0F04                133      BSR    OUTPUT
00001138                           134  
00001138                           135  
00001138  347C 1042                136      MOVE.W #$1042, A2
0000113C  6100 0074                137      BSR     OPCODE *test ASR
00001140                           138      
00001140                           139      
00001140  347C 1044                140      MOVE.W #$1044, A2
00001144  6100 006C                141      BSR     OPCODE *test ROL
00001148                           142  
00001148  347C 1046                143      MOVE.W #$1046, A2
0000114C  6100 0064                144      BSR     OPCODE *test ROR
00001150                           145      
00001150  43F9 000024B4            146      LEA empty,A1
00001156  13FC 0001 0000241D       147      MOVE.B  #1,(OutputType) * new line  
0000115E  6100 0EDA                148      BSR    OUTPUT
00001162                           149  
00001162  347C 1048                150      MOVE.W #$1048, A2
00001166  6100 004A                151      BSR     OPCODE *test BGT
0000116A                           152  
0000116A  347C 1050                153      MOVE.W #$1050, A2
0000116E  6100 0042                154      BSR     OPCODE *test BLE
00001172                           155      
00001172  347C 1054                156      MOVE.W #$1054, A2
00001176  6100 003A                157      BSR     OPCODE *test BEQ
0000117A                           158      
0000117A                           159  
0000117A                           160    
0000117A  347C 1186                161      MOVE.W #$1186, A2
0000117E  6100 0032                162      BSR     OPCODE *test RTS
00001182                           163  
00001182                           164  
00001182                           165  * calls---------------------------------------------------------    
00001182  6000 0004                166      BRA userInputRepeat
00001186                           167  there    
00001186  4E75                     168      RTS
00001188                           169  * end testing--------------------------------------------------------------
00001188                           170   
00001188                           171  
00001188                           172       
00001188                           173    
00001188                           174  
00001188                           175      
00001188                           176  userInputRepeat
00001188  43F9 000023A8            177      LEA     INPUTREPEAT,A1
0000118E  103C 000E                178      MOVE.B  #14,D0
00001192  4E4F                     179      TRAP    #15
00001194  5239 0000241C            180      ADD.B   #1,(LineCounter)
0000119A                           181      
0000119A  43F9 00008008            182      LEA     userInputStored,A1
000011A0  103C 0005                183      MOVE.B  #5,D0
000011A4  4E4F                     184      TRAP    #15
000011A6                           185      
000011A6  B23C 000D                186      CMP.B   #$0D,D1
000011AA  6700 FE5C                187      BEQ     userInputStart
000011AE                           188   
000011AE  FFFF FFFF                189      SIMHALT
000011B2                           190  
000011B2                           191  **********************************************************
000011B2                           192  *Subroutine: OPCODE
000011B2                           193  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B2                           194  *Registers: 
000011B2                           195  *A1: printing
000011B2                           196  *A2: parameter with instruction address
000011B2                           197  *D0: printing
000011B2                           198  *D3: used for determing the instruction, mostly shifts
000011B2                           199  *D2: used for determing the size
000011B2                           200  *D4: used for passing size to SIZE
000011B2                           201  *Paramemeters: A2 the memory address to decode from
000011B2                           202  **********************************************************
000011B2                           203  OPCODE:
000011B2  4243                     204      CLR D3
000011B4                           205      
000011B4  0C52 4E75                206      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011B8  6700 0380                207      BEQ rts
000011BC                           208      
000011BC  0C52 4E71                209      CMP #$4E71, (A2) *NOP compare
000011C0  6700 0138                210      BEQ nop
000011C4                           211      
000011C4  3612                     212      Move.W (A2), D3 
000011C6  E04B                     213      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011C8  E84B                     214      LSR #4,D3
000011CA                           215      
000011CA                           216      
000011CA  B67C 0008                217      CMP #%1000, D3 * OR compare
000011CE  6700 05F0                218      BEQ or
000011D2                           219      
000011D2                           220      
000011D2  B67C 0003                221      CMP #%0011, D3 *MOVE and MOVEA compare
000011D6  6F00 0142                222      BLE move
000011DA                           223      
000011DA  B67C 0007                224      CMP #%0111, D3 *MOVEQ compare
000011DE  6700 01C8                225      BEQ moveq
000011E2                           226      
000011E2  B67C 0009                227      CMP #%1001, D3 *SUB compare
000011E6  6700 022A                228      BEQ sub
000011EA                           229      
000011EA  B67C 000C                230      CMP #%1100, D3 *AND compare
000011EE  6700 061C                231      BEQ and
000011F2                           232      
000011F2  B67C 0005                233      CMP #%0101, D3 *ADDQ compare
000011F6  6700 0266                234      BEQ addq
000011FA                           235      
000011FA  B67C 0006                236      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
000011FE  6700 0658                237      BEQ bcc
00001202                           238      
00001202                           239  
00001202  3612                     240      Move.W (A2), D3 * reset D3
00001204  0243 F118                241      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
00001208  B67C E108                242      CMP #%1110000100001000,D3 * LSL compare
0000120C  6700 03C4                243      BEQ lsl
00001210                           244  
00001210  3612                     245      Move.W (A2), D3 * reset D3
00001212  0243 F118                246      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
00001216  B67C E008                247      CMP #%1110000000001000,D3 * LSR compare
0000121A  6700 0402                248      BEQ lsr
0000121E                           249      
0000121E                           250      
0000121E  3612                     251      Move.W (A2), D3 * reset D3
00001220  0243 F118                252      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001224  B67C E100                253      CMP #%1110000100000000,D3 * ASL compare
00001228  6700 0440                254      BEQ asl
0000122C                           255  
0000122C  3612                     256      Move.W (A2), D3 * reset D3
0000122E  0243 F118                257      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001232  B67C E000                258      CMP #%1110000000000000,D3 * ASR compare
00001236  6700 047E                259      BEQ asr
0000123A                           260  
0000123A  3612                     261      Move.W (A2), D3 * reset D3
0000123C  0243 F118                262      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001240  B67C E118                263      CMP #%1110000100011000,D3 * ROL compare
00001244  6700 04BC                264      BEQ rol
00001248                           265  
00001248  3612                     266      Move.W (A2), D3 * reset D3
0000124A  0243 F118                267      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000124E  B67C E018                268      CMP #%1110000000011000,D3 * ROR compare
00001252  6700 04FA                269      BEQ ror
00001256                           270  
00001256                           271      
00001256                           272      
00001256  3612                     273      Move.W (A2), D3 * reset D3
00001258  0243 F0C0                274      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000125C  B67C D0C0                275      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001260  6700 0294                276      BEQ adda
00001264                           277      
00001264  3612                     278      Move.W (A2), D3 
00001266  E04B                     279      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001268  E84B                     280      LSR #4,D3
0000126A  B67C 000D                281      CMP #%1101, D3 *ADD compare
0000126E  6700 023A                282      BEQ add
00001272                           283  
00001272                           284    
00001272  3612                     285      Move.W (A2), D3 * reset D3
00001274  0243 FB80                286      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001278  B67C 4880                287      CMP #%0100100010000000,D3 * MOVEM compare
0000127C  6700 0150                288      BEQ movem
00001280                           289  
00001280                           290      
00001280                           291      
00001280  3612                     292      Move.W (A2), D3 * reset D3
00001282  EC4B                     293      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001284  B67C 013A                294      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001288  6700 02D6                295      BEQ jsr
0000128C                           296  
0000128C  3612                     297      Move.W (A2), D3 * reset D3
0000128E  E04B                     298      LSR #8,D3 * make D3 only contain the first 8 bits
00001290  B67C 0046                299      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001294  6700 02F0                300      BEQ not
00001298                           301      
00001298  3612                     302      Move.W (A2), D3 * reset D3
0000129A  0243 F1C0                303      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000129E  B67C 41C0                304      CMP #%0100000111000000,D3 *LEA compare
000012A2  6700 04F6                305      BEQ lea
000012A6                           306      
000012A6                           307      
000012A6                           308      
000012A6                           309      
000012A6                           310      
000012A6                           311  
000012A6                           312  
000012A6                           313     
000012A6  3612                     314      Move.W (A2), D3 * reset D3
000012A8  E04B                     315      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012AA  B67C 0060                316      CMP #%01100000, D3 *BRA compare
000012AE  6700 0634                317      BEQ bra
000012B2                           318      
000012B2                           319      
000012B2  6000 0652                320      BRA data
000012B6                           321      
000012B6                           322  return
000012B6  4E75                     323      RTS
000012B8                           324      
000012B8                           325  
000012B8                           326  
000012B8                           327      
000012B8                           328  byte
000012B8  43F9 00002497            329      LEA    byteout,A1        
000012BE  13FC 0002 0000241D       330      MOVE.B  #2,(OutputType)
000012C6  6100 0D72                331      BSR     OUTPUT 
000012CA  2257                     332      MOVE.L (SP),A1 
000012CC  4ED1                     333      JMP (A1)
000012CE                           334  
000012CE                           335  word
000012CE  43F9 0000249E            336      LEA    wordout,A1        
000012D4  13FC 0002 0000241D       337      MOVE.B  #2,(OutputType)
000012DC  6100 0D5C                338      BSR     OUTPUT
000012E0  2257                     339      MOVE.L (SP),A1 
000012E2  4ED1                     340      JMP (A1)
000012E4                           341  
000012E4                           342  long
000012E4  43F9 000024A5            343      LEA    longout,A1        
000012EA  13FC 0002 0000241D       344      MOVE.B  #2,(OutputType)
000012F2  6100 0D46                345      BSR     OUTPUT
000012F6  2257                     346      MOVE.L (SP),A1 
000012F8  4ED1                     347      JMP (A1)
000012FA                           348      
000012FA                           349       
000012FA                           350      
000012FA                           351  nop 
000012FA  13FC 0004 0000241D       352      MOVE.B  #4,(OutputType)
00001302  6100 0D36                353      BSR     OUTPUT
00001306  43F9 0000241F            354      LEA    nopout,A1        
0000130C  13FC 0001 0000241D       355      MOVE.B  #1,(OutputType)
00001314  6100 0D24                356      BSR     OUTPUT
00001318  609C                     357      BRA return
0000131A                           358      
0000131A                           359  move
0000131A                           360      * put the size of the instruction into D2 to use later
0000131A                           361      * since the first two bits of D3 are 00 for move moving the entire word works
0000131A  3403                     362      Move.W D3, D2
0000131C                           363  
0000131C                           364  
0000131C                           365      * determine if MOVE or MOVEA
0000131C                           366      * if bits 8,7,6 = 001 its MOVEA
0000131C  3612                     367      MOVE.W (A2),D3
0000131E  0243 01C0                368      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
00001322                           369      
00001322  B67C 0040                370      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001326  6700 0044                371      BEQ movea
0000132A                           372      
0000132A  13FC 0004 0000241D       373      MOVE.B  #4,(OutputType)
00001332  6100 0D06                374      BSR     OUTPUT
00001336                           375  
00001336  43F9 00002425            376      LEA    moveout,A1     *print the type
0000133C  13FC 0001 0000241D       377      MOVE.B  #1,(OutputType)   
00001344  6100 0CF4                378      BSR    OUTPUT
00001348                           379      
00001348                           380      *now to print size  
00001348  4879 00001364            381      PEA op1
0000134E                           382      
0000134E  B47C 0002                383      cmp #2,D2 *if the size is 2 branch to long
00001352  6790                     384      BEQ long
00001354  B47C 0003                385      cmp #3,D2 *if the size is 3 branch to word
00001358  6700 FF74                386      BEQ word
0000135C  B47C 0001                387      cmp #1,D2 * if the size is 1 branch to byte
00001360  6700 FF56                388      BEQ byte   
00001364                           389  op1
00001364  6100 07B4                390      BSR MOVE_MOVEA_EA
00001368  6000 FF4C                391      BRA return
0000136C                           392      
0000136C                           393  movea
0000136C  13FC 0004 0000241D       394      MOVE.B  #4,(OutputType)
00001374  6100 0CC4                395      BSR     OUTPUT
00001378                           396  
00001378  43F9 0000242A            397      LEA    moveaout,A1
0000137E  13FC 0001 0000241D       398      MOVE.B  #1,(OutputType)       
00001386  6100 0CB2                399      BSR    OUTPUT
0000138A                           400      
0000138A                           401      *now to print size  
0000138A  4879 000013A0            402      PEA op2
00001390                           403  
00001390  B47C 0002                404      cmp #2,D2 *if the size is 2 branch to long
00001394  6700 FF4E                405      BEQ long
00001398  B47C 0003                406      cmp #3,D2 *if the size is 3 branch to word
0000139C  6700 FF30                407      BEQ word
000013A0                           408  op2
000013A0  6100 0778                409      BSR MOVE_MOVEA_EA
000013A4  6000 FF10                410      BRA return
000013A8                           411      
000013A8                           412  moveq
000013A8  13FC 0004 0000241D       413      MOVE.B  #4,(OutputType)
000013B0  6100 0C88                414      BSR     OUTPUT
000013B4                           415  
000013B4  43F9 00002430            416      LEA    moveqout,A1
000013BA  13FC 0001 0000241D       417      MOVE.B  #1,(OutputType)       
000013C2  6100 0C76                418      BSR    OUTPUT
000013C6  6100 08A0                419      BSR MOVEQ_EA
000013CA  6000 FEEA                420      BRA return
000013CE                           421  
000013CE                           422      
000013CE                           423  movem
000013CE  13FC 0004 0000241D       424      MOVE.B  #4,(OutputType)
000013D6  6100 0C62                425      BSR     OUTPUT
000013DA                           426      
000013DA  43F9 00002436            427      LEA    movemout,A1
000013E0  13FC 0001 0000241D       428      MOVE.B  #1,(OutputType)       
000013E8  6100 0C50                429      BSR    OUTPUT
000013EC                           430      
000013EC  4879 0000140A            431      PEA op3
000013F2  3412                     432      MOVE.W (A2),D2
000013F4  0242 0040                433      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013F8  EC4A                     434      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013FA  B47C 0001                435      CMP #1, D2 * if the size is 1 branch to long
000013FE  6700 FEE4                436      BEQ long
00001402  B47C 0000                437      CMP #0, D2 * if the size is 0 branch to long
00001406  6700 FEC6                438      BEQ word
0000140A                           439  op3
0000140A  6100 0884                440      BSR MOVEM_EA
0000140E  6000 FEA6                441      BRA return
00001412                           442      
00001412                           443      
00001412                           444  sub 
00001412  13FC 0004 0000241D       445      MOVE.B  #4,(OutputType)
0000141A  6100 0C1E                446      BSR     OUTPUT
0000141E                           447     
0000141E  43F9 0000243C            448      LEA    subout,A1
00001424  13FC 0001 0000241D       449      MOVE.B  #1,(OutputType)       
0000142C  6100 0C0C                450      BSR    OUTPUT
00001430                           451      
00001430  3412                     452      MOVE.W (A2),D2
00001432  0242 00C0                453      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001436  EC4A                     454      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001438                           455  
00001438                           456  
00001438                           457      
00001438                           458      *now to print size  
00001438  4879 00001456            459      PEA op4
0000143E  B47C 0002                460      cmp #2,D2 *if the size is 2 branch to long
00001442  6700 FEA0                461      BEQ long
00001446  B47C 0001                462      cmp #1,D2 *if the size is 1 branch to word
0000144A  6700 FE82                463      BEQ word
0000144E  B47C 0000                464      cmp #0,D2 *if the size is 0 branch to byte
00001452  6700 FE64                465      BEQ byte 
00001456                           466  op4
00001456  6100 0700                467      BSR EA_GROUP1
0000145A  6000 FE5A                468      BRA return
0000145E                           469      
0000145E                           470  addq 
0000145E  13FC 0004 0000241D       471      MOVE.B  #4,(OutputType)
00001466  6100 0BD2                472      BSR     OUTPUT
0000146A                           473     
0000146A  43F9 00002449            474      LEA    addqout,A1
00001470  13FC 0001 0000241D       475      MOVE.B  #1,(OutputType)       
00001478  6100 0BC0                476      BSR    OUTPUT
0000147C                           477      
0000147C  3412                     478      MOVE.W (A2),D2
0000147E  0242 00C0                479      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001482  EC4A                     480      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001484                           481  
00001484                           482  
00001484                           483      
00001484                           484      *now to print size  
00001484  4879 000014A2            485      PEA op5
0000148A  B47C 0002                486      cmp #2,D2 *if the size is 2 branch to long
0000148E  6700 FE54                487      BEQ long
00001492  B47C 0001                488      cmp #1,D2 *if the size is 1 branch to word
00001496  6700 FE36                489      BEQ word
0000149A  B47C 0000                490      cmp #0,D2 *if the size is 0 branch to byte
0000149E  6700 FE18                491      BEQ byte *otherwise branch to byte
000014A2                           492  op5    
000014A2  6100 079C                493      BSR ADDQ_EA
000014A6  6000 FE0E                494      BRA return    
000014AA                           495      
000014AA                           496      
000014AA                           497  add
000014AA  13FC 0004 0000241D       498      MOVE.B  #4,(OutputType)
000014B2  6100 0B86                499      BSR     OUTPUT
000014B6                           500  
000014B6  43F9 00002440            501      LEA    addout,A1
000014BC  13FC 0001 0000241D       502      MOVE.B  #1,(OutputType)       
000014C4  6100 0B74                503      BSR    OUTPUT
000014C8                           504      
000014C8  3412                     505      MOVE.W (A2),D2
000014CA  0242 00C0                506      ANDI.W #%0000000011000000, D2 * set to only the size bits
000014CE  EC4A                     507      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000014D0                           508  
000014D0                           509  
000014D0                           510      
000014D0                           511      *now to print size  
000014D0  4879 000014EE            512      PEA op6
000014D6  B47C 0002                513      cmp #2,D2 *if the size is 2 branch to long
000014DA  6700 FE08                514      BEQ long
000014DE  B47C 0001                515      cmp #1,D2 *if the size is 1 branch to word
000014E2  6700 FDEA                516      BEQ word
000014E6  B47C 0000                517      cmp #0,D2 *if the size is 0 branch to byte
000014EA  6700 FDE2                518      BEQ word
000014EE                           519  op6
000014EE  6100 0668                520      BSR EA_GROUP1
000014F2  6000 FDC2                521      BRA return
000014F6                           522  
000014F6                           523  adda
000014F6                           524  
000014F6  13FC 0004 0000241D       525      MOVE.B  #4,(OutputType)
000014FE  6100 0B3A                526      BSR     OUTPUT
00001502                           527  
00001502  43F9 00002444            528      LEA    addaout,A1
00001508  13FC 0001 0000241D       529      MOVE.B  #1,(OutputType)       
00001510  6100 0B28                530      BSR    OUTPUT
00001514                           531      
00001514  3412                     532      MOVE.W (A2),D2
00001516  0242 0100                533      ANDI.W #%0000000100000000, D2 * set to only the size bit
0000151A  E04A                     534      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
0000151C                           535  
0000151C                           536  
0000151C                           537      
0000151C                           538      *now to print size  
0000151C  4879 00001532            539      PEA op7
00001522  B47C 0001                540      cmp #1,D2 *if the size is 1 branch to long
00001526  6700 FDBC                541      BEQ long
0000152A  B47C 0000                542      cmp #0,D2 *if the size is 0 branch to word
0000152E  6700 FD9E                543      BEQ word
00001532                           544  op7
00001532  6100 06D0                545      BSR EA_GROUP4
00001536  6000 FD7E                546      BRA return
0000153A                           547  
0000153A                           548      
0000153A                           549  rts
0000153A  13FC 0004 0000241D       550      MOVE.B  #4,(OutputType)
00001542  6100 0AF6                551      BSR     OUTPUT
00001546                           552  
00001546  43F9 00002485            553      LEA    rtsout,A1
0000154C  13FC 0001 0000241D       554      MOVE.B  #1,(OutputType)       
00001554  6100 0AE4                555      BSR    OUTPUT
00001558                           556      
00001558  6100 0648                557      BSR EA_GROUP2
0000155C  6000 FD58                558      BRA return
00001560                           559      
00001560                           560      
00001560                           561  jsr 
00001560  13FC 0004 0000241D       562      MOVE.B  #4,(OutputType)
00001568  6100 0AD0                563      BSR     OUTPUT
0000156C                           564     
0000156C  43F9 00002481            565      LEA    jsrout,A1
00001572  13FC 0001 0000241D       566      MOVE.B  #1,(OutputType)       
0000157A  6100 0ABE                567      BSR    OUTPUT
0000157E                           568      
0000157E  6100 0622                569      BSR EA_GROUP2
00001582  6000 FD32                570      BRA return
00001586                           571      
00001586                           572      
00001586                           573  not 
00001586  13FC 0004 0000241D       574      MOVE.B  #4,(OutputType)
0000158E  6100 0AAA                575      BSR     OUTPUT
00001592                           576    
00001592  43F9 00002452            577      LEA    notout,A1
00001598  13FC 0001 0000241D       578      MOVE.B  #1,(OutputType)       
000015A0  6100 0A98                579      BSR    OUTPUT
000015A4                           580      
000015A4  3412                     581      MOVE.W (A2),D2
000015A6  0242 00C0                582      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015AA  EC4A                     583      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015AC                           584  
000015AC                           585      *now to print size  
000015AC  4879 000015CA            586      PEA op8
000015B2  B47C 0002                587      cmp #2,D2 *if the size is 2 branch to long
000015B6  6700 FD2C                588      BEQ long
000015BA  B47C 0001                589      cmp #1,D2 *if the size is 1 branch to word
000015BE  6700 FD0E                590      BEQ word
000015C2  B47C 0000                591      cmp #0,D2 *if the size is 0 branch to byte
000015C6  6700 FCF0                592      BEQ byte
000015CA                           593  
000015CA                           594      
000015CA                           595  op8    
000015CA  6100 061C                596      BSR EA_GROUP3
000015CE                           597      
000015CE  6000 FCE6                598      BRA return
000015D2                           599  
000015D2                           600  lsl
000015D2  13FC 0004 0000241D       601      MOVE.B  #4,(OutputType)
000015DA  6100 0A5E                602      BSR     OUTPUT
000015DE                           603  
000015DE  43F9 0000245D            604      LEA    lslout,A1
000015E4  13FC 0001 0000241D       605      MOVE.B  #1,(OutputType)       
000015EC  6100 0A4C                606      BSR    OUTPUT
000015F0                           607      
000015F0  3412                     608      MOVE.W (A2),D2
000015F2  0242 00C0                609      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015F6  EC4A                     610      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015F8                           611  
000015F8                           612  
000015F8                           613      
000015F8                           614      *now to print size 
000015F8  4879 00001616            615      PEA op9 
000015FE  B47C 0002                616      cmp #2,D2 *if the size is 2 branch to long
00001602  6700 FCE0                617      BEQ long
00001606  B47C 0001                618      cmp #1,D2 *if the size is 1 branch to word
0000160A  6700 FCC2                619      BEQ word
0000160E  B47C 0000                620      cmp #0,D2 *if the size is 0 branch to byte
00001612  6700 FCA4                621      BEQ byte
00001616                           622  op9
00001616  6100 058A                623      BSR EA_GROUP2
0000161A  6000 FC9A                624      BRA return
0000161E                           625  
0000161E                           626  lsr
0000161E  13FC 0004 0000241D       627      MOVE.B  #4,(OutputType)
00001626  6100 0A12                628      BSR     OUTPUT
0000162A                           629  
0000162A  43F9 00002461            630      LEA    lsrout,A1
00001630  13FC 0001 0000241D       631      MOVE.B  #1,(OutputType)       
00001638  6100 0A00                632      BSR    OUTPUT
0000163C                           633      
0000163C  3412                     634      MOVE.W (A2),D2
0000163E  0242 00C0                635      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001642  EC4A                     636      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001644                           637  
00001644                           638  
00001644                           639      
00001644                           640      *now to print size 
00001644  4879 00001662            641      PEA op10 
0000164A  B47C 0002                642      cmp #2,D2 *if the size is 2 branch to long
0000164E  6700 FC94                643      BEQ long
00001652  B47C 0001                644      cmp #1,D2 *if the size is 1 branch to word
00001656  6700 FC76                645      BEQ word
0000165A  B47C 0000                646      cmp #0,D2 *if the size is 0 branch to byte
0000165E  6700 FC58                647      BEQ byte
00001662                           648  op10
00001662  6100 053E                649      BSR EA_GROUP2
00001666  6000 FC4E                650      BRA return
0000166A                           651  asl
0000166A  13FC 0004 0000241D       652      MOVE.B  #4,(OutputType)
00001672  6100 09C6                653      BSR     OUTPUT
00001676                           654  
00001676  43F9 00002465            655      LEA    aslout,A1
0000167C  13FC 0001 0000241D       656      MOVE.B  #1,(OutputType)       
00001684  6100 09B4                657      BSR    OUTPUT
00001688                           658      
00001688  3412                     659      MOVE.W (A2),D2
0000168A  0242 00C0                660      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000168E  EC4A                     661      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001690                           662  
00001690                           663  
00001690                           664      
00001690                           665      *now to print size 
00001690  4879 000016AE            666      PEA op11 
00001696  B47C 0002                667      cmp #2,D2 *if the size is 2 branch to long
0000169A  6700 FC48                668      BEQ long
0000169E  B47C 0001                669      cmp #1,D2 *if the size is 1 branch to word
000016A2  6700 FC2A                670      BEQ word
000016A6  B47C 0000                671      cmp #0,D2 *if the size is 0 branch to byte
000016AA  6700 FC0C                672      BEQ byte
000016AE                           673  op11
000016AE  6100 04F2                674      BSR EA_GROUP2
000016B2  6000 FC02                675      BRA return
000016B6                           676  
000016B6                           677  asr
000016B6  13FC 0004 0000241D       678      MOVE.B  #4,(OutputType)
000016BE  6100 097A                679      BSR     OUTPUT
000016C2                           680  
000016C2  43F9 00002469            681      LEA    asrout,A1
000016C8  13FC 0001 0000241D       682      MOVE.B  #1,(OutputType)       
000016D0  6100 0968                683      BSR    OUTPUT
000016D4                           684      
000016D4  3412                     685      MOVE.W (A2),D2
000016D6  0242 00C0                686      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016DA  EC4A                     687      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016DC                           688  
000016DC                           689  
000016DC                           690      
000016DC                           691       *now to print size 
000016DC  4879 000016FA            692      PEA op12 
000016E2  B47C 0002                693      cmp #2,D2 *if the size is 2 branch to long
000016E6  6700 FBFC                694      BEQ long
000016EA  B47C 0001                695      cmp #1,D2 *if the size is 1 branch to word
000016EE  6700 FBDE                696      BEQ word
000016F2  B47C 0000                697      cmp #0,D2 *if the size is 0 branch to byte
000016F6  6700 FBC0                698      BEQ byte
000016FA                           699  op12
000016FA  6100 04A6                700      BSR EA_GROUP2
000016FE  6000 FBB6                701      BRA return
00001702                           702      
00001702                           703  rol
00001702  13FC 0004 0000241D       704      MOVE.B  #4,(OutputType)
0000170A  6100 092E                705      BSR     OUTPUT
0000170E                           706  
0000170E  43F9 0000246D            707      LEA    rolout,A1
00001714  13FC 0001 0000241D       708      MOVE.B  #1,(OutputType)       
0000171C  6100 091C                709      BSR    OUTPUT
00001720                           710      
00001720  3412                     711      MOVE.W (A2),D2
00001722  0242 00C0                712      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001726  EC4A                     713      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001728                           714  
00001728                           715  
00001728                           716      
00001728                           717     *now to print size 
00001728  4879 00001746            718      PEA op13 
0000172E  B47C 0002                719      cmp #2,D2 *if the size is 2 branch to long
00001732  6700 FBB0                720      BEQ long
00001736  B47C 0001                721      cmp #1,D2 *if the size is 1 branch to word
0000173A  6700 FB92                722      BEQ word
0000173E  B47C 0000                723      cmp #0,D2 *if the size is 0 branch to byte
00001742  6700 FB74                724      BEQ byte
00001746                           725  op13
00001746  6100 045A                726      BSR EA_GROUP2
0000174A  6000 FB6A                727      BRA return
0000174E                           728  
0000174E                           729  ror
0000174E  13FC 0004 0000241D       730      MOVE.B  #4,(OutputType)
00001756  6100 08E2                731      BSR     OUTPUT
0000175A                           732  
0000175A  43F9 00002471            733      LEA    rorout,A1
00001760  13FC 0001 0000241D       734      MOVE.B  #1,(OutputType)       
00001768  6100 08D0                735      BSR    OUTPUT
0000176C                           736      
0000176C  3412                     737      MOVE.W (A2),D2
0000176E  0242 00C0                738      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001772  EC4A                     739      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001774                           740  
00001774                           741  
00001774                           742     *now to print size 
00001774  4879 00001792            743      PEA op14 
0000177A  B47C 0002                744      cmp #2,D2 *if the size is 2 branch to long
0000177E  6700 FB64                745      BEQ long
00001782  B47C 0001                746      cmp #1,D2 *if the size is 1 branch to word
00001786  6700 FB46                747      BEQ word
0000178A  B47C 0000                748      cmp #0,D2 *if the size is 0 branch to byte
0000178E  6700 FB28                749      BEQ byte
00001792                           750  op14
00001792  6100 040E                751      BSR EA_GROUP2
00001796  6000 FB1E                752      BRA return
0000179A                           753      
0000179A                           754      
0000179A                           755  
0000179A                           756  lea
0000179A  13FC 0004 0000241D       757      MOVE.B  #4,(OutputType)
000017A2  6100 0896                758      BSR     OUTPUT
000017A6                           759  
000017A6  43F9 0000244E            760      LEA    leaout,A1
000017AC  13FC 0001 0000241D       761      MOVE.B  #1,(OutputType)       
000017B4  6100 0884                762      BSR    OUTPUT
000017B8  6100 044A                763      BSR EA_GROUP4
000017BC  6000 FAF8                764      BRA return
000017C0                           765      
000017C0                           766  or
000017C0  13FC 0004 0000241D       767      MOVE.B  #4,(OutputType)
000017C8  6100 0870                768      BSR     OUTPUT
000017CC                           769  
000017CC  43F9 00002456            770      LEA    orout,A1
000017D2  13FC 0001 0000241D       771      MOVE.B  #1,(OutputType)       
000017DA  6100 085E                772      BSR    OUTPUT
000017DE                           773      
000017DE                           774          
000017DE  3412                     775      MOVE.W (A2),D2
000017E0  0242 00C0                776      ANDI.W #%0000000011000000, D2 * set to only the size bits
000017E4  EC4A                     777      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000017E6                           778  
000017E6                           779        *now to print size 
000017E6  4879 00001804            780      PEA op15 
000017EC  B47C 0002                781      cmp #2,D2 *if the size is 2 branch to long
000017F0  6700 FAF2                782      BEQ long
000017F4  B47C 0001                783      cmp #1,D2 *if the size is 1 branch to word
000017F8  6700 FAD4                784      BEQ word
000017FC  B47C 0000                785      cmp #0,D2 *if the size is 0 branch to byte
00001800  6700 FAB6                786      BEQ byte
00001804                           787  op15    
00001804  6100 0352                788      BSR EA_GROUP1
00001808  6000 FAAC                789      BRA return
0000180C                           790      
0000180C                           791  and
0000180C  13FC 0004 0000241D       792      MOVE.B  #4,(OutputType)
00001814  6100 0824                793      BSR     OUTPUT
00001818                           794  
00001818  43F9 00002459            795      LEA    andout,A1
0000181E  13FC 0001 0000241D       796      MOVE.B  #1,(OutputType)       
00001826  6100 0812                797      BSR    OUTPUT
0000182A                           798      
0000182A                           799          
0000182A  3412                     800      MOVE.W (A2),D2
0000182C  0242 00C0                801      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001830  EC4A                     802      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001832                           803  
00001832                           804      *now to print size 
00001832  4879 00001850            805      PEA op16 
00001838  B47C 0002                806      cmp #2,D2 *if the size is 2 branch to long
0000183C  6700 FAA6                807      BEQ long
00001840  B47C 0001                808      cmp #1,D2 *if the size is 1 branch to word
00001844  6700 FA88                809      BEQ word
00001848  B47C 0000                810      cmp #0,D2 *if the size is 0 branch to byte
0000184C  6700 FA6A                811      BEQ byte
00001850                           812  op16
00001850  6100 0306                813      BSR EA_GROUP1
00001854  6000 FA60                814      BRA return    
00001858                           815  
00001858                           816  bcc
00001858  4243                     817      CLR D3
0000185A  3612                     818      MOVE.W (A2), D3
0000185C                           819      
0000185C  0243 0F00                820      ANDI.W #%0000111100000000,D3 * bits [11-8]
00001860  E04B                     821      LSR.W #8,D3
00001862  B67C 000E                822      CMP #%1110, D3 * BGT compare
00001866  6700 0016                823      BEQ bgt
0000186A  B67C 000F                824      CMP #%1111, D3 * BLE compare
0000186E  6700 0030                825      BEQ ble
00001872  B67C 0007                826      CMP #%0111, D3 * BEQ compare
00001876  6700 004A                827      BEQ beq
0000187A  6000 008A                828      BRA data * goto data if doesn't work
0000187E                           829  
0000187E                           830  bgt
0000187E  13FC 0004 0000241D       831      MOVE.B  #4,(OutputType)
00001886  6100 07B2                832      BSR     OUTPUT
0000188A                           833  
0000188A  43F9 00002475            834      LEA    bgtout,A1
00001890  13FC 0001 0000241D       835      MOVE.B  #1,(OutputType)       
00001898  6100 07A0                836      BSR    OUTPUT
0000189C  6000 FA18                837      BRA return
000018A0                           838  
000018A0                           839  ble
000018A0  13FC 0004 0000241D       840      MOVE.B  #4,(OutputType)
000018A8  6100 0790                841      BSR     OUTPUT
000018AC                           842  
000018AC  43F9 00002479            843      LEA    bleout,A1
000018B2  13FC 0001 0000241D       844      MOVE.B  #1,(OutputType)       
000018BA  6100 077E                845      BSR    OUTPUT
000018BE  6000 F9F6                846      BRA return
000018C2                           847  beq
000018C2  13FC 0004 0000241D       848      MOVE.B  #4,(OutputType)
000018CA  6100 076E                849      BSR     OUTPUT
000018CE                           850  
000018CE  43F9 0000247D            851      LEA    beqout,A1
000018D4  13FC 0001 0000241D       852      MOVE.B  #1,(OutputType)       
000018DC  6100 075C                853      BSR    OUTPUT
000018E0  6000 F9D4                854      BRA return
000018E4                           855  
000018E4                           856  bra
000018E4  13FC 0004 0000241D       857      MOVE.B  #4,(OutputType)
000018EC  6100 074C                858      BSR     OUTPUT
000018F0                           859  
000018F0  43F9 0000248B            860      LEA    braout,A1
000018F6  13FC 0001 0000241D       861      MOVE.B  #1,(OutputType)       
000018FE  6100 073A                862      BSR    OUTPUT
00001902  6000 F9B2                863      BRA return
00001906                           864  
00001906                           865  data
00001906  13FC 0004 0000241D       866      MOVE.B  #4,(OutputType)
0000190E  6100 072A                867      BSR     OUTPUT
00001912                           868  
00001912  43F9 0000248F            869      LEA    dataout,A1
00001918  13FC 0001 0000241D       870      MOVE.B  #1,(OutputType)       
00001920  6100 0718                871      BSR    OUTPUT
00001924                           872      
00001924  13FC 0003 0000241D       873      MOVE.B  #3,(OutputType)       
0000192C  6100 070C                874      BSR    OUTPUT     
00001930  6000 F984                875      BRA return
00001934                           876  
00001934                           877  
00001934                           878  **********************************************************
00001934                           879  *Subroutine: USERINPUT
00001934                           880  *What it does: Takes in user input, rejects bad input
00001934                           881  *Registers: Uses register A1, D0, D5
00001934                           882  *A1: Stores messages and user input
00001934                           883  *D0: Used for TRAP #15
00001934                           884  *D5: Temporaraly stores user input to be masked then transfered
00001934                           885  *Paramemeters: No parameters
00001934                           886  **********************************************************
00001934                           887  USERINPUT:
00001934  4281                     888      CLR.L   D1
00001936  4282                     889      CLR.L   D2
00001938  4283                     890      CLR.L   D3
0000193A  4284                     891      CLR.L   D4
0000193C  4285                     892      CLR.L   D5
0000193E  0C39 0000 0000241E       893      CMP.B   #0,(RepeatFlag)
00001946  6700 001A                894      BEQ     welcomeExplanation
0000194A  6000 0030                895      BRA     firstInput
0000194E  02B9 00000000 00008000   896      AND.L   #$00000000,(Input1)
00001958  02B9 00000000 00008004   897      AND.L   #$00000000,(Input2)
00001962                           898      
00001962                           899  welcomeExplanation
00001962  43F9 00002190            900      LEA     STARTMESSAGE,A1         
00001968  103C 000E                901      MOVE.B  #14,D0
0000196C  4E4F                     902      TRAP    #15
0000196E                           903      
0000196E  5039 0000241C            904      ADD.B   #8,(LineCounter)
00001974  13FC 0001 0000241E       905      MOVE.B  #1,(RepeatFlag)
0000197C                           906  
0000197C                           907  firstInput
0000197C  43F9 00002302            908      LEA     INPUT1MESSAGE,A1        
00001982  103C 000E                909      MOVE.B  #14,D0                  
00001986  4E4F                     910      TRAP    #15                     Asks user for first input
00001988  5239 0000241C            911      ADD.B   #1,(LineCounter)        Adds 1 to line counter
0000198E                           912      
0000198E  43F9 00008008            913      LEA     userInputStored,A1
00001994  103C 0002                914      MOVE.B  #2,D0                   
00001998  4E4F                     915      TRAP    #15                     User can input string for address
0000199A  5239 0000241C            916      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000019A0                           917  
000019A0                           918      
000019A0  6100 0104                919      BSR     CONVERTATOH                 String converted to hex address
000019A4                           920      
000019A4  0C39 0000 0000241B       921      CMP.B   #0,(InputQuality)       Checks if bad input flag set
000019AC  6700 0036                922      BEQ     throwInput1CharError
000019B0                           923  
000019B0                           924      
000019B0  CABC 00FFFFFF            925      AND.L   #$00FFFFFF,D5           
000019B6  2C05                     926      MOVE.L  D5,D6
000019B8  CCBC 0000000F            927      AND.L   #$0000000F,D6
000019BE  CC3C 0001                928      AND.B   #%0001,D6
000019C2  BC3C 0001                929      CMP.B   #%0001,D6
000019C6  6700 000E                930      BEQ     oddnumber1
000019CA  23C5 00008000            931      MOVE.L  D5,input1               Moves result into input 1 memory location
000019D0  4285                     932      CLR.L   D5                      Clears D5 for future use
000019D2  6000 0030                933      BRA     secondInput
000019D6                           934      
000019D6                           935  oddnumber1    
000019D6  5205                     936      ADD.B   #1,D5
000019D8  23C5 00008000            937      MOVE.L  D5,input1
000019DE  4285                     938      CLR.L   D5
000019E0  6000 0022                939      BRA     secondInput
000019E4                           940      
000019E4                           941  throwInput1CharError
000019E4  43F9 0000234E            942      LEA     INPUTERRORBADCHAR,A1
000019EA  103C 000E                943      MOVE.B  #14,D0
000019EE  4E4F                     944      TRAP    #15                     Outputs bad character error message
000019F0  5639 0000241C            945      ADD.B   #3,(LineCounter)        Adds 2 to line counter
000019F6                           946      
000019F6  13FC 0001 0000241B       947      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
000019FE  4285                     948      CLR.L   D5                      Clears D5 for future use
00001A00                           949      
00001A00                           950      
00001A00                           951      
00001A00  6000 FF7A                952      BRA     firstInput              Tries again for input1
00001A04                           953  
00001A04                           954      
00001A04                           955  secondInput
00001A04  43F9 00002328            956      LEA     INPUT2MESSAGE,A1        
00001A0A  103C 000E                957      MOVE.B  #14,D0                  
00001A0E  4E4F                     958      TRAP    #15                     Asks user for second input
00001A10  5239 0000241C            959      ADD.B   #1,(LineCounter)
00001A16                           960      
00001A16  43F9 00008008            961      LEA     userInputStored,A1
00001A1C  103C 0002                962      MOVE.B  #2,D0                   
00001A20  4E4F                     963      TRAP    #15                     User can input string for address
00001A22  5239 0000241C            964      ADD.B   #1,(LineCounter)
00001A28                           965  
00001A28                           966      
00001A28  6100 007C                967      BSR     CONVERTATOH                 String converted to hex address
00001A2C                           968  
00001A2C  0C39 0000 0000241B       969      CMP.B   #0,(InputQuality)       
00001A34  6700 003C                970      BEQ     throwInput2CharError    Checks if bad input flag set
00001A38                           971      
00001A38  CABC 00FFFFFF            972      AND.L   #$00FFFFFF,D5
00001A3E  BAB9 00008000            973      CMP.L   (input1),D5
00001A44  6D00 004A                974      BLT     throwInput2LowerError
00001A48  2C05                     975      MOVE.L  D5,D6
00001A4A  CCBC 0000000F            976      AND.L   #$0000000F,D6
00001A50  CC3C 0001                977      AND.B   #%0001,D6
00001A54  BC3C 0001                978      CMP.B   #%0001,D6
00001A58  6700 000C                979      BEQ     oddnumber2
00001A5C                           980  
00001A5C                           981      
00001A5C                           982      
00001A5C  23C5 00008004            983      MOVE.L  D5,input2               Moves result into input 2 memory location
00001A62  4285                     984      CLR.L   D5                      Clears D5 for future use
00001A64  4E75                     985      RTS
00001A66                           986  
00001A66                           987  oddnumber2
00001A66  5205                     988      ADD.B   #1,D5
00001A68  23C5 00008004            989      MOVE.L  D5,input2
00001A6E  4285                     990      CLR.L   D5
00001A70  4E75                     991      RTS
00001A72                           992  
00001A72                           993      
00001A72                           994  throwInput2CharError
00001A72  43F9 0000234E            995      LEA     INPUTERRORBADCHAR,A1    
00001A78  103C 000E                996      MOVE.B  #14,D0
00001A7C  4E4F                     997      TRAP    #15                     Outputs bad character error message
00001A7E                           998      
00001A7E  5639 0000241B            999      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
00001A84  4285                    1000      CLR.L   D5                      Clears D5 for future use
00001A86                          1001      
00001A86  5639 0000241C           1002      ADD.B   #3,(LineCounter)
00001A8C                          1003      
00001A8C  6000 FF76               1004      BRA     secondInput             Tries again for input2
00001A90                          1005      
00001A90                          1006  throwInput2LowerError
00001A90  43F9 0000236C           1007      LEA     INPUTERROR2SMALLER,A1
00001A96  103C 000E               1008      MOVE.B  #14,D0
00001A9A  4E4F                    1009      TRAP    #15
00001A9C                          1010      
00001A9C  5639 0000241C           1011      ADD.B   #3,(LineCounter)
00001AA2                          1012      
00001AA2  6000 FF60               1013      BRA     secondInput
00001AA6                          1014  
00001AA6                          1015  
00001AA6                          1016  
00001AA6                          1017  **********************************************************
00001AA6                          1018  *Subroutine: CONVERTATOH
00001AA6                          1019  *What it does: Converts user input to hex code
00001AA6                          1020  *Registers: Uses register A1, D2, D5
00001AA6                          1021  *Paramemeters: User input stored in (A1)
00001AA6                          1022  ********************************************************** 
00001AA6                          1023  CONVERTATOH:
00001AA6                          1024      
00001AA6                          1025  AtoH
00001AA6  1419                    1026      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
00001AA8                          1027      
00001AA8  B43C 0000               1028      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
00001AAC  6700 004C               1029      BEQ     Finish                  Moves to finish if they are equal (no more input)
00001AB0                          1030      
00001AB0  E985                    1031      ASL.L   #4,D5
00001AB2                          1032      
00001AB2  B43C 0030               1033      CMP.B   #$30,D2
00001AB6  6D00 0044               1034      BLT     inputError
00001ABA                          1035      
00001ABA  B43C 0039               1036      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
00001ABE  6E00 000A               1037      BGT     upperCase               Branches if greater, may or may not be a letter in hex
00001AC2                          1038      
00001AC2  0402 0030               1039      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
00001AC6  DA02                    1040      ADD.B   D2,D5
00001AC8                          1041      
00001AC8  60DC                    1042      BRA     AtoH
00001ACA                          1043  
00001ACA                          1044          
00001ACA                          1045  upperCase   
00001ACA  B43C 0041               1046      CMP.B   #$41,D2
00001ACE  6D00 002C               1047      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
00001AD2                          1048      
00001AD2  B43C 0046               1049      CMP.B   #$46,D2                 
00001AD6  6E00 000A               1050      BGT     lowerCase               Greater than 46 may be hex code in lowercase
00001ADA                          1051      
00001ADA  0402 0037               1052      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
00001ADE  DA02                    1053      ADD.B   D2,D5
00001AE0  60C4                    1054      BRA     AtoH
00001AE2                          1055  
00001AE2                          1056  lowerCase
00001AE2  B43C 0061               1057      CMP.B   #$61,D2
00001AE6  6D00 0014               1058      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001AEA                          1059      
00001AEA  B43C 0066               1060      CMP.B   #$66,D2
00001AEE  6E00 000C               1061      BGT     InputError              Greater than 66 is not part of hex code
00001AF2                          1062      
00001AF2  0402 0057               1063      SUBI.B  #$57,D2
00001AF6  DA02                    1064      ADD.B   D2,D5
00001AF8  60AC                    1065      BRA     AtoH
00001AFA                          1066          
00001AFA                          1067  Finish
00001AFA  4E75                    1068      RTS                             Return from CONVERT
00001AFC                          1069      
00001AFC                          1070  inputError
00001AFC  13FC 0000 0000241B      1071      MOVE.B  #0,(InputQuality)
00001B04  4E75                    1072      RTS
00001B06                          1073  
00001B06                          1074  *********************************************************************
00001B06                          1075  *Subroutine: EA
00001B06                          1076  *What it does: Outputs parts of opword, moves to new screen if needed
00001B06                          1077  *Registers: Uses register A1, D0,
00001B06                          1078  *A1: Used to store messages and single char
00001B06                          1079  *Paramemeters: A1
00001B06                          1080  *A1: Stores what should be used--++
00001B06                          1081  *********************************************************************  
00001B06  =0000003F               1082  BITS0TO5_MASK   EQU %00111111
00001B06  =000000C0               1083  BITS7TO8_MASK   EQU %11000000
00001B06  =00000E00               1084  BITS9TO11_MASK  EQU %00000111000000000
00001B06                          1085  
00001B06  1E3C 000A               1086  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001B0A  BC7C 0000               1087                          CMP     #0,D6
00001B0E  6700 0006               1088                          BEQ     IMMEDIATE0
00001B12  6000 0004               1089                          BRA     IMMEDIATE_END
00001B16  7C08                    1090  IMMEDIATE0              MOVEQ   #8,D6
00001B18                          1091  
00001B18  4E75                    1092  IMMEDIATE_END           RTS
00001B1A                          1093  
00001B1A  3212                    1094  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001B1C  0201 003F               1095                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001B20  0001 00C0               1096                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
00001B24  1C01                    1097                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001B26  3212                    1098                  MOVE.W  (A2),D1         
00001B28  3412                    1099                  MOVE.W  (A2),D2 
00001B2A  0241 0E00               1100                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001B2E  163C 0009               1101                  MOVE.B  #9,D3                   * Prepare shift count
00001B32  E669                    1102                  LSR.W   D3,D1                   * Move destination register bits right
00001B34  0242 01C0               1103                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001B38  E64A                    1104                  LSR.W   #3,D2                  * Move destination mode bits right
00001B3A  8242                    1105                  OR.W    D2,D1
00001B3C  1A01                    1106                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001B3E  1206                    1107                  MOVE.B  D6,D1               * Pass source into subroutine
00001B40  4EB9 00001D02           1108                  JSR     CHECK_VALID_EA
00001B46  1205                    1109                  MOVE.B  D5,D1               * Pass destination into subroutine
00001B48  4EB9 00001D02           1110                  JSR     CHECK_VALID_EA
00001B4E  6100 01F6               1111                  BSR print_EA
00001B52  6100 0496               1112                  BSR print_NEWLINE
00001B56                          1113                  
00001B56  4E75                    1114                  RTS
00001B58                          1115  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001B58  3212                    1116  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001B5A  3412                    1117          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001B5C  0201 003F               1118          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001B60                          1119          
00001B60  0242 0E00               1120          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001B64  163C 0009               1121          MOVE.B  #9,D3                   * Prepare shift count
00001B68  E66A                    1122          LSR.W   D3,D2                   * Move register bits right
00001B6A  0202 00C7               1123          ANDI.B  #%11000111,D2           * Set EA mode
00001B6E  3612                    1124          MOVE.W  (A2),D3
00001B70  0803 0008               1125          BTST    #8,D3                   * Check opmode
00001B74  6700 000A               1126          BEQ     EA1_MODE_ZERO           * Check opmode
00001B78                          1127          
00001B78  3A01                    1128  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001B7A  3C02                    1129                  MOVE.W  D2,D6           * Set register as source
00001B7C  6000 0006               1130                  BRA EA1_END             * Complete subroutine
00001B80                          1131          
00001B80  3C01                    1132  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001B82  3A02                    1133                  MOVE.W  D2,D5           * Set register as destination
00001B84                          1134  
00001B84  0006 00C0               1135  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001B88  1206                    1136                  MOVE.B  D6,D1               * Pass source into subroutine
00001B8A  4EB9 00001D02           1137                  JSR     CHECK_VALID_EA
00001B90  1205                    1138                  MOVE.B  D5,D1               * Pass destination into subroutine
00001B92  4EB9 00001D02           1139                  JSR     CHECK_VALID_EA
00001B98  6100 01AC               1140                  BSR print_EA
00001B9C  6100 044C               1141                  BSR print_NEWLINE
00001BA0                          1142  
00001BA0  4E75                    1143                  RTS
00001BA2                          1144  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001BA2  3C12                    1145  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001BA4  0246 0E00               1146                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001BA8  163C 0009               1147                  MOVE.B  #9,D3                   * Prepare shift count
00001BAC  E66E                    1148                  LSR.W   D3,D6                   * Move register bits right
00001BAE  3612                    1149                  MOVE.W  (A2),D3
00001BB0  0803 0005               1150                  BTST    #5,D3           * Check whether shift count is immediate
00001BB4  6700 000A               1151                  BEQ     EA2_IMMEDIATE
00001BB8                          1152   
00001BB8  0006 00C0               1153  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001BBC  6000 000A               1154                  BRA     EA2_END         * Complete subroutine
00001BC0                          1155                  
00001BC0  1E3C 000A               1156  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001BC4  4EB8 1B06               1157                  JSR     FORMAT_IMMEDIATE_DATA
00001BC8                          1158                  
00001BC8  3A12                    1159  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001BCA  CA3C 0007               1160                  AND.B   #%00000111,D5
00001BCE  1206                    1161                  MOVE.B  D6,D1               * Pass source into subroutine
00001BD0  4EB9 00001D02           1162                  JSR     CHECK_VALID_EA
00001BD6  1205                    1163                  MOVE.B  D5,D1               * Pass destination into subroutine
00001BD8  4EB9 00001D02           1164                  JSR     CHECK_VALID_EA
00001BDE  6100 0166               1165                  BSR print_EA
00001BE2  6100 0406               1166                  BSR print_NEWLINE
00001BE6  4E75                    1167                  RTS   
00001BE8                          1168  
00001BE8                          1169  
00001BE8                          1170  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001BE8  3C12                    1171  EA_GROUP3     MOVE.W  (A2),D6
00001BEA  0206 003F               1172          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001BEE  0006 0080               1173          ORI.B   #%10000000,D6
00001BF2  1206                    1174          MOVE.B  D6,D1               * Pass source into subroutine
00001BF4  4EB9 00001D02           1175          JSR     CHECK_VALID_EA
00001BFA  6100 014A               1176          BSR print_EA
00001BFE  6100 03EA               1177          BSR print_NEWLINE
00001C02  4E75                    1178          RTS
00001C04                          1179  
00001C04                          1180  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001C04  3212                    1181  EA_GROUP4     MOVE.W  (A2),D1         
00001C06  0201 003F               1182          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001C0A  0001 00C0               1183          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001C0E  1C01                    1184          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001C10  3212                    1185          MOVE.W  (A2),D1         
00001C12                          1186          
00001C12  0241 0E00               1187          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001C16  143C 0009               1188          MOVE.B  #9,D2                   * Prepare shift count
00001C1A  E469                    1189          LSR.W   D2,D1                   * Move register bits right
00001C1C  0201 00CF               1190          ANDI.B  #%11001111,D1           * Set destination mode
00001C20  0001 0008               1191          ORI.B   #%00001000,D1           * Set destination mode
00001C24  1A01                    1192          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001C26  1206                    1193          MOVE.B  D6,D1               * Pass source into subroutine
00001C28  4EB9 00001D02           1194          JSR     CHECK_VALID_EA
00001C2E  1205                    1195          MOVE.B  D5,D1               * Pass destination into subroutine
00001C30  4EB9 00001D02           1196          JSR     CHECK_VALID_EA
00001C36  6100 010E               1197          BSR print_EA
00001C3A  6100 03AE               1198          BSR print_NEWLINE
00001C3E  4E75                    1199          RTS
00001C40                          1200          
00001C40  3C12                    1201  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001C42  0246 0E00               1202          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001C46  163C 0009               1203          MOVE.B  #9,D3                   * Prepare shift count
00001C4A  E66E                    1204          LSR.W   D3,D6                  * Move source data bits right            !---
00001C4C  3A12                    1205          MOVE.W  (A2),D5                 * Prepare destination bits
00001C4E  0205 003F               1206          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001C52  4EB8 1B06               1207          JSR     FORMAT_IMMEDIATE_DATA
00001C56  1206                    1208          MOVE.B  D6,D1               * Pass source into subroutine
00001C58  4EB9 00001D02           1209          JSR     CHECK_VALID_EA
00001C5E  1205                    1210          MOVE.B  D5,D1               * Pass destination into subroutine
00001C60  4EB9 00001D02           1211          JSR     CHECK_VALID_EA
00001C66  4E75                    1212          RTS                                    !---
00001C68                          1213          
00001C68  3C12                    1214  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001C6A  CC7C 00FF               1215              AND.W   #$00FF,D6                                                   !---
00001C6E  3A12                    1216              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001C70  0245 0E00               1217              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001C74  163C 0009               1218              MOVE.B  #9,D3                   * Prepare shift count
00001C78  E66D                    1219              LSR.W   D3,D5                   * Move destination register bits right
00001C7A  1E3C 000A               1220              MOVE.B  #10,D7
00001C7E  1206                    1221              MOVE.B  D6,D1               * Pass source into subroutine
00001C80  4EB9 00001D02           1222              JSR     CHECK_VALID_EA
00001C86  1205                    1223              MOVE.B  D5,D1               * Pass destination into subroutine
00001C88  4EB9 00001D02           1224              JSR     CHECK_VALID_EA
00001C8E  4E75                    1225              RTS                                 !---
00001C90                          1226  
00001C90                          1227  
00001C90                          1228  
00001C90                          1229  
00001C90  3412                    1230  MOVEM_EA   MOVE.W (A2),D2
00001C92  0802 000A               1231             BTST    #10, D2
00001C96  6700 003E               1232             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001C9A                          1233            
00001C9A                          1234             
00001C9A                          1235                  
00001C9A                          1236  *ELSE IT IS  memory-to-register transfers
00001C9A                          1237  
00001C9A                          1238  
00001C9A                          1239  
00001C9A                          1240  
00001C9A                          1241     
00001C9A  E68A                    1242  Memory_to_Register LSR.L #3, D2
00001C9C  C43C 0007               1243                     AND.B #$07, D2
00001CA0  B43C 0002               1244                     CMP.B #$2,D2
00001CA4  6700 0022               1245                     BEQ   MODE_010
00001CA8  B43C 0003               1246                     CMP.B #$03, D2
00001CAC  6700 001A               1247                     BEQ   MODE_010  
00001CB0  B43C 0007               1248                     CMP.B #$07,D2
00001CB4  6700 0012               1249                     BEQ   MODE_010  
00001CB8  4EF9 00001CBE           1250                     JMP   WRONG_INSTRUCTION    
00001CBE                          1251     
00001CBE  1E3C 0005               1252  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001CC2  2C4A                    1253                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001CC4  3C12                    1254                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001CC6  4E75                    1255                               RTS 
00001CC8                          1256             
00001CC8  3412                    1257  MODE_010  MOVE.W    (A2),D2
00001CCA  C43C 003F               1258            AND.B     #$3F,D2
00001CCE  08C2 0007               1259            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001CD2  1C02                    1260            MOVE.B    D2,D6
00001CD4  4E75                    1261            RTS
00001CD6                          1262  
00001CD6  3412                    1263  Register_to_memory MOVE.W (A2),D2
00001CD8  E68A                    1264                     LSR.L #3, D2
00001CDA  C43C 0007               1265                     AND.B #$07, D2
00001CDE  B43C 0002               1266                     CMP.B #$2,D2
00001CE2  6700 0016               1267                     BEQ   MODE_01_0
00001CE6  B43C 0004               1268                     CMP.B #$04, D2
00001CEA  6700 000E               1269                     BEQ   MODE_01_0 
00001CEE  B43C 0007               1270                     CMP.B #$07,D2
00001CF2  6700 0006               1271                     BEQ   MODE_01_0 
00001CF6  4EF8 1CBE               1272                     JMP   WRONG_INSTRUCTION
00001CFA                          1273                     
00001CFA                          1274  
00001CFA  3C12                    1275  MODE_01_0       MOVE.W  (A2),D6
00001CFC  0206 003F               1276                  ANDI.B  #$3F,D6
00001D00  4E75                    1277                  RTS
00001D02                          1278           
00001D02  1001                    1279  CHECK_VALID_EA  MOVE.B  D1,D0
00001D04  0200 0038               1280                  ANDI.B  #%111000,D0
00001D08  E648                    1281                  LSR     #3,D0
00001D0A  B03C 0005               1282                  CMP.B   #%00000101,D0
00001D0E  6700 002C               1283                  BEQ     INVALID_EA
00001D12  B03C 0006               1284                  CMP.B   #%00000110,D0
00001D16  6700 0024               1285                  BEQ     INVALID_EA
00001D1A  B03C 0007               1286                  CMP.B   #%00000111,D0
00001D1E  6700 0004               1287                  BEQ     VALID_EA_PC
00001D22  4E75                    1288                  RTS
00001D24                          1289                  
00001D24                          1290                  
00001D24  1001                    1291  VALID_EA_PC     MOVE.B  D1,D0
00001D26  0200 0007               1292                  ANDI.B  #%000111,D0
00001D2A  B03C 0010               1293                  CMP.B   #%00010000,D0
00001D2E  6700 000C               1294                  BEQ     INVALID_EA
00001D32  B03C 0018               1295                  CMP.B   #%00011000,D0
00001D36  6700 0004               1296                  BEQ     INVALID_EA
00001D3A  4E75                    1297                  RTS
00001D3C                          1298                  
00001D3C  4EB8 1CBE               1299  INVALID_EA      JSR     WRONG_INSTRUCTION
00001D40  3A7C 0005               1300                  MOVE.W  #5, A5
00001D44  4E75                    1301                  RTS
00001D46                          1302                  
00001D46  48E7 FFDE               1303  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001D4A  163C 0038               1304                  MOVE.B  #$38,D3
00001D4E  C604                    1305                  AND.B   D4,D3
00001D50  C83C 0007               1306                  AND.B   #$7, D4
00001D54                          1307                  
00001D54  B63C 0000               1308                  CMP.B   #$0, D3
00001D58  6600 0014               1309                  BNE     CHECK_EA_AR
00001D5C  0604 00D0               1310                  ADD.B   #$D0, D4
00001D60  4281                    1311                  CLR.L   D1
00001D62  1204                    1312                  MOVE.B  D4, D1
00001D64  4EB9 00001F10           1313                  JSR     PRINT_REGISTOR              * DATA REG
00001D6A  6000 0114               1314                  BRA     PRINT_EA_RETURN
00001D6E                          1315  
00001D6E  B63C 0008               1316  CHECK_EA_AR         CMP.B   #$8, D3
00001D72  6600 0014               1317                      BNE     CHECK_EA_INDIRECT
00001D76  0604 00A0               1318                      ADD.B   #$A0, D4
00001D7A  4281                    1319                      CLR.L   D1
00001D7C  1204                    1320                      MOVE.B  D4, D1
00001D7E  4EB9 00001F10           1321                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001D84  6000 00FA               1322                      BRA     PRINT_EA_RETURN
00001D88                          1323                      
00001D88  B63C 0010               1324  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001D8C  6600 0020               1325                          BNE     CHECK_EA_POST
00001D90  4EB9 00001F64           1326                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001D96  0604 00A0               1327                          ADD.B   #$A0, D4
00001D9A  4281                    1328                          CLR.L   D1
00001D9C  1204                    1329                          MOVE.B  D4, D1
00001D9E  4EB9 00001F10           1330                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001DA4  4EB9 00001F78           1331                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001DAA  6000 00D4               1332                          BRA     PRINT_EA_RETURN
00001DAE                          1333                          
00001DAE  B63C 0018               1334  CHECK_EA_POST   CMP.B   #$18,D3
00001DB2  6600 0026               1335                  BNE     CHECK_EA_PRE
00001DB6  4EB9 00001F64           1336                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001DBC  0604 00A0               1337                  ADD.B   #$A0, D4
00001DC0  4281                    1338                  CLR.L   D1
00001DC2  1204                    1339                  MOVE.B  D4, D1
00001DC4  4EB9 00001F10           1340                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001DCA  4EB9 00001F78           1341                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001DD0  4EB9 00001F90           1342                  JSR     PRINT_PLUS                  * +
00001DD6  6000 00A8               1343                  BRA     PRINT_EA_RETURN
00001DDA                          1344  
00001DDA  B63C 0020               1345  CHECK_EA_PRE        CMP.B   #$20,D3
00001DDE  6600 0026               1346                      BNE     CHECK_EA_AB_W
00001DE2  4EB9 00001FA4           1347                      JSR     PRINT_MINUS                 * -
00001DE8  4EB9 00001F64           1348                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001DEE  0604 00A0               1349                      ADD.B   #$A0, D4
00001DF2  4281                    1350                      CLR.L   D1
00001DF4  1204                    1351                      MOVE.B  D4, D1
00001DF6  4EB9 00001F10           1352                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001DFC  4EB9 00001F78           1353                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001E02  6000 007C               1354                      BRA     PRINT_EA_RETURN
00001E06                          1355  
00001E06  D604                    1356  CHECK_EA_AB_W           ADD.B   D4,D3
00001E08  B63C 0038               1357                          CMP.B   #$38,D3     
00001E0C  6600 0018               1358                          BNE     CHECK_EA_AB_L
00001E10  4EB9 00002012           1359                          JSR     PRINT_DOLLAR        * $
00001E16  3A1A                    1360                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001E18  163C 0002               1361                          MOVE.B  #2,D3
00001E1C  4EB9 00001EA8           1362                          JSR     PRINT_HEX
00001E22  6000 005C               1363                          BRA     PRINT_EA_RETURN
00001E26                          1364                          
00001E26  B63C 0039               1365  CHECK_EA_AB_L       CMP.B   #$39, D3
00001E2A  6600 0018               1366                      BNE     CHECK_EA_IMM
00001E2E  4EB9 00002012           1367                      JSR     PRINT_DOLLAR        * $
00001E34  2A1A                    1368                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001E36  163C 0004               1369                      MOVE.B  #4,D3
00001E3A  4EB9 00001EA8           1370                      JSR     PRINT_HEX
00001E40  6000 003E               1371                      BRA     PRINT_EA_RETURN
00001E44                          1372                      
00001E44  BE3C 0004               1373  CHECK_EA_IMM        CMP.B   #4,D7
00001E48  6600 001E               1374                      BNE     READ_WORD_IMM
00001E4C  4EB9 00001FFE           1375                      JSR     PRINT_HASH_SIGN     * #
00001E52  4EB9 00002012           1376                      JSR     PRINT_DOLLAR        * $
00001E58  2A1A                    1377                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001E5A  163C 0004               1378                      MOVE.B  #4,D3
00001E5E  4EB9 00001EA8           1379                      JSR     PRINT_HEX
00001E64  6000 001A               1380                      BRA     PRINT_EA_RETURN
00001E68                          1381                      
00001E68  4EB9 00001FFE           1382  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001E6E  4EB9 00002012           1383                      JSR     PRINT_DOLLAR        * $
00001E74  3A1A                    1384                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001E76  163C 0002               1385                      MOVE.B  #2,D3
00001E7A  4EB9 00001EA8           1386                      JSR     PRINT_HEX
00001E80                          1387  
00001E80  4CDF 7BFF               1388  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001E84  4E75                    1389                      RTS
00001E86                          1390  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001E86                          1391  PRINT_BUFFER    DS.B    10
00001E90= 30 30 30 30 30 30 ...   1392  IPUT_BUFFER_EX  DC.B    '00000000'
00001E98                          1393  INPUT_BUFFER    DS.B    15                    
00001EA8  48E7 FFFE               1394  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001EAC  43F8 1E86               1395                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001EB0  D3FC 0000000A           1396                  ADD.L       #10,A1
00001EB6  133C 0000               1397                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001EBA  6000 000E               1398                  BRA         POPULATE_BUFFER
00001EBE                          1399                  
00001EBE  103C 000E               1400  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001EC2  4E4F                    1401                      TRAP        #15
00001EC4  4CDF 7FFF               1402                      MOVEM.L     (SP)+,ALL_REG
00001EC8  4E75                    1403                      RTS
00001ECA                          1404                 
00001ECA  B63C 0000               1405  POPULATE_BUFFER     CMP.B       #0,D3
00001ECE  67EE                    1406                      BEQ         PRINT_HEX_RETURN
00001ED0  183C 000F               1407                      MOVE.B      #$0F,D4
00001ED4  C805                    1408                      AND.B       D5,D4
00001ED6  E81D                    1409                      ROR.B       #4,D5
00001ED8  4EB9 00001EF4           1410                      JSR         HEX_TO_ASCII
00001EDE  1304                    1411                      MOVE.B      D4,-(A1)
00001EE0  1805                    1412                      MOVE.B      D5,D4
00001EE2  C83C 000F               1413                      AND.B       #$0F,D4
00001EE6  4EB9 00001EF4           1414                      JSR         HEX_TO_ASCII
00001EEC  1304                    1415                      MOVE.B      D4,-(A1)
00001EEE  E08D                    1416                      LSR.L       #8,D5
00001EF0  5303                    1417                      SUB.B       #1,D3
00001EF2  60D6                    1418                      BRA         POPULATE_BUFFER
00001EF4                          1419  
00001EF4  48E7 E7FE               1420  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001EF8  B83C 0009               1421                          CMP.B       #9,D4
00001EFC  6F00 000C               1422                          BLE         NUMBER_TO_ASCII
00001F00  0604 0037               1423                          ADD.B       #$37,D4
00001F04  4CDF 7FE7               1424  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001F08  4E75                    1425                          RTS
00001F0A                          1426                  
00001F0A  0604 0030               1427  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001F0E  60F4                    1428                      BRA     HEX_TO_ASCII_RETURN                    
00001F10                          1429                      
00001F10  48E7 FFFE               1430  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001F14  3F3C 0000               1431                      MOVE.W      #00,-(SP)           *for printing purpose
00001F18  343C 00F0               1432                      MOVE.W      #$f0,D2             *manipulating each digit
00001F1C  C441                    1433                      AND.W       D1,D2
00001F1E  E842                    1434                      ASR.W       #4,D2
00001F20  4EB9 00001F46           1435                      JSR         TO_STRING           * converts to the string ASCII val
00001F26  E142                    1436                      ASL.W       #8,D2
00001F28                          1437                      
00001F28  C27C 000F               1438                      AND.W       #$F,D1              * the last digit
00001F2C  1401                    1439                      MOVE.B      D1,D2               
00001F2E  4EB9 00001F46           1440                      JSR         TO_STRING
00001F34  3F02                    1441                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001F36                          1442                      
00001F36  224F                    1443                      MOVE.L      SP,A1               * printing
00001F38  103C 000E               1444                      MOVE.B      #14,D0
00001F3C  4E4F                    1445                      TRAP        #15
00001F3E  2A1F                    1446                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001F40                          1447  
00001F40  4CDF 7FFF               1448  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001F44  4E75                    1449                                  RTS
00001F46                          1450                                  
00001F46  B43C 0009               1451  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001F4A  6E00 0008               1452              BGT     LETTERS     
00001F4E  0602 0030               1453              ADD.B   #$30,D2             * offseting digit
00001F52  4E75                    1454              RTS
00001F54  0602 0037               1455  LETTERS     ADD.B   #$37,D2             * offseting leter
00001F58  4E75                    1456              RTS   
00001F5A                          1457  
00001F5A                          1458  *________________________________________________________________________________________
00001F5A                          1459  
00001F5A                          1460  
00001F5A                          1461  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001F5A                          1462          *PARAMENTER     NO PARAMETER NEEDED
00001F5A= 28 00                   1463  OPEN_PAR_TAG        DC.B    '(',0  
00001F5C= 29 00                   1464  CLOSED_PAR_TAG      DC.B    ')',0
00001F5E= 23 00                   1465  HASH_SIGN_TAG       DC.B    '#',0
00001F60= 24 00                   1466  DOLLAR_TAG          DC.B    '$',0
00001F62= 2F 00                   1467  FORWARD_SLASH_TAG   DC.B    '/',0      
00001F64  48E7 FFFE               1468  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001F68  43F8 1F5A               1469                          LEA         OPEN_PAR_TAG, A1
00001F6C  103C 000E               1470                          MOVE.B      #14,D0
00001F70  4E4F                    1471                          TRAP        #15
00001F72  4CDF 7FFF               1472                          MOVEM.L     (SP)+,ALL_REG
00001F76  4E75                    1473                          RTS
00001F78                          1474  *_________________________________________________________________________________
00001F78                          1475  
00001F78                          1476  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001F78                          1477          *PARAMENTER     NO PARAMETER NEEDED
00001F78                          1478          
00001F78  48E7 FFFE               1479  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001F7C  43F8 1F5C               1480                              LEA         CLOSED_PAR_TAG, A1
00001F80  103C 000E               1481                              MOVE.B      #14,D0
00001F84  4E4F                    1482                              TRAP        #15
00001F86  4CDF 7FFF               1483                              MOVEM.L     (SP)+,ALL_REG
00001F8A  4E75                    1484                              RTS
00001F8C                          1485  *__________________________________________________________________________________
00001F8C                          1486  
00001F8C                          1487  *________________ PRINT PLUS SIGN _________________________________________________
00001F8C                          1488          *PARAMENTER     NO PARAMETER NEEDED
00001F8C= 2B 00                   1489  PLUS_TAG            DC.B    '+',0
00001F8E= 2D 00                   1490  MINUS_TAG           DC.B    '-',0        
00001F90  48E7 FFFE               1491  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001F94  43F8 1F8C               1492                  LEA         PLUS_TAG, A1
00001F98  103C 000E               1493                  MOVE.B      #14,D0
00001F9C  4E4F                    1494                  TRAP        #15
00001F9E  4CDF 7FFF               1495                  MOVEM.L     (SP)+,ALL_REG
00001FA2  4E75                    1496                  RTS
00001FA4                          1497  *_________________________________________________________________________________
00001FA4                          1498  
00001FA4                          1499  *________________ PRINT MINUS SIGN _______________________________________________
00001FA4                          1500          *PARAMENTER     NO PARAMETER NEEDED
00001FA4                          1501          
00001FA4  48E7 FFFE               1502  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001FA8  43F8 1F8E               1503                      LEA         MINUS_TAG, A1
00001FAC  103C 000E               1504                      MOVE.B      #14,D0
00001FB0  4E4F                    1505                      TRAP        #15
00001FB2  4CDF 7FFF               1506                      MOVEM.L     (SP)+,ALL_REG
00001FB6  4E75                    1507                      RTS
00001FB8                          1508  *_________________________________________________________________________________
00001FB8                          1509  
00001FB8                          1510  *________________ PRINT COMMA ____________________________________________________
00001FB8                          1511          *PARAMENTER     NO PARAMETER NEEDED
00001FB8= 09 00                   1512  TAB_TAG         DC.B    $9,0
00001FBA= 20 00                   1513  SPACE_TAG       DC.B    ' ',0
00001FBC= 2C 00                   1514  COMMA_TAG       DC.B    ',',0        
00001FBE  48E7 FFFE               1515  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001FC2  43F8 1FBC               1516                      LEA         COMMA_TAG, A1
00001FC6  103C 000E               1517                      MOVE.B      #14,D0
00001FCA  4E4F                    1518                      TRAP        #15
00001FCC  4CDF 7FFF               1519                      MOVEM.L     (SP)+,ALL_REG
00001FD0  4E75                    1520                      RTS
00001FD2                          1521  *_________________________________________________________________________________
00001FD2                          1522  
00001FD2                          1523  *________________ PRINT TAB ______________________________________________________
00001FD2                          1524          *PARAMENTER     NO PARAMETER NEEDED
00001FD2                          1525          
00001FD2  48E7 FFFE               1526  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001FD6  43F8 1FB8               1527                  LEA         TAB_TAG, A1
00001FDA  103C 000E               1528                  MOVE.B      #14,D0
00001FDE  4E4F                    1529                  TRAP        #15
00001FE0  4CDF 7FFF               1530                  MOVEM.L     (SP)+,ALL_REG
00001FE4  4E75                    1531                  RTS
00001FE6                          1532  *_________________________________________________________________________________
00001FE6                          1533  
00001FE6                          1534  
00001FE6                          1535  *_______________    PRINT NEWLINE   ________________________________________________
00001FE6                          1536          *PARAMETER NO PARAMETER NEEDED
00001FE6= 0D 0A 00                1537  NEWLINE_TAG         DC.B    CR,LF,0        
00001FEA  48E7 FFFE               1538  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001FEE  43F8 1FE6               1539                      LEA         NEWLINE_TAG, A1
00001FF2  103C 000E               1540                      MOVE.B      #14,D0
00001FF6  4E4F                    1541                      TRAP        #15
00001FF8  4CDF 7FFF               1542                      MOVEM.L     (SP)+,ALL_REG
00001FFC  4E75                    1543                      RTS
00001FFE                          1544  
00001FFE                          1545  *___________________________________________________________________________________
00001FFE                          1546  
00001FFE                          1547  
00001FFE                          1548  *_______________    PRINT HASH SIGN   ________________________________________________
00001FFE                          1549          *PARAMETER NO PARAMETER NEEDED
00001FFE                          1550          
00001FFE  48E7 FFFE               1551  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00002002  43F8 1F5E               1552                      LEA         HASH_SIGN_TAG, A1
00002006  103C 000E               1553                      MOVE.B      #14,D0
0000200A  4E4F                    1554                      TRAP        #15
0000200C  4CDF 7FFF               1555                      MOVEM.L     (SP)+,ALL_REG
00002010  4E75                    1556                      RTS
00002012                          1557  
00002012                          1558  *___________________________________________________________________________________
00002012                          1559  
00002012                          1560  
00002012                          1561  
00002012                          1562  *_______________    PRINT DOLLAR   ________________________________________________
00002012                          1563          *PARAMETER NO PARAMETER NEEDED
00002012                          1564          
00002012  48E7 FFFE               1565  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00002016  43F8 1F60               1566                      LEA         DOLLAR_TAG, A1
0000201A  103C 000E               1567                      MOVE.B      #14,D0
0000201E  4E4F                    1568                      TRAP        #15
00002020  4CDF 7FFF               1569                      MOVEM.L     (SP)+,ALL_REG
00002024  4E75                    1570                      RTS
00002026                          1571  
00002026                          1572  *___________________________________________________________________________________
00002026                          1573  
00002026                          1574  
00002026                          1575  
00002026                          1576  *_______________    PRINT FORWARD SLASH   ________________________________________________
00002026                          1577          *PARAMETER NO PARAMETER NEEDED
00002026                          1578          
00002026  48E7 FFFE               1579  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
0000202A  43F8 1F62               1580                          LEA         FORWARD_SLASH_TAG, A1
0000202E  103C 000E               1581                          MOVE.B      #14,D0
00002032  4E4F                    1582                          TRAP        #15
00002034  4CDF 7FFF               1583                          MOVEM.L     (SP)+,ALL_REG
00002038  4E75                    1584                          RTS
0000203A                          1585  
0000203A                          1586  
0000203A                          1587     
0000203A                          1588  *********************************************************************
0000203A                          1589  *Subroutine: OUTPUT
0000203A                          1590  *What it does: Outputs parts of opword, moves to new screen if needed
0000203A                          1591  *Registers: Uses register A1, D0,
0000203A                          1592  *A1: Used to store messages and single char
0000203A                          1593  *Paramemeters: A1, A2
0000203A                          1594  *A1: Stores what should be used
0000203A                          1595  *********************************************************************  
0000203A                          1596  
0000203A                          1597       OUTPUT:
0000203A                          1598       
0000203A  0C39 0001 0000241D      1599       CMP.B  #1,(OutputType)
00002042  6700 0026               1600       BEQ    outputOpcode
00002046  0C39 0002 0000241D      1601       CMP.B  #2,(OutputType)
0000204E  6700 0066               1602       BEQ    OutputSize
00002052  0C39 0003 0000241D      1603       CMP.B  #3,(OutputType)
0000205A  6700 0062               1604       BEQ    OutputData
0000205E  0C39 0004 0000241D      1605       CMP.B  #4,(OutputType)
00002066  6700 00AC               1606       BEQ    OutputAddress
0000206A                          1607       
0000206A                          1608  outputOpcode    
0000206A  0C39 001E 0000241C      1609       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00002072  6C00 0010               1610       BGE    outputOpcodeNewScreen
00002076                          1611       
00002076  103C 000E               1612       MOVE.B #14,D0
0000207A  4E4F                    1613       TRAP   #15
0000207C                          1614       
0000207C  5239 0000241C           1615       ADD.B  #1,(LineCounter)
00002082                          1616       
00002082  4E75                    1617       RTS
00002084                          1618       
00002084                          1619       
00002084                          1620  outputOpcodeNewScreen
00002084  2F09                    1621       MOVE.L A1,-(SP)                Storing last message to be used later
00002086                          1622       
00002086  43F9 000023F2           1623       LEA    OUTPUTNEWSCREEN,A1         
0000208C  103C 000E               1624       MOVE.B #14,D0
00002090  4E4F                    1625       TRAP   #15
00002092                          1626       
00002092  43F9 00008008           1627       LEA    userInputStored,A1         Pauses program to show screen full of data
00002098  103C 0002               1628       MOVE.B #2,D0
0000209C  4E4F                    1629       TRAP   #15
0000209E                          1630       
0000209E  13FC 0000 0000241C      1631       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
000020A6                          1632       
000020A6  225F                    1633       MOVE.L (SP)+,A1                Retriving message to be used
000020A8                          1634       
000020A8  103C 000E               1635       MOVE.B #14,D0                  Outputting decoded message
000020AC  4E4F                    1636       TRAP   #15
000020AE                          1637       
000020AE  5239 0000241C           1638       ADD.B  #1,(LineCounter)        Add to line counter for new screen
000020B4                          1639       
000020B4  4E75                    1640       RTS
000020B6                          1641       
000020B6                          1642  outputSize
000020B6  103C 000E               1643      MOVE.B  #14,D0
000020BA  4E4F                    1644      TRAP    #15
000020BC  4E75                    1645      RTS
000020BE                          1646  outputData
000020BE  267C 00000800           1647      MOVE.L   #$800,A3
000020C4  3692                    1648      MOVE.W  (A2),(A3)
000020C6  2F06                    1649      MOVE.L  D6,-(SP)
000020C8  103C 0000               1650      MOVE.B  #0,D0
000020CC  43F9 00009005           1651      LEA     addressOutput,A1
000020D2                          1652  
000020D2                          1653  outputDataLoop
000020D2                          1654  *check if loop has run 4 times
000020D2  B03C 0002               1655      CMP.B   #2,D0
000020D6  6700 001C               1656      BEQ     outputDataLoopEnd
000020DA                          1657      *Grab byte from address, dont increment
000020DA  1C13                    1658      MOVE.B  (A3),D6
000020DC                          1659      *LSR to isolate left bit
000020DC  E80E                    1660      LSR.B   #4,D6
000020DE                          1661      *Call converthtoa
000020DE  6100 008A               1662      BSR     CONVERTHTOA
000020E2  12C6                    1663      MOVE.B  D6,(A1)+   
000020E4                          1664      *Grab bye from address, increment
000020E4  1C1B                    1665      MOVE.B  (A3)+,D6
000020E6                          1666      *AND Mask second digit
000020E6  CC3C 000F               1667      AND.B   #$0F,D6
000020EA  6100 007E               1668      BSR     CONVERTHTOA
000020EE  12C6                    1669      MOVE.B  D6,(A1)+
000020F0  5200                    1670      ADD.B   #1,D0
000020F2  60DE                    1671      BRA     outputDataLoop
000020F4                          1672      
000020F4                          1673  outputDataLoopEnd
000020F4  12BC 0000               1674      MOVE.B  #$00,(A1)
000020F8  2C1F                    1675      MOVE.L  (SP)+,D6
000020FA  43F9 00009005           1676      LEA     addressOutput,A1
00002100  103C 000E               1677      MOVE.B  #14,D0
00002104  4E4F                    1678      TRAP    #15
00002106                          1679      
00002106  43F9 00002415           1680      LEA     NEWLINE,A1
0000210C  103C 000E               1681      MOVE.B  #14,D0
00002110  4E4F                    1682      TRAP    #15
00002112                          1683  
00002112  4E75                    1684      RTS
00002114                          1685   
00002114                          1686      
00002114                          1687  outputAddress
00002114  267C 00000800           1688      MOVE.L  #$800,A3
0000211A  268A                    1689      MOVE.L  A2,(A3)
0000211C  2F06                    1690      MOVE.L  D6,-(SP)
0000211E  103C 0000               1691      MOVE.B  #0,D0
00002122  43F9 00009005           1692      LEA     addressOutput,A1
00002128                          1693  outputAddressLoop
00002128                          1694      *check if loop has run 4 times
00002128  B03C 0004               1695      CMP.B   #4,D0
0000212C  6700 001C               1696      BEQ     outputAddressLoopEnd
00002130                          1697      *Grab byte from address, dont increment
00002130  1C13                    1698      MOVE.B  (A3),D6
00002132                          1699      *LSR to isolate left bit
00002132  E80E                    1700      LSR.B   #4,D6
00002134                          1701      *Call converthtoa
00002134  6100 0034               1702      BSR     CONVERTHTOA
00002138  12C6                    1703      MOVE.B  D6,(A1)+   
0000213A                          1704      *Grab bye from address, increment
0000213A  1C1B                    1705      MOVE.B  (A3)+,D6
0000213C                          1706      *AND Mask second digit
0000213C  CC3C 000F               1707      AND.B   #$0F,D6
00002140  6100 0028               1708      BSR     CONVERTHTOA
00002144  12C6                    1709      MOVE.B  D6,(A1)+
00002146  5200                    1710      ADD.B   #1,D0
00002148  60DE                    1711      BRA     outputAddressLoop
0000214A                          1712      
0000214A                          1713      
0000214A                          1714  outputAddressLoopEnd
0000214A  12BC 0000               1715      MOVE.B  #$00,(A1)
0000214E  2C1F                    1716      MOVE.L  (SP)+,D6
00002150  43F9 00009005           1717      LEA     addressOutput,A1
00002156                          1718      
00002156  103C 000E               1719      MOVE.B  #14,D0
0000215A  4E4F                    1720      TRAP    #15
0000215C                          1721      
0000215C  43F9 00002418           1722      LEA     spaces,A1
00002162  103C 000E               1723      MOVE.B  #14,D0
00002166  4E4F                    1724      TRAP    #15
00002168                          1725  
00002168                          1726  
00002168  4E75                    1727      RTS
0000216A                          1728  
0000216A                          1729  *********************************************************************
0000216A                          1730  *Subroutine: CONVERTHTOA
0000216A                          1731  *What it does: Converts HEX to ASCII
0000216A                          1732  *Registers: Uses register D6,D0
0000216A                          1733  *D6: Stores hex character to be converted
0000216A                          1734  *Paramemeters: D6
0000216A                          1735  *D6: Stores hex characcter to be converted
0000216A                          1736  *********************************************************************
0000216A                          1737      CONVERTHTOA:
0000216A                          1738      
0000216A  BC3C 0009               1739      CMP.B   #9,D6
0000216E  6F00 0006               1740      BLE     zerotonine
00002172  6000 000A               1741      BRA     AtoF
00002176                          1742      
00002176                          1743  zerotonine    
00002176  0686 00000030           1744      ADD.L   #$30,D6
0000217C  4E75                    1745      RTS
0000217E                          1746  AtoF
0000217E  0686 00000037           1747      ADD.L   #$37,D6
00002184  4E75                    1748      RTS
00002186                          1749      
00002186                          1750  END_SIMULATION:
00002186                          1751          
00002186  103C 0009               1752      MOVE.B  #9,D0
0000218A  4E4F                    1753      TRAP    #15
0000218C                          1754  
0000218C  FFFF FFFF               1755      SIMHALT             ; halt simulator
00002190                          1756  
00002190                          1757  * Put variables and constants here
00002190= 57 65 6C 63 6F 6D ...   1758  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
000021B6= 53 6F 6D 65 20 71 ...   1759                  DC.B    'Some quick rules:',CR,LF
000021C9= 31 29 20 4F 6E 6C ...   1760                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
00002205= 32 29 20 54 68 65 ...   1761                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
00002250= 33 29 20 41 6E 79 ...   1762                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
00002294= 20 20 20 77 69 6C ...   1763                  DC.B    '   will be rejected',CR,LF
000022A9= 34 29 20 54 68 65 ...   1764                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
000022EC= 20 20 20 77 69 6C ...   1765                  DC.B    '   will be rejected',CR,LF,0      
00002302= 50 6C 65 61 73 65 ...   1766  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
00002328= 50 6C 65 61 73 65 ...   1767  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
0000234E                          1768  
0000234E= 0D 0A 54 68 69 73 ...   1769  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
0000236C= 0D 0A 49 6E 70 75 ...   1770  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
000023A8                          1771  
000023A8= 54 6F 20 72 65 70 ...   1772  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
000023F2                          1773  
000023F2= 50 6C 65 61 73 65 ...   1774  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
00002415                          1775  
00002415= 0D 0A 00                1776  NEWLINE     DC.B    CR,LF,0
00002418= 20 20 00                1777  SPACES      DC.B    '  ',0
0000241B                          1778  
0000241B= 01                      1779  InputQuality    DC.B    1       Set to 1 for default good
0000241C= 00                      1780  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
0000241D= 00                      1781  OutputType      DC.B    0      To track what type is being output
0000241E= 00                      1782  RepeatFlag      DC.B    0
0000241F                          1783  
0000241F= 4E 4F 50 0D 0A 00       1784  nopout  DC.B    'NOP',CR,LF,0
00002425= 4D 4F 56 45 00          1785  moveout  DC.B    'MOVE',0
0000242A= 4D 4F 56 45 41 00       1786  moveaout DC.B      'MOVEA',0
00002430= 4D 4F 56 45 51 00       1787  moveqout DC.B   'MOVEQ',0
00002436= 4D 4F 56 45 4D 00       1788  movemout DC.B   'MOVEM',0
0000243C                          1789  
0000243C= 53 55 42 00             1790  subout    DC.B  'SUB',0
00002440= 41 44 44 00             1791  addout    DC.B 'ADD',0
00002444= 41 44 44 41 00          1792  addaout    DC.B 'ADDA',0
00002449= 41 44 44 51 00          1793  addqout    DC.B 'ADDQ',0
0000244E                          1794  
0000244E= 4C 45 41 00             1795  leaout    DC.B  'LEA',0
00002452                          1796  
00002452= 4E 4F 54 00             1797  notout    DC.B  'NOT',0
00002456= 4F 52 00                1798  orout DC.B     'OR',0
00002459= 41 4E 44 00             1799  andout DC.B     'AND',0
0000245D                          1800  
0000245D                          1801  
0000245D= 4C 53 4C 00             1802  lslout    DC.B  'LSL',0
00002461= 4C 53 52 00             1803  lsrout    DC.B  'LSR',0
00002465= 41 53 4C 00             1804  aslout    DC.B  'ASL',0
00002469= 41 53 52 00             1805  asrout    DC.B  'ASR',0
0000246D                          1806  
0000246D= 52 4F 4C 00             1807  rolout    DC.B  'ROL',0
00002471= 52 4F 52 00             1808  rorout    DC.B  'ROR',0
00002475                          1809  
00002475= 42 47 54 00             1810  bgtout DC.B     'BGT',0
00002479= 42 4C 45 00             1811  bleout DC.B     'BLE',0
0000247D= 42 45 51 00             1812  beqout DC.B     'BEQ',0
00002481                          1813  
00002481= 4A 53 52 00             1814  jsrout DC.B     'JSR',0
00002485= 52 54 53 0D 0A 00       1815  rtsout DC.B     'RTS',CR,LF,0
0000248B= 42 52 41 00             1816  braout DC.B     'BRA',0
0000248F                          1817  
0000248F= 44 41 54 41 20 20 ...   1818  dataout DC.B    'DATA   ',0
00002497                          1819  
00002497                          1820  
00002497                          1821  
00002497= 2E 42 20 20 20 20 00    1822  byteout  DC.B    '.B    ',0
0000249E= 2E 57 20 20 20 20 00    1823  wordout  DC.B    '.W    ',0
000024A5= 2E 4C 20 20 20 20 00    1824  longout  DC.B    '.L    ',0
000024AC= 20 20 20 20 20 20 ...   1825  nosizeout DC.B   '       ',0
000024B4                          1826  
000024B4= 0D 0A 00                1827  empty    DC.B    '',CR,LF,0
000024B7                          1828  
000024B7  =0000000D               1829  CR  EQU $0D
000024B7  =0000000A               1830  LF  EQU $0A
000024B7                          1831  
000024B7                          1832  
000024B7                          1833      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 14AA
ADDA                14F6
ADDAOUT             2444
ADDOUT              2440
ADDQ                145E
ADDQOUT             2449
ADDQ_EA             1C40
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 180C
ANDOUT              2459
ASL                 166A
ASLOUT              2465
ASR                 16B6
ASROUT              2469
ATOF                217E
ATOH                1AA6
BCC                 1858
BEQ                 18C2
BEQOUT              247D
BGT                 187E
BGTOUT              2475
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 18A0
BLEOUT              2479
BRA                 18E4
BRAOUT              248B
BYTE                12B8
BYTEOUT             2497
CHECK_EA_AB_L       1E26
CHECK_EA_AB_W       1E06
CHECK_EA_AR         1D6E
CHECK_EA_IMM        1E44
CHECK_EA_INDIRECT   1D88
CHECK_EA_POST       1DAE
CHECK_EA_PRE        1DDA
CHECK_VALID_EA      1D02
CLOSED_PAR_TAG      1F5C
COMMA_TAG           1FBC
CONVERTATOH         1AA6
CONVERTHTOA         216A
CR                  D
DATA                1906
DATAOUT             248F
DOLLAR_TAG          1F60
EA1_END             1B84
EA1_MODE_ONE        1B78
EA1_MODE_ZERO       1B80
EA2_END             1BC8
EA2_IMMEDIATE       1BC0
EA2_REGISTER        1BB8
EA_GROUP1           1B58
EA_GROUP2           1BA2
EA_GROUP3           1BE8
EA_GROUP4           1C04
EMPTY               24B4
END_SIMULATION      2186
FINISH              1AFA
FIRSTINPUT          197C
FORMAT_IMMEDIATE_DATA  1B06
FORWARD_SLASH_TAG   1F62
HASH_SIGN_TAG       1F5E
HERE                1020
HEX_TO_ASCII        1EF4
HEX_TO_ASCII_RETURN  1F04
IMMEDIATE0          1B16
IMMEDIATE_END       1B18
INPUT1              8000
INPUT1MESSAGE       2302
INPUT2              8004
INPUT2MESSAGE       2328
INPUTERROR          1AFC
INPUTERROR2SMALLER  236C
INPUTERRORBADCHAR   234E
INPUTQUALITY        241B
INPUTREPEAT         23A8
INPUT_BUFFER        1E98
INVALID_EA          1D3C
IPUT_BUFFER_EX      1E90
JSR                 1560
JSROUT              2481
LEA                 179A
LEAOUT              244E
LETSGO              1058
LETTERS             1F54
LF                  A
LINECOUNTER         241C
LONG                12E4
LONGOUT             24A5
LOWERCASE           1AE2
LSL                 15D2
LSLOUT              245D
LSR                 161E
LSROUT              2461
MEMORY_TO_REGISTER  1C9A
MINUS_TAG           1F8E
MODE_010            1CC8
MODE_01_0           1CFA
MOVE                131A
MOVEA               136C
MOVEAOUT            242A
MOVEM               13CE
MOVEMOUT            2436
MOVEM_EA            1C90
MOVEOUT             2425
MOVEQ               13A8
MOVEQOUT            2430
MOVEQ_EA            1C68
MOVE_MOVEA_EA       1B1A
NEWLINE             2415
NEWLINE_TAG         1FE6
NOP                 12FA
NOPOUT              241F
NOSIZEOUT           24AC
NOT                 1586
NOTOUT              2452
NUMBER_TO_ASCII     1F0A
ODDNUMBER1          19D6
ODDNUMBER2          1A66
OP1                 1364
OP10                1662
OP11                16AE
OP12                16FA
OP13                1746
OP14                1792
OP15                1804
OP16                1850
OP2                 13A0
OP3                 140A
OP4                 1456
OP5                 14A2
OP6                 14EE
OP7                 1532
OP8                 15CA
OP9                 1616
OPCODE              11B2
OPEN_PAR_TAG        1F5A
OR                  17C0
OROUT               2456
OUTPUT              203A
OUTPUTADDRESS       2114
OUTPUTADDRESSLOOP   2128
OUTPUTADDRESSLOOPEND  214A
OUTPUTDATA          20BE
OUTPUTDATALOOP      20D2
OUTPUTDATALOOPEND   20F4
OUTPUTNEWSCREEN     23F2
OUTPUTOPCODE        206A
OUTPUTOPCODENEWSCREEN  2084
OUTPUTSIZE          20B6
OUTPUTTYPE          241D
PLUS_TAG            1F8C
POPULATE_BUFFER     1ECA
PRINT_BUFFER        1E86
PRINT_CLOSED_PARENTHESIS  1F78
PRINT_COMMA         1FBE
PRINT_DOLLAR        2012
PRINT_EA            1D46
PRINT_EA_RETURN     1E80
PRINT_FORWARD_SLASH  2026
PRINT_HASH_SIGN     1FFE
PRINT_HEX           1EA8
PRINT_HEX_RETURN    1EBE
PRINT_MINUS         1FA4
PRINT_NEWLINE       1FEA
PRINT_OPEN_PARENTHESIS  1F64
PRINT_PLUS          1F90
PRINT_REGISTOR      1F10
PRINT_REGISTOR_RETURN  1F40
PRINT_TAB           1FD2
READ_WORD_IMM       1E68
REGISTER_TO_MEMORY  1CD6
REPEATFLAG          241E
RETURN              12B6
ROL                 1702
ROLOUT              246D
ROR                 174E
ROROUT              2471
RTS                 153A
RTSOUT              2485
SECONDINPUT         1A04
SPACES              2418
SPACE_TAG           1FBA
START               1000
STARTMESSAGE        2190
SUB                 1412
SUBOUT              243C
TAB_TAG             1FB8
THERE               1186
THROWINPUT1CHARERROR  19E4
THROWINPUT2CHARERROR  1A72
THROWINPUT2LOWERERROR  1A90
TO_STRING           1F46
UPPERCASE           1ACA
USERINPUT           1934
USERINPUTREPEAT     1188
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1D24
WELCOMEEXPLANATION  1962
WORD                12CE
WORDOUT             249E
WRONG_INSTRUCTION   1CBE
ZEROTONINE          2176
