00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 5:27:43 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 0000233E        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 0894                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 00001186             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048  6E00 000E                 42      BGT letsgo
0000104C  B67C 0004                 43      CMP #4,D3 
00001050  6700 0006                 44      BEQ letsgo
00001054  6F00 0002                 45      BLE letsgo
00001058                            46     
00001058                            47  letsgo
00001058                            48      
00001058                            49  * calls-------------------------------------------------------
00001058  347C 100C                 50      MOVE.W #$100C, A2
0000105C  6100 0154                 51      BSR     OPCODE * test MOVE.B
00001060                            52  
00001060  347C 1010                 53      MOVE.W #$1010, A2
00001064  6100 014C                 54      BSR     OPCODE * test MOVEA.W
00001068                            55      
00001068  347C 1014                 56      MOVE.W #$1014, A2
0000106C  6100 0144                 57      BSR     OPCODE * test MOVEQ
00001070                            58     
00001070  347C 1016                 59      MOVE.W #$1016, A2
00001074  6100 013C                 60      BSR     OPCODE *test MOVEA.L
00001078                            61      
00001078  347C 1018                 62      MOVE.W #$1018, A2
0000107C  6100 0134                 63      BSR     OPCODE *test DATA
00001080                            64      
00001080                            65      
00001080  347C 101A                 66      MOVE.W #$101A, A2
00001084  6100 012C                 67      BSR     OPCODE *test SUB.L
00001088                            68      
00001088  347C 101C                 69      MOVE.W #$101C, A2
0000108C  6100 0124                 70      BSR     OPCODE *test BRA
00001090                            71      
00001090  347C 1020                 72      MOVE.W #$1020, A2
00001094  6100 011C                 73      BSR     OPCODE *test JSR
00001098                            74      
00001098                            75      
00001098  43F9 000023CE             76      LEA empty,A1
0000109E  13FC 0001 0000233F        77      MOVE.B  #1,(OutputType)       
000010A6  6100 0EB4                 78      BSR    OUTPUT
000010AA                            79  
000010AA                            80      
000010AA  347C 1026                 81      MOVE.W #$1026, A2
000010AE  6100 0102                 82      BSR     OPCODE *test NOT
000010B2                            83      
000010B2  347C 1028                 84      MOVE.W #$1028, A2
000010B6  6100 00FA                 85      BSR     OPCODE *test LEA
000010BA                            86      
000010BA  347C 102A                 87      MOVE.W #$102A, A2
000010BE  6100 00F2                 88      BSR     OPCODE *test OR
000010C2                            89      
000010C2  43F9 000023CE             90       LEA empty,A1
000010C8  13FC 0001 0000233F        91      MOVE.B  #1,(OutputType)       
000010D0  6100 0E8A                 92      BSR    OUTPUT
000010D4                            93  
000010D4                            94      
000010D4  347C 1030                 95      MOVE.W #$1030, A2
000010D8  6100 00D8                 96      BSR     OPCODE *test MOVEM
000010DC                            97  
000010DC  347C 1034                 98      MOVE.W #$1034, A2
000010E0  6100 00D0                 99      BSR     OPCODE *test AND
000010E4                           100      
000010E4  347C 1036                101      MOVE.W #$1036, A2
000010E8  6100 00C8                102      BSR     OPCODE *test ADD
000010EC                           103      
000010EC  43F9 000023CE            104      LEA empty,A1
000010F2  13FC 0001 0000233F       105      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0E60                106      BSR    OUTPUT
000010FE                           107  
000010FE  347C 1038                108      MOVE.W #$1038, A2
00001102  6100 00AE                109      BSR     OPCODE *test ADDA
00001106                           110      
00001106  347C 103A                111      MOVE.W #$103A, A2
0000110A  6100 00A6                112      BSR     OPCODE *test ADDQ
0000110E                           113      
0000110E  347C 103C                114      MOVE.W #$103C, A2
00001112  6100 009E                115      BSR     OPCODE *test LSL
00001116                           116  
00001116  347C 103E                117      MOVE.W #$103E, A2
0000111A  6100 0096                118      BSR     OPCODE *test LSR
0000111E                           119      
0000111E  347C 1040                120      MOVE.W #$1040, A2
00001122  6100 008E                121      BSR     OPCODE *test ASL
00001126                           122      
00001126  43F9 000023CE            123      LEA empty,A1
0000112C  13FC 0001 0000233F       124      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0E26                125      BSR    OUTPUT
00001138                           126  
00001138                           127  
00001138  347C 1042                128      MOVE.W #$1042, A2
0000113C  6100 0074                129      BSR     OPCODE *test ASR
00001140                           130      
00001140                           131      
00001140  347C 1044                132      MOVE.W #$1044, A2
00001144  6100 006C                133      BSR     OPCODE *test ROL
00001148                           134  
00001148  347C 1046                135      MOVE.W #$1046, A2
0000114C  6100 0064                136      BSR     OPCODE *test ROR
00001150                           137      
00001150  43F9 000023CE            138      LEA empty,A1
00001156  13FC 0001 0000233F       139      MOVE.B  #1,(OutputType) * new line  
0000115E  6100 0DFC                140      BSR    OUTPUT
00001162                           141  
00001162  347C 1048                142      MOVE.W #$1048, A2
00001166  6100 004A                143      BSR     OPCODE *test BGT
0000116A                           144  
0000116A  347C 1050                145      MOVE.W #$1050, A2
0000116E  6100 0042                146      BSR     OPCODE *test BLE
00001172                           147      
00001172  347C 1054                148      MOVE.W #$1054, A2
00001176  6100 003A                149      BSR     OPCODE *test BEQ
0000117A                           150      
0000117A                           151  
0000117A                           152    
0000117A  347C 1186                153      MOVE.W #$1186, A2
0000117E  6100 0032                154      BSR     OPCODE *test RTS
00001182                           155  
00001182                           156  
00001182                           157  * calls---------------------------------------------------------    
00001182  6000 0004                158      BRA userInputRepeat
00001186                           159  there    
00001186  4E75                     160      RTS
00001188                           161  * end testing--------------------------------------------------------------
00001188                           162   
00001188                           163  
00001188                           164       
00001188                           165    
00001188                           166  
00001188                           167      
00001188                           168  userInputRepeat
00001188  43F9 000022CA            169      LEA     INPUTREPEAT,A1
0000118E  103C 000E                170      MOVE.B  #14,D0
00001192  4E4F                     171      TRAP    #15
00001194  5239 0000233E            172      ADD.B   #1,(LineCounter)
0000119A                           173      
0000119A  43F9 00008008            174      LEA     userInputStored,A1
000011A0  103C 0005                175      MOVE.B  #5,D0
000011A4  4E4F                     176      TRAP    #15
000011A6                           177      
000011A6  B23C 000D                178      CMP.B   #$0D,D1
000011AA  6700 FE5C                179      BEQ     userInputStart
000011AE                           180   
000011AE  FFFF FFFF                181      SIMHALT
000011B2                           182  
000011B2                           183  **********************************************************
000011B2                           184  *Subroutine: OPCODE
000011B2                           185  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B2                           186  *Registers: 
000011B2                           187  *A1: printing
000011B2                           188  *A2: parameter with instruction address
000011B2                           189  *D0: printing
000011B2                           190  *D3: used for determing the instruction, mostly shifts
000011B2                           191  *D2: used for determing the size
000011B2                           192  *Paramemeters: A2 the memory address to decode from
000011B2                           193  **********************************************************
000011B2                           194  OPCODE:
000011B2  4243                     195      CLR D3
000011B4                           196      
000011B4  0C52 4E75                197      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011B8  6700 0344                198      BEQ rts
000011BC                           199      
000011BC  0C52 4E71                200      CMP #$4E71, (A2) *NOP compare
000011C0  6700 0134                201      BEQ nop
000011C4                           202      
000011C4  3612                     203      Move.W (A2), D3 
000011C6  E04B                     204      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011C8  E84B                     205      LSR #4,D3
000011CA                           206      
000011CA                           207      
000011CA  B67C 0008                208      CMP #%1000, D3 * OR compare
000011CE  6700 056E                209      BEQ or
000011D2                           210      
000011D2                           211      
000011D2  B67C 0003                212      CMP #%0011, D3 *MOVE and MOVEA compare
000011D6  6F00 0140                213      BLE move
000011DA                           214      
000011DA  B67C 0007                215      CMP #%0111, D3 *MOVEQ compare
000011DE  6700 01BA                216      BEQ moveq
000011E2                           217      
000011E2  B67C 0009                218      CMP #%1001, D3 *SUB compare
000011E6  6700 0212                219      BEQ sub
000011EA                           220      
000011EA  B67C 000C                221      CMP #%1100, D3 *AND compare
000011EE  6700 0590                222      BEQ and
000011F2                           223      
000011F2  B67C 0005                224      CMP #%0101, D3 *ADDQ compare
000011F6  6700 0244                225      BEQ addq
000011FA                           226      
000011FA  B67C 0006                227      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
000011FE  6700 05C2                228      BEQ bcc
00001202                           229      
00001202                           230  
00001202  3612                     231      Move.W (A2), D3 * reset D3
00001204  0243 F118                232      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
00001208  B67C E108                233      CMP #%1110000100001000,D3 * LSL compare
0000120C  6700 037E                234      BEQ lsl
00001210                           235  
00001210  3612                     236      Move.W (A2), D3 * reset D3
00001212  0243 F118                237      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
00001216  B67C E008                238      CMP #%1110000000001000,D3 * LSR compare
0000121A  6700 03B2                239      BEQ lsr
0000121E                           240      
0000121E                           241      
0000121E  3612                     242      Move.W (A2), D3 * reset D3
00001220  0243 F118                243      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001224  B67C E100                244      CMP #%1110000100000000,D3 * ASL compare
00001228  6700 03E6                245      BEQ asl
0000122C                           246  
0000122C  3612                     247      Move.W (A2), D3 * reset D3
0000122E  0243 F118                248      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001232  B67C E000                249      CMP #%1110000000000000,D3 * ASR compare
00001236  6700 041A                250      BEQ asr
0000123A                           251  
0000123A  3612                     252      Move.W (A2), D3 * reset D3
0000123C  0243 F118                253      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001240  B67C E118                254      CMP #%1110000100011000,D3 * ROL compare
00001244  6700 044E                255      BEQ rol
00001248                           256  
00001248  3612                     257      Move.W (A2), D3 * reset D3
0000124A  0243 F118                258      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000124E  B67C E018                259      CMP #%1110000000011000,D3 * ROR compare
00001252  6700 0482                260      BEQ ror
00001256                           261  
00001256                           262      
00001256                           263      
00001256  3612                     264      Move.W (A2), D3 * reset D3
00001258  0243 F0C0                265      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000125C  B67C D0C0                266      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001260  6700 025E                267      BEQ adda
00001264                           268      
00001264  3612                     269      Move.W (A2), D3 
00001266  E04B                     270      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001268  E84B                     271      LSR #4,D3
0000126A  B67C 000D                272      CMP #%1101, D3 *ADD compare
0000126E  6700 020E                273      BEQ add
00001272                           274  
00001272                           275    
00001272  3612                     276      Move.W (A2), D3 * reset D3
00001274  0243 FB80                277      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001278  B67C 4880                278      CMP #%0100100010000000,D3 * MOVEM compare
0000127C  6700 0142                279      BEQ movem
00001280                           280  
00001280                           281      
00001280                           282      
00001280  3612                     283      Move.W (A2), D3 * reset D3
00001282  EC4B                     284      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001284  B67C 013A                285      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001288  6700 029A                286      BEQ jsr
0000128C                           287  
0000128C  3612                     288      Move.W (A2), D3 * reset D3
0000128E  E04B                     289      LSR #8,D3 * make D3 only contain the first 8 bits
00001290  B67C 0046                290      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001294  6700 02B4                291      BEQ not
00001298                           292      
00001298  3612                     293      Move.W (A2), D3 * reset D3
0000129A  0243 F1C0                294      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000129E  B67C 41C0                295      CMP #%0100000111000000,D3 *LEA compare
000012A2  6700 0474                296      BEQ lea
000012A6                           297      
000012A6                           298      
000012A6                           299      
000012A6                           300      
000012A6                           301      
000012A6                           302  
000012A6                           303  
000012A6                           304     
000012A6  3612                     305      Move.W (A2), D3 * reset D3
000012A8  E04B                     306      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012AA  B67C 0060                307      CMP #%01100000, D3 *BRA compare
000012AE  6700 059E                308      BEQ bra
000012B2                           309      
000012B2                           310      
000012B2  6000 05BC                311      BRA data
000012B6                           312      
000012B6                           313  return
000012B6  4E75                     314      RTS
000012B8                           315  byte
000012B8  43F9 000023B9            316      LEA    byteout,A1        
000012BE  13FC 0002 0000233F       317      MOVE.B  #2,(OutputType)
000012C6  6100 0C94                318      BSR     OUTPUT 
000012CA  4E75                     319      RTS
000012CC                           320  word
000012CC  43F9 000023C0            321      LEA    wordout,A1        
000012D2  13FC 0002 0000233F       322      MOVE.B  #2,(OutputType)
000012DA  6100 0C80                323      BSR     OUTPUT
000012DE  4E75                     324      RTS
000012E0                           325  long
000012E0  43F9 000023C7            326      LEA    longout,A1        
000012E6  13FC 0002 0000233F       327      MOVE.B  #2,(OutputType)
000012EE  6100 0C6C                328      BSR     OUTPUT 
000012F2  60C2                     329      BRA return
000012F4  4E75                     330      RTS
000012F6                           331  nop 
000012F6  13FC 0004 0000233F       332      MOVE.B  #4,(OutputType)
000012FE  6100 0C5C                333      BSR     OUTPUT
00001302  43F9 00002341            334      LEA    nopout,A1        
00001308  13FC 0001 0000233F       335      MOVE.B  #1,(OutputType)
00001310  6100 0C4A                336      BSR     OUTPUT
00001314  60A0                     337      BRA return
00001316  4E75                     338      RTS
00001318                           339      
00001318                           340  move
00001318                           341      * put the size of the instruction into D2 to use later
00001318                           342      * since the first two bits of D3 are 00 for move moving the entire word works
00001318  3403                     343      Move.W D3, D2
0000131A                           344  
0000131A                           345  
0000131A                           346      * determine if MOVE or MOVEA
0000131A                           347      * if bits 8,7,6 = 001 its MOVEA
0000131A  3612                     348      MOVE.W (A2),D3
0000131C  0243 01C0                349      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
00001320                           350      
00001320  B67C 0040                351      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001324  6700 003E                352      BEQ movea
00001328                           353      
00001328  13FC 0004 0000233F       354      MOVE.B  #4,(OutputType)
00001330  6100 0C2A                355      BSR     OUTPUT
00001334                           356  
00001334  43F9 00002347            357      LEA    moveout,A1     *print the type
0000133A  13FC 0001 0000233F       358      MOVE.B  #1,(OutputType)   
00001342  6100 0C18                359      BSR    OUTPUT
00001346                           360      
00001346                           361      *now to print size  
00001346  B47C 0002                362      cmp #2,D2 *if the size is 2 branch to long
0000134A  6794                     363      BEQ long
0000134C  B47C 0003                364      cmp #3,D2 *if the size is 3 branch to word
00001350  6700 FF7A                365      BEQ word
00001354  B47C 0001                366      cmp #1,D2 * if the size is 1 branch to byte
00001358  6700 FF5E                367      BEQ byte
0000135C                           368    
0000135C  6100 06DE                369      BSR MOVE_MOVEA_EA
00001360                           370      
00001360  6000 FF54                371      BRA return
00001364                           372      
00001364                           373      
00001364                           374  movea
00001364  13FC 0004 0000233F       375      MOVE.B  #4,(OutputType)
0000136C  6100 0BEE                376      BSR     OUTPUT
00001370                           377  
00001370  43F9 0000234C            378      LEA    moveaout,A1
00001376  13FC 0001 0000233F       379      MOVE.B  #1,(OutputType)       
0000137E  6100 0BDC                380      BSR    OUTPUT
00001382                           381      
00001382                           382      *now to print size  
00001382  B47C 0002                383      cmp #2,D2 *if the size is 2 branch to long
00001386  6700 FF58                384      BEQ long
0000138A  B47C 0003                385      cmp #3,D2 *if the size is 3 branch to word
0000138E  6700 FF3C                386      BEQ word
00001392                           387      
00001392  6100 06A8                388      BSR MOVE_MOVEA_EA
00001396                           389      
00001396  6000 FF1E                390      BRA return
0000139A                           391      
0000139A                           392  moveq
0000139A  13FC 0004 0000233F       393      MOVE.B  #4,(OutputType)
000013A2  6100 0BB8                394      BSR     OUTPUT
000013A6                           395  
000013A6  43F9 00002352            396      LEA    moveqout,A1
000013AC  13FC 0001 0000233F       397      MOVE.B  #1,(OutputType)       
000013B4  6100 0BA6                398      BSR    OUTPUT
000013B8  6100 07D0                399      BSR MOVEQ_EA
000013BC  6000 FEF8                400      BRA return
000013C0                           401  
000013C0                           402      
000013C0                           403  movem
000013C0  13FC 0004 0000233F       404      MOVE.B  #4,(OutputType)
000013C8  6100 0B92                405      BSR     OUTPUT
000013CC                           406      
000013CC  43F9 00002358            407      LEA    movemout,A1
000013D2  13FC 0001 0000233F       408      MOVE.B  #1,(OutputType)       
000013DA  6100 0B80                409      BSR    OUTPUT
000013DE                           410      
000013DE  3412                     411      MOVE.W (A2),D2
000013E0  0242 0040                412      ANDI.W #%0000000001000000, D2 * set to only the size bits
000013E4  EC4A                     413      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000013E6  B47C 0001                414      CMP #1, D2 * if the size is 1 branch to long
000013EA  6700 FEF4                415      BEQ long
000013EE  6100 FEDC                416      BSR word * otherwise branch to word
000013F2  6100 07BE                417      BSR MOVEM_EA
000013F6                           418      
000013F6  6000 FEBE                419      BRA return
000013FA                           420  sub 
000013FA  13FC 0004 0000233F       421      MOVE.B  #4,(OutputType)
00001402  6100 0B58                422      BSR     OUTPUT
00001406                           423     
00001406  43F9 0000235E            424      LEA    subout,A1
0000140C  13FC 0001 0000233F       425      MOVE.B  #1,(OutputType)       
00001414  6100 0B46                426      BSR    OUTPUT
00001418                           427      
00001418  3412                     428      MOVE.W (A2),D2
0000141A  0242 00C0                429      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000141E  EC4A                     430      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001420                           431  
00001420                           432  
00001420                           433      
00001420                           434      *now to print size  
00001420  B47C 0002                435      cmp #2,D2 *if the size is 2 branch to long
00001424  6700 FEBA                436      BEQ long
00001428  B47C 0001                437      cmp #1,D2 *if the size is 1 branch to word
0000142C  6700 FE9E                438      BEQ word
00001430  6100 FE86                439      BSR byte *otherwise branch to byte
00001434  6100 0644                440      BSR EA_GROUP1
00001438  6000 FE7C                441      BRA return
0000143C                           442      
0000143C                           443  addq 
0000143C  13FC 0004 0000233F       444      MOVE.B  #4,(OutputType)
00001444  6100 0B16                445      BSR     OUTPUT
00001448                           446     
00001448  43F9 0000236B            447      LEA    addqout,A1
0000144E  13FC 0001 0000233F       448      MOVE.B  #1,(OutputType)       
00001456  6100 0B04                449      BSR    OUTPUT
0000145A                           450      
0000145A  3412                     451      MOVE.W (A2),D2
0000145C  0242 00C0                452      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001460  EC4A                     453      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001462                           454  
00001462                           455  
00001462                           456      
00001462                           457      *now to print size  
00001462  B47C 0002                458      cmp #2,D2 *if the size is 2 branch to long
00001466  6700 FE78                459      BEQ long
0000146A  B47C 0001                460      cmp #1,D2 *if the size is 1 branch to word
0000146E  6700 FE5C                461      BEQ word
00001472  6100 FE44                462      BSR byte *otherwise branch to byte
00001476  6100 06EA                463          BSR ADDQ_EA
0000147A                           464  
0000147A  6000 FE3A                465      BRA return    
0000147E                           466      
0000147E                           467      
0000147E                           468  add
0000147E  13FC 0004 0000233F       469      MOVE.B  #4,(OutputType)
00001486  6100 0AD4                470      BSR     OUTPUT
0000148A                           471  
0000148A  43F9 00002362            472      LEA    addout,A1
00001490  13FC 0001 0000233F       473      MOVE.B  #1,(OutputType)       
00001498  6100 0AC2                474      BSR    OUTPUT
0000149C                           475      
0000149C  3412                     476      MOVE.W (A2),D2
0000149E  0242 00C0                477      ANDI.W #%0000000011000000, D2 * set to only the size bits
000014A2  EC4A                     478      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000014A4                           479  
000014A4                           480  
000014A4                           481      
000014A4                           482      *now to print size  
000014A4  B47C 0002                483      cmp #2,D2 *if the size is 2 branch to long
000014A8  6700 FE36                484      BEQ long
000014AC  B47C 0001                485      cmp #1,D2 *if the size is 1 branch to word
000014B0  6700 FE1A                486      BEQ word
000014B4  6100 FE02                487      BSR byte *otherwise branch to byte
000014B8  6100 05C0                488          BSR EA_GROUP1
000014BC                           489  
000014BC  6000 FDF8                490      BRA return
000014C0                           491  
000014C0                           492  adda
000014C0                           493  
000014C0  13FC 0004 0000233F       494      MOVE.B  #4,(OutputType)
000014C8  6100 0A92                495      BSR     OUTPUT
000014CC                           496  
000014CC  43F9 00002366            497      LEA    addaout,A1
000014D2  13FC 0001 0000233F       498      MOVE.B  #1,(OutputType)       
000014DA  6100 0A80                499      BSR    OUTPUT
000014DE                           500      
000014DE  3412                     501      MOVE.W (A2),D2
000014E0  0242 0100                502      ANDI.W #%0000000100000000, D2 * set to only the size bit
000014E4  E04A                     503      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
000014E6                           504  
000014E6                           505  
000014E6                           506      
000014E6                           507      *now to print size  
000014E6  B47C 0001                508      cmp #1,D2 *if the size is 1 branch to long
000014EA  6700 FDF4                509      BEQ long
000014EE  B47C 0000                510      cmp #0,D2 *if the size is 0 branch to word
000014F2  6700 FDD8                511      BEQ word
000014F6  6100 062E                512          BSR EA_GROUP4
000014FA                           513     
000014FA  6000 FDBA                514      BRA return
000014FE                           515  
000014FE                           516      
000014FE                           517  rts
000014FE  13FC 0004 0000233F       518      MOVE.B  #4,(OutputType)
00001506  6100 0A54                519      BSR     OUTPUT
0000150A                           520  
0000150A  43F9 000023A7            521      LEA    rtsout,A1
00001510  13FC 0001 0000233F       522      MOVE.B  #1,(OutputType)       
00001518  6100 0A42                523      BSR    OUTPUT
0000151C  6100 05A6                524          BSR EA_GROUP2
00001520                           525  
00001520  6000 FD94                526      BRA return
00001524                           527      
00001524                           528      
00001524                           529  jsr 
00001524  13FC 0004 0000233F       530      MOVE.B  #4,(OutputType)
0000152C  6100 0A2E                531      BSR     OUTPUT
00001530                           532     
00001530  43F9 000023A3            533      LEA    jsrout,A1
00001536  13FC 0001 0000233F       534      MOVE.B  #1,(OutputType)       
0000153E  6100 0A1C                535      BSR    OUTPUT
00001542  6100 0580                536          BSR EA_GROUP2
00001546                           537  
00001546  6000 FD6E                538      BRA return
0000154A                           539      
0000154A                           540      
0000154A                           541  not 
0000154A  13FC 0004 0000233F       542      MOVE.B  #4,(OutputType)
00001552  6100 0A08                543      BSR     OUTPUT
00001556                           544    
00001556  43F9 00002374            545      LEA    notout,A1
0000155C  13FC 0001 0000233F       546      MOVE.B  #1,(OutputType)       
00001564  6100 09F6                547      BSR    OUTPUT
00001568                           548      
00001568  3412                     549      MOVE.W (A2),D2
0000156A  0242 00C0                550      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000156E  EC4A                     551      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001570                           552  
00001570                           553      *now to print size  
00001570  B47C 0002                554      cmp #2,D2 *if the size is 2 branch to long
00001574  6700 FD6A                555      BEQ long
00001578  B47C 0001                556      cmp #1,D2 *if the size is 1 branch to word
0000157C  6700 FD4E                557      BEQ word
00001580  6100 FD36                558      BSR byte *otherwise branch to byte
00001584                           559      
00001584  6100 0584                560      BSR EA_GROUP3
00001588                           561      
00001588  6000 FD2C                562      BRA return
0000158C                           563  
0000158C                           564  lsl
0000158C  13FC 0004 0000233F       565      MOVE.B  #4,(OutputType)
00001594  6100 09C6                566      BSR     OUTPUT
00001598                           567  
00001598  43F9 0000237F            568      LEA    lslout,A1
0000159E  13FC 0001 0000233F       569      MOVE.B  #1,(OutputType)       
000015A6  6100 09B4                570      BSR    OUTPUT
000015AA                           571      
000015AA  3412                     572      MOVE.W (A2),D2
000015AC  0242 00C0                573      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015B0  EC4A                     574      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015B2                           575  
000015B2                           576  
000015B2                           577      
000015B2                           578      *now to print size  
000015B2  B47C 0002                579      cmp #2,D2 *if the size is 2 branch to long
000015B6  6700 FD28                580      BEQ long
000015BA  B47C 0001                581      cmp #1,D2 *if the size is 1 branch to word
000015BE  6700 FD0C                582      BEQ word
000015C2  6100 FCF4                583      BSR byte *otherwise branch to byte
000015C6  6100 04FC                584          BSR EA_GROUP2
000015CA                           585  
000015CA  6000 FCEA                586      BRA return
000015CE                           587  
000015CE                           588  lsr
000015CE  13FC 0004 0000233F       589      MOVE.B  #4,(OutputType)
000015D6  6100 0984                590      BSR     OUTPUT
000015DA                           591  
000015DA  43F9 00002383            592      LEA    lsrout,A1
000015E0  13FC 0001 0000233F       593      MOVE.B  #1,(OutputType)       
000015E8  6100 0972                594      BSR    OUTPUT
000015EC                           595      
000015EC  3412                     596      MOVE.W (A2),D2
000015EE  0242 00C0                597      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015F2  EC4A                     598      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015F4                           599  
000015F4                           600  
000015F4                           601      
000015F4                           602      *now to print size  
000015F4  B47C 0002                603      cmp #2,D2 *if the size is 2 branch to long
000015F8  6700 FCE6                604      BEQ long
000015FC  B47C 0001                605      cmp #1,D2 *if the size is 1 branch to word
00001600  6700 FCCA                606      BEQ word
00001604  6100 FCB2                607      BSR byte *otherwise branch to byte
00001608  6100 04BA                608          BSR EA_GROUP2
0000160C                           609  
0000160C  6000 FCA8                610      BRA return
00001610                           611  asl
00001610  13FC 0004 0000233F       612      MOVE.B  #4,(OutputType)
00001618  6100 0942                613      BSR     OUTPUT
0000161C                           614  
0000161C  43F9 00002387            615      LEA    aslout,A1
00001622  13FC 0001 0000233F       616      MOVE.B  #1,(OutputType)       
0000162A  6100 0930                617      BSR    OUTPUT
0000162E                           618      
0000162E  3412                     619      MOVE.W (A2),D2
00001630  0242 00C0                620      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001634  EC4A                     621      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001636                           622  
00001636                           623  
00001636                           624      
00001636                           625      *now to print size  
00001636  B47C 0002                626      cmp #2,D2 *if the size is 2 branch to long
0000163A  6700 FCA4                627      BEQ long
0000163E  B47C 0001                628      cmp #1,D2 *if the size is 1 branch to word
00001642  6700 FC88                629      BEQ word
00001646  6100 FC70                630      BSR byte *otherwise branch to byte
0000164A  6100 0478                631          BSR EA_GROUP2
0000164E                           632  
0000164E  6000 FC66                633      BRA return
00001652                           634  
00001652                           635  asr
00001652  13FC 0004 0000233F       636      MOVE.B  #4,(OutputType)
0000165A  6100 0900                637      BSR     OUTPUT
0000165E                           638  
0000165E  43F9 0000238B            639      LEA    asrout,A1
00001664  13FC 0001 0000233F       640      MOVE.B  #1,(OutputType)       
0000166C  6100 08EE                641      BSR    OUTPUT
00001670                           642      
00001670  3412                     643      MOVE.W (A2),D2
00001672  0242 00C0                644      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001676  EC4A                     645      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001678                           646  
00001678                           647  
00001678                           648      
00001678                           649      *now to print size  
00001678  B47C 0002                650      cmp #2,D2 *if the size is 2 branch to long
0000167C  6700 FC62                651      BEQ long
00001680  B47C 0001                652      cmp #1,D2 *if the size is 1 branch to word
00001684  6700 FC46                653      BEQ word
00001688  6100 FC2E                654      BSR byte *otherwise branch to byte
0000168C  6100 0436                655          BSR EA_GROUP2
00001690                           656  
00001690  6000 FC24                657      BRA return
00001694                           658      
00001694                           659  rol
00001694  13FC 0004 0000233F       660      MOVE.B  #4,(OutputType)
0000169C  6100 08BE                661      BSR     OUTPUT
000016A0                           662  
000016A0  43F9 0000238F            663      LEA    rolout,A1
000016A6  13FC 0001 0000233F       664      MOVE.B  #1,(OutputType)       
000016AE  6100 08AC                665      BSR    OUTPUT
000016B2                           666      
000016B2  3412                     667      MOVE.W (A2),D2
000016B4  0242 00C0                668      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016B8  EC4A                     669      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016BA                           670  
000016BA                           671  
000016BA                           672      
000016BA                           673      *now to print size  
000016BA  B47C 0002                674      cmp #2,D2 *if the size is 2 branch to long
000016BE  6700 FC20                675      BEQ long
000016C2  B47C 0001                676      cmp #1,D2 *if the size is 1 branch to word
000016C6  6700 FC04                677      BEQ word
000016CA  6100 FBEC                678      BSR byte *otherwise branch to byte
000016CE  6100 03F4                679          BSR EA_GROUP2
000016D2                           680  
000016D2  6000 FBE2                681      BRA return
000016D6                           682  
000016D6                           683  ror
000016D6  13FC 0004 0000233F       684      MOVE.B  #4,(OutputType)
000016DE  6100 087C                685      BSR     OUTPUT
000016E2                           686  
000016E2  43F9 00002393            687      LEA    rorout,A1
000016E8  13FC 0001 0000233F       688      MOVE.B  #1,(OutputType)       
000016F0  6100 086A                689      BSR    OUTPUT
000016F4                           690      
000016F4  3412                     691      MOVE.W (A2),D2
000016F6  0242 00C0                692      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016FA  EC4A                     693      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016FC                           694  
000016FC                           695  
000016FC                           696      
000016FC                           697      *now to print size  
000016FC  B47C 0002                698      cmp #2,D2 *if the size is 2 branch to long
00001700  6700 FBDE                699      BEQ long
00001704  B47C 0001                700      cmp #1,D2 *if the size is 1 branch to word
00001708  6700 FBC2                701      BEQ word
0000170C  6100 FBAA                702      BSR byte *otherwise branch to byte
00001710  6100 03B2                703          BSR EA_GROUP2
00001714                           704  
00001714  6000 FBA0                705      BRA return
00001718                           706      
00001718                           707      
00001718                           708  
00001718                           709  lea
00001718  13FC 0004 0000233F       710      MOVE.B  #4,(OutputType)
00001720  6100 083A                711      BSR     OUTPUT
00001724                           712  
00001724  43F9 00002370            713      LEA    leaout,A1
0000172A  13FC 0001 0000233F       714      MOVE.B  #1,(OutputType)       
00001732  6100 0828                715      BSR    OUTPUT
00001736  6100 03EE                716          BSR EA_GROUP4
0000173A                           717  
0000173A  6000 FB7A                718      BRA return
0000173E                           719      
0000173E                           720  or
0000173E  13FC 0004 0000233F       721      MOVE.B  #4,(OutputType)
00001746  6100 0814                722      BSR     OUTPUT
0000174A                           723  
0000174A  43F9 00002378            724      LEA    orout,A1
00001750  13FC 0001 0000233F       725      MOVE.B  #1,(OutputType)       
00001758  6100 0802                726      BSR    OUTPUT
0000175C                           727      
0000175C                           728          
0000175C  3412                     729      MOVE.W (A2),D2
0000175E  0242 00C0                730      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001762  EC4A                     731      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001764                           732  
00001764                           733      *now to print size  
00001764  B47C 0002                734      cmp #2,D2 *if the size is 2 branch to long
00001768  6700 FB76                735      BEQ long
0000176C  B47C 0001                736      cmp #1,D2 *if the size is 1 branch to word
00001770  6700 FB5A                737      BEQ word
00001774  6100 FB42                738      BSR byte *otherwise branch to byte
00001778  6100 0300                739      BSR EA_GROUP1
0000177C  6000 FB38                740      BRA return
00001780                           741      
00001780                           742  and
00001780  13FC 0004 0000233F       743      MOVE.B  #4,(OutputType)
00001788  6100 07D2                744      BSR     OUTPUT
0000178C                           745  
0000178C  43F9 0000237B            746      LEA    andout,A1
00001792  13FC 0001 0000233F       747      MOVE.B  #1,(OutputType)       
0000179A  6100 07C0                748      BSR    OUTPUT
0000179E                           749      
0000179E                           750          
0000179E  3412                     751      MOVE.W (A2),D2
000017A0  0242 00C0                752      ANDI.W #%0000000011000000, D2 * set to only the size bits
000017A4  EC4A                     753      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000017A6                           754  
000017A6                           755      *now to print size  
000017A6  B47C 0002                756      cmp #2,D2 *if the size is 2 branch to long
000017AA  6700 FB34                757      BEQ long
000017AE  B47C 0001                758      cmp #1,D2 *if the size is 1 branch to word
000017B2  6700 FB18                759      BEQ word
000017B6  6100 FB00                760      BSR byte *otherwise branch to byte
000017BA  6100 02BE                761      BSR EA_GROUP1
000017BE  6000 FAF6                762      BRA return    
000017C2                           763  
000017C2                           764  bcc
000017C2  4243                     765      CLR D3
000017C4  3612                     766      MOVE.W (A2), D3
000017C6                           767      
000017C6  0243 0F00                768      ANDI.W #%0000111100000000,D3 * bits [11-8]
000017CA  E04B                     769      LSR.W #8,D3
000017CC  B67C 000E                770      CMP #%1110, D3 * BGT compare
000017D0  6700 0016                771      BEQ bgt
000017D4  B67C 000F                772      CMP #%1111, D3 * BLE compare
000017D8  6700 0030                773      BEQ ble
000017DC  B67C 0007                774      CMP #%0111, D3 * BEQ compare
000017E0  6700 004A                775      BEQ beq
000017E4  6000 008A                776      BRA data * goto data if doesn't work
000017E8                           777  
000017E8                           778  bgt
000017E8  13FC 0004 0000233F       779      MOVE.B  #4,(OutputType)
000017F0  6100 076A                780      BSR     OUTPUT
000017F4                           781  
000017F4  43F9 00002397            782      LEA    bgtout,A1
000017FA  13FC 0001 0000233F       783      MOVE.B  #1,(OutputType)       
00001802  6100 0758                784      BSR    OUTPUT
00001806  6000 FAAE                785      BRA return
0000180A                           786  
0000180A                           787  ble
0000180A  13FC 0004 0000233F       788      MOVE.B  #4,(OutputType)
00001812  6100 0748                789      BSR     OUTPUT
00001816                           790  
00001816  43F9 0000239B            791      LEA    bleout,A1
0000181C  13FC 0001 0000233F       792      MOVE.B  #1,(OutputType)       
00001824  6100 0736                793      BSR    OUTPUT
00001828  6000 FA8C                794      BRA return
0000182C                           795  beq
0000182C  13FC 0004 0000233F       796      MOVE.B  #4,(OutputType)
00001834  6100 0726                797      BSR     OUTPUT
00001838                           798  
00001838  43F9 0000239F            799      LEA    beqout,A1
0000183E  13FC 0001 0000233F       800      MOVE.B  #1,(OutputType)       
00001846  6100 0714                801      BSR    OUTPUT
0000184A  6000 FA6A                802      BRA return
0000184E                           803  
0000184E                           804  bra
0000184E  13FC 0004 0000233F       805      MOVE.B  #4,(OutputType)
00001856  6100 0704                806      BSR     OUTPUT
0000185A                           807  
0000185A  43F9 000023AD            808      LEA    braout,A1
00001860  13FC 0001 0000233F       809      MOVE.B  #1,(OutputType)       
00001868  6100 06F2                810      BSR    OUTPUT
0000186C  6000 FA48                811      BRA return
00001870                           812  
00001870                           813  data
00001870  13FC 0004 0000233F       814      MOVE.B  #4,(OutputType)
00001878  6100 06E2                815      BSR     OUTPUT
0000187C                           816  
0000187C  43F9 000023B1            817      LEA    dataout,A1
00001882  13FC 0001 0000233F       818      MOVE.B  #1,(OutputType)       
0000188A  6100 06D0                819      BSR    OUTPUT
0000188E                           820      
0000188E  13FC 0003 0000233F       821      MOVE.B  #3,(OutputType)       
00001896  6100 06C4                822      BSR    OUTPUT     
0000189A  6000 FA1A                823      BRA return
0000189E                           824  
0000189E                           825  
0000189E                           826  **********************************************************
0000189E                           827  *Subroutine: USERINPUT
0000189E                           828  *What it does: Takes in user input, rejects bad input
0000189E                           829  *Registers: Uses register A1, D0, D5
0000189E                           830  *A1: Stores messages and user input
0000189E                           831  *D0: Used for TRAP #15
0000189E                           832  *D5: Temporaraly stores user input to be masked then transfered
0000189E                           833  *Paramemeters: No parameters
0000189E                           834  **********************************************************
0000189E                           835  USERINPUT:
0000189E  4281                     836      CLR.L   D1
000018A0  4282                     837      CLR.L   D2
000018A2  4283                     838      CLR.L   D3
000018A4  4284                     839      CLR.L   D4
000018A6  4285                     840      CLR.L   D5
000018A8  0C39 0000 00002340       841      CMP.B   #0,(RepeatFlag)
000018B0  6700 001A                842      BEQ     welcomeExplanation
000018B4  6000 0030                843      BRA     firstInput
000018B8  02B9 00000000 00008000   844      AND.L   #$00000000,(Input1)
000018C2  02B9 00000000 00008004   845      AND.L   #$00000000,(Input2)
000018CC                           846      
000018CC                           847  welcomeExplanation
000018CC  43F9 000020B2            848      LEA     STARTMESSAGE,A1         
000018D2  103C 000E                849      MOVE.B  #14,D0
000018D6  4E4F                     850      TRAP    #15
000018D8                           851      
000018D8  5039 0000233E            852      ADD.B   #8,(LineCounter)
000018DE  13FC 0001 00002340       853      MOVE.B  #1,(RepeatFlag)
000018E6                           854  
000018E6                           855  firstInput
000018E6  43F9 00002224            856      LEA     INPUT1MESSAGE,A1        
000018EC  103C 000E                857      MOVE.B  #14,D0                  
000018F0  4E4F                     858      TRAP    #15                     Asks user for first input
000018F2  5239 0000233E            859      ADD.B   #1,(LineCounter)        Adds 1 to line counter
000018F8                           860      
000018F8  43F9 00008008            861      LEA     userInputStored,A1
000018FE  103C 0002                862      MOVE.B  #2,D0                   
00001902  4E4F                     863      TRAP    #15                     User can input string for address
00001904  5239 0000233E            864      ADD.B   #1,(LineCounter)        Adds 1 to line counter
0000190A                           865  
0000190A                           866      
0000190A  6100 00BC                867      BSR     CONVERTATOH                 String converted to hex address
0000190E                           868      
0000190E  0C39 0000 0000233D       869      CMP.B   #0,(InputQuality)       Checks if bad input flag set
00001916  6700 0014                870      BEQ     throwInput1CharError
0000191A                           871  
0000191A                           872      
0000191A  CABC 00FFFFFF            873      AND.L   #$00FFFFFF,D5
00001920  23C5 00008000            874      MOVE.L  D5,input1               Moves result into input 1 memory location
00001926  4285                     875      CLR.L   D5                      Clears D5 for future use
00001928  6000 0020                876      BRA     secondInput
0000192C                           877      
0000192C                           878  throwInput1CharError
0000192C  43F9 00002270            879      LEA     INPUTERRORBADCHAR,A1
00001932  103C 000E                880      MOVE.B  #14,D0
00001936  4E4F                     881      TRAP    #15                     Outputs bad character error message
00001938  5639 0000233E            882      ADD.B   #3,(LineCounter)        Adds 2 to line counter
0000193E                           883      
0000193E  13FC 0001 0000233D       884      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
00001946  4285                     885      CLR.L   D5                      Clears D5 for future use
00001948                           886      
00001948                           887      
00001948                           888      
00001948  609C                     889      BRA     firstInput              Tries again for input1
0000194A                           890  
0000194A                           891      
0000194A                           892  secondInput
0000194A  43F9 0000224A            893      LEA     INPUT2MESSAGE,A1        
00001950  103C 000E                894      MOVE.B  #14,D0                  
00001954  4E4F                     895      TRAP    #15                     Asks user for second input
00001956  5239 0000233E            896      ADD.B   #1,(LineCounter)
0000195C                           897      
0000195C  43F9 00008008            898      LEA     userInputStored,A1
00001962  103C 0002                899      MOVE.B  #2,D0                   
00001966  4E4F                     900      TRAP    #15                     User can input string for address
00001968  5239 0000233E            901      ADD.B   #1,(LineCounter)
0000196E                           902  
0000196E                           903      
0000196E  6100 0058                904      BSR     CONVERTATOH                 String converted to hex address
00001972                           905  
00001972  0C39 0000 0000233D       906      CMP.B   #0,(InputQuality)       
0000197A  6700 001C                907      BEQ     throwInput2CharError    Checks if bad input flag set
0000197E                           908      
0000197E  CABC 00FFFFFF            909      AND.L   #$00FFFFFF,D5
00001984  BAB9 00008000            910      CMP.L   (input1),D5
0000198A  6D00 0028                911      BLT     throwInput2LowerError
0000198E                           912      
0000198E                           913      
0000198E                           914      
0000198E  23C5 00008004            915      MOVE.L  D5,input2               Moves result into input 2 memory location
00001994  4285                     916      CLR.L   D5                      Clears D5 for future use
00001996  4E75                     917      RTS    
00001998                           918      
00001998                           919  throwInput2CharError
00001998  43F9 00002270            920      LEA     INPUTERRORBADCHAR,A1    
0000199E  103C 000E                921      MOVE.B  #14,D0
000019A2  4E4F                     922      TRAP    #15                     Outputs bad character error message
000019A4                           923      
000019A4  5639 0000233D            924      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
000019AA  4285                     925      CLR.L   D5                      Clears D5 for future use
000019AC                           926      
000019AC  5639 0000233E            927      ADD.B   #3,(LineCounter)
000019B2                           928      
000019B2  6096                     929      BRA     secondInput             Tries again for input2
000019B4                           930      
000019B4                           931  throwInput2LowerError
000019B4  43F9 0000228E            932      LEA     INPUTERROR2SMALLER,A1
000019BA  103C 000E                933      MOVE.B  #14,D0
000019BE  4E4F                     934      TRAP    #15
000019C0                           935      
000019C0  5639 0000233E            936      ADD.B   #3,(LineCounter)
000019C6                           937      
000019C6  6082                     938      BRA     secondInput
000019C8                           939  
000019C8                           940  
000019C8                           941  **********************************************************
000019C8                           942  *Subroutine: CONVERTATOH
000019C8                           943  *What it does: Converts user input to hex code
000019C8                           944  *Registers: Uses register A1, D2, D5
000019C8                           945  *Paramemeters: User input stored in (A1)
000019C8                           946  ********************************************************** 
000019C8                           947  CONVERTATOH:
000019C8                           948      
000019C8                           949  AtoH
000019C8  1419                     950      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
000019CA                           951      
000019CA  B43C 0000                952      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
000019CE  6700 004C                953      BEQ     Finish                  Moves to finish if they are equal (no more input)
000019D2                           954      
000019D2  E985                     955      ASL.L   #4,D5
000019D4                           956      
000019D4  B43C 0030                957      CMP.B   #$30,D2
000019D8  6D00 0044                958      BLT     inputError
000019DC                           959      
000019DC  B43C 0039                960      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
000019E0  6E00 000A                961      BGT     upperCase               Branches if greater, may or may not be a letter in hex
000019E4                           962      
000019E4  0402 0030                963      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
000019E8  DA02                     964      ADD.B   D2,D5
000019EA                           965      
000019EA  60DC                     966      BRA     AtoH
000019EC                           967  
000019EC                           968          
000019EC                           969  upperCase   
000019EC  B43C 0041                970      CMP.B   #$41,D2
000019F0  6D00 002C                971      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
000019F4                           972      
000019F4  B43C 0046                973      CMP.B   #$46,D2                 
000019F8  6E00 000A                974      BGT     lowerCase               Greater than 46 may be hex code in lowercase
000019FC                           975      
000019FC  0402 0037                976      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
00001A00  DA02                     977      ADD.B   D2,D5
00001A02  60C4                     978      BRA     AtoH
00001A04                           979  
00001A04                           980  lowerCase
00001A04  B43C 0061                981      CMP.B   #$61,D2
00001A08  6D00 0014                982      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001A0C                           983      
00001A0C  B43C 0066                984      CMP.B   #$66,D2
00001A10  6E00 000C                985      BGT     InputError              Greater than 66 is not part of hex code
00001A14                           986      
00001A14  0402 0057                987      SUBI.B  #$57,D2
00001A18  DA02                     988      ADD.B   D2,D5
00001A1A  60AC                     989      BRA     AtoH
00001A1C                           990          
00001A1C                           991  Finish
00001A1C  4E75                     992      RTS                             Return from CONVERT
00001A1E                           993      
00001A1E                           994  inputError
00001A1E  13FC 0000 0000233D       995      MOVE.B  #0,(InputQuality)
00001A26  4E75                     996      RTS
00001A28                           997  
00001A28                           998  *********************************************************************
00001A28                           999  *Subroutine: EA
00001A28                          1000  *What it does: Outputs parts of opword, moves to new screen if needed
00001A28                          1001  *Registers: Uses register A1, D0,
00001A28                          1002  *A1: Used to store messages and single char
00001A28                          1003  *Paramemeters: A1
00001A28                          1004  *A1: Stores what should be used--++
00001A28                          1005  *********************************************************************  
00001A28  =0000003F               1006  BITS0TO5_MASK   EQU %00111111
00001A28  =000000C0               1007  BITS7TO8_MASK   EQU %11000000
00001A28  =00000E00               1008  BITS9TO11_MASK  EQU %00000111000000000
00001A28                          1009  
00001A28  1E3C 000A               1010  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001A2C  BC7C 0000               1011                          CMP     #0,D6
00001A30  6700 0006               1012                          BEQ     IMMEDIATE0
00001A34  6000 0004               1013                          BRA     IMMEDIATE_END
00001A38  7C08                    1014  IMMEDIATE0              MOVEQ   #8,D6
00001A3A                          1015  
00001A3A  4E75                    1016  IMMEDIATE_END           RTS
00001A3C                          1017  
00001A3C  3212                    1018  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001A3E  0201 003F               1019                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001A42  0001 00C0               1020                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
00001A46  1C01                    1021                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001A48  3212                    1022                  MOVE.W  (A2),D1         
00001A4A  3412                    1023                  MOVE.W  (A2),D2 
00001A4C  0241 0E00               1024                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001A50  163C 0009               1025                  MOVE.B  #9,D3                   * Prepare shift count
00001A54  E669                    1026                  LSR.W   D3,D1                   * Move destination register bits right
00001A56  0242 01C0               1027                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001A5A  E64A                    1028                  LSR.W   #3,D2                  * Move destination mode bits right
00001A5C  8242                    1029                  OR.W    D2,D1
00001A5E  1A01                    1030                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001A60  1206                    1031                  MOVE.B  D6,D1               * Pass source into subroutine
00001A62  4EB9 00001C24           1032                  JSR     CHECK_VALID_EA
00001A68  1205                    1033                  MOVE.B  D5,D1               * Pass destination into subroutine
00001A6A  4EB9 00001C24           1034                  JSR     CHECK_VALID_EA
00001A70  6100 01F6               1035                  BSR print_EA
00001A74  6100 0496               1036                  BSR print_NEWLINE
00001A78                          1037                  
00001A78  4E75                    1038                  RTS
00001A7A                          1039  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001A7A  3212                    1040  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001A7C  3412                    1041          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001A7E  0201 003F               1042          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001A82                          1043          
00001A82  0242 0E00               1044          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001A86  163C 0009               1045          MOVE.B  #9,D3                   * Prepare shift count
00001A8A  E66A                    1046          LSR.W   D3,D2                   * Move register bits right
00001A8C  0202 00C7               1047          ANDI.B  #%11000111,D2           * Set EA mode
00001A90  3612                    1048          MOVE.W  (A2),D3
00001A92  0803 0008               1049          BTST    #8,D3                   * Check opmode
00001A96  6700 000A               1050          BEQ     EA1_MODE_ZERO           * Check opmode
00001A9A                          1051          
00001A9A  3A01                    1052  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001A9C  3C02                    1053                  MOVE.W  D2,D6           * Set register as source
00001A9E  6000 0006               1054                  BRA EA1_END             * Complete subroutine
00001AA2                          1055          
00001AA2  3C01                    1056  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001AA4  3A02                    1057                  MOVE.W  D2,D5           * Set register as destination
00001AA6                          1058  
00001AA6  0006 00C0               1059  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001AAA  1206                    1060                  MOVE.B  D6,D1               * Pass source into subroutine
00001AAC  4EB9 00001C24           1061                  JSR     CHECK_VALID_EA
00001AB2  1205                    1062                  MOVE.B  D5,D1               * Pass destination into subroutine
00001AB4  4EB9 00001C24           1063                  JSR     CHECK_VALID_EA
00001ABA  6100 01AC               1064                  BSR print_EA
00001ABE  6100 044C               1065                  BSR print_NEWLINE
00001AC2                          1066  
00001AC2  4E75                    1067                  RTS
00001AC4                          1068  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001AC4  3C12                    1069  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001AC6  0246 0E00               1070                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001ACA  163C 0009               1071                  MOVE.B  #9,D3                   * Prepare shift count
00001ACE  E66E                    1072                  LSR.W   D3,D6                   * Move register bits right
00001AD0  3612                    1073                  MOVE.W  (A2),D3
00001AD2  0803 0005               1074                  BTST    #5,D3           * Check whether shift count is immediate
00001AD6  6700 000A               1075                  BEQ     EA2_IMMEDIATE
00001ADA                          1076   
00001ADA  0006 00C0               1077  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001ADE  6000 000A               1078                  BRA     EA2_END         * Complete subroutine
00001AE2                          1079                  
00001AE2  1E3C 000A               1080  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001AE6  4EB8 1A28               1081                  JSR     FORMAT_IMMEDIATE_DATA
00001AEA                          1082                  
00001AEA  3A12                    1083  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001AEC  CA3C 0007               1084                  AND.B   #%00000111,D5
00001AF0  1206                    1085                  MOVE.B  D6,D1               * Pass source into subroutine
00001AF2  4EB9 00001C24           1086                  JSR     CHECK_VALID_EA
00001AF8  1205                    1087                  MOVE.B  D5,D1               * Pass destination into subroutine
00001AFA  4EB9 00001C24           1088                  JSR     CHECK_VALID_EA
00001B00  6100 0166               1089                  BSR print_EA
00001B04  6100 0406               1090                  BSR print_NEWLINE
00001B08  4E75                    1091                  RTS   
00001B0A                          1092  
00001B0A                          1093  
00001B0A                          1094  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001B0A  3C12                    1095  EA_GROUP3     MOVE.W  (A2),D6
00001B0C  0206 003F               1096          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001B10  0006 0080               1097          ORI.B   #%10000000,D6
00001B14  1206                    1098          MOVE.B  D6,D1               * Pass source into subroutine
00001B16  4EB9 00001C24           1099          JSR     CHECK_VALID_EA
00001B1C  6100 014A               1100          BSR print_EA
00001B20  6100 03EA               1101          BSR print_NEWLINE
00001B24  4E75                    1102          RTS
00001B26                          1103  
00001B26                          1104  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001B26  3212                    1105  EA_GROUP4     MOVE.W  (A2),D1         
00001B28  0201 003F               1106          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001B2C  0001 00C0               1107          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001B30  1C01                    1108          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001B32  3212                    1109          MOVE.W  (A2),D1         
00001B34                          1110          
00001B34  0241 0E00               1111          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001B38  143C 0009               1112          MOVE.B  #9,D2                   * Prepare shift count
00001B3C  E469                    1113          LSR.W   D2,D1                   * Move register bits right
00001B3E  0201 00CF               1114          ANDI.B  #%11001111,D1           * Set destination mode
00001B42  0001 0008               1115          ORI.B   #%00001000,D1           * Set destination mode
00001B46  1A01                    1116          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001B48  1206                    1117          MOVE.B  D6,D1               * Pass source into subroutine
00001B4A  4EB9 00001C24           1118          JSR     CHECK_VALID_EA
00001B50  1205                    1119          MOVE.B  D5,D1               * Pass destination into subroutine
00001B52  4EB9 00001C24           1120          JSR     CHECK_VALID_EA
00001B58  6100 010E               1121          BSR print_EA
00001B5C  6100 03AE               1122          BSR print_NEWLINE
00001B60  4E75                    1123          RTS
00001B62                          1124          
00001B62  3C12                    1125  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001B64  0246 0E00               1126          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001B68  163C 0009               1127          MOVE.B  #9,D3                   * Prepare shift count
00001B6C  E66E                    1128          LSR.W   D3,D6                  * Move source data bits right            !---
00001B6E  3A12                    1129          MOVE.W  (A2),D5                 * Prepare destination bits
00001B70  0205 003F               1130          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001B74  4EB8 1A28               1131          JSR     FORMAT_IMMEDIATE_DATA
00001B78  1206                    1132          MOVE.B  D6,D1               * Pass source into subroutine
00001B7A  4EB9 00001C24           1133          JSR     CHECK_VALID_EA
00001B80  1205                    1134          MOVE.B  D5,D1               * Pass destination into subroutine
00001B82  4EB9 00001C24           1135          JSR     CHECK_VALID_EA
00001B88  4E75                    1136          RTS                                    !---
00001B8A                          1137          
00001B8A  3C12                    1138  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001B8C  CC7C 00FF               1139              AND.W   #$00FF,D6                                                   !---
00001B90  3A12                    1140              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001B92  0245 0E00               1141              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001B96  163C 0009               1142              MOVE.B  #9,D3                   * Prepare shift count
00001B9A  E66D                    1143              LSR.W   D3,D5                   * Move destination register bits right
00001B9C  1E3C 000A               1144              MOVE.B  #10,D7
00001BA0  1206                    1145              MOVE.B  D6,D1               * Pass source into subroutine
00001BA2  4EB9 00001C24           1146              JSR     CHECK_VALID_EA
00001BA8  1205                    1147              MOVE.B  D5,D1               * Pass destination into subroutine
00001BAA  4EB9 00001C24           1148              JSR     CHECK_VALID_EA
00001BB0  4E75                    1149              RTS                                 !---
00001BB2                          1150  
00001BB2                          1151  
00001BB2                          1152  
00001BB2                          1153  
00001BB2  3412                    1154  MOVEM_EA   MOVE.W (A2),D2
00001BB4  0802 000A               1155             BTST    #10, D2
00001BB8  6700 003E               1156             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001BBC                          1157            
00001BBC                          1158             
00001BBC                          1159                  
00001BBC                          1160  *ELSE IT IS  memory-to-register transfers
00001BBC                          1161  
00001BBC                          1162  
00001BBC                          1163  
00001BBC                          1164  
00001BBC                          1165     
00001BBC  E68A                    1166  Memory_to_Register LSR.L #3, D2
00001BBE  C43C 0007               1167                     AND.B #$07, D2
00001BC2  B43C 0002               1168                     CMP.B #$2,D2
00001BC6  6700 0022               1169                     BEQ   MODE_010
00001BCA  B43C 0003               1170                     CMP.B #$03, D2
00001BCE  6700 001A               1171                     BEQ   MODE_010  
00001BD2  B43C 0007               1172                     CMP.B #$07,D2
00001BD6  6700 0012               1173                     BEQ   MODE_010  
00001BDA  4EF9 00001BE0           1174                     JMP   WRONG_INSTRUCTION    
00001BE0                          1175     
00001BE0  1E3C 0005               1176  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001BE4  2C4A                    1177                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001BE6  3C12                    1178                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001BE8  4E75                    1179                               RTS 
00001BEA                          1180             
00001BEA  3412                    1181  MODE_010  MOVE.W    (A2),D2
00001BEC  C43C 003F               1182            AND.B     #$3F,D2
00001BF0  08C2 0007               1183            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001BF4  1C02                    1184            MOVE.B    D2,D6
00001BF6  4E75                    1185            RTS
00001BF8                          1186  
00001BF8  3412                    1187  Register_to_memory MOVE.W (A2),D2
00001BFA  E68A                    1188                     LSR.L #3, D2
00001BFC  C43C 0007               1189                     AND.B #$07, D2
00001C00  B43C 0002               1190                     CMP.B #$2,D2
00001C04  6700 0016               1191                     BEQ   MODE_01_0
00001C08  B43C 0004               1192                     CMP.B #$04, D2
00001C0C  6700 000E               1193                     BEQ   MODE_01_0 
00001C10  B43C 0007               1194                     CMP.B #$07,D2
00001C14  6700 0006               1195                     BEQ   MODE_01_0 
00001C18  4EF8 1BE0               1196                     JMP   WRONG_INSTRUCTION
00001C1C                          1197                     
00001C1C                          1198  
00001C1C  3C12                    1199  MODE_01_0       MOVE.W  (A2),D6
00001C1E  0206 003F               1200                  ANDI.B  #$3F,D6
00001C22  4E75                    1201                  RTS
00001C24                          1202           
00001C24  1001                    1203  CHECK_VALID_EA  MOVE.B  D1,D0
00001C26  0200 0038               1204                  ANDI.B  #%111000,D0
00001C2A  E648                    1205                  LSR     #3,D0
00001C2C  B03C 0005               1206                  CMP.B   #%00000101,D0
00001C30  6700 002C               1207                  BEQ     INVALID_EA
00001C34  B03C 0006               1208                  CMP.B   #%00000110,D0
00001C38  6700 0024               1209                  BEQ     INVALID_EA
00001C3C  B03C 0007               1210                  CMP.B   #%00000111,D0
00001C40  6700 0004               1211                  BEQ     VALID_EA_PC
00001C44  4E75                    1212                  RTS
00001C46                          1213                  
00001C46                          1214                  
00001C46  1001                    1215  VALID_EA_PC     MOVE.B  D1,D0
00001C48  0200 0007               1216                  ANDI.B  #%000111,D0
00001C4C  B03C 0010               1217                  CMP.B   #%00010000,D0
00001C50  6700 000C               1218                  BEQ     INVALID_EA
00001C54  B03C 0018               1219                  CMP.B   #%00011000,D0
00001C58  6700 0004               1220                  BEQ     INVALID_EA
00001C5C  4E75                    1221                  RTS
00001C5E                          1222                  
00001C5E  4EB8 1BE0               1223  INVALID_EA      JSR     WRONG_INSTRUCTION
00001C62  3A7C 0005               1224                  MOVE.W  #5, A5
00001C66  4E75                    1225                  RTS
00001C68                          1226                  
00001C68  48E7 FFDE               1227  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001C6C  163C 0038               1228                  MOVE.B  #$38,D3
00001C70  C604                    1229                  AND.B   D4,D3
00001C72  C83C 0007               1230                  AND.B   #$7, D4
00001C76                          1231                  
00001C76  B63C 0000               1232                  CMP.B   #$0, D3
00001C7A  6600 0014               1233                  BNE     CHECK_EA_AR
00001C7E  0604 00D0               1234                  ADD.B   #$D0, D4
00001C82  4281                    1235                  CLR.L   D1
00001C84  1204                    1236                  MOVE.B  D4, D1
00001C86  4EB9 00001E32           1237                  JSR     PRINT_REGISTOR              * DATA REG
00001C8C  6000 0114               1238                  BRA     PRINT_EA_RETURN
00001C90                          1239  
00001C90  B63C 0008               1240  CHECK_EA_AR         CMP.B   #$8, D3
00001C94  6600 0014               1241                      BNE     CHECK_EA_INDIRECT
00001C98  0604 00A0               1242                      ADD.B   #$A0, D4
00001C9C  4281                    1243                      CLR.L   D1
00001C9E  1204                    1244                      MOVE.B  D4, D1
00001CA0  4EB9 00001E32           1245                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001CA6  6000 00FA               1246                      BRA     PRINT_EA_RETURN
00001CAA                          1247                      
00001CAA  B63C 0010               1248  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001CAE  6600 0020               1249                          BNE     CHECK_EA_POST
00001CB2  4EB9 00001E86           1250                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001CB8  0604 00A0               1251                          ADD.B   #$A0, D4
00001CBC  4281                    1252                          CLR.L   D1
00001CBE  1204                    1253                          MOVE.B  D4, D1
00001CC0  4EB9 00001E32           1254                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001CC6  4EB9 00001E9A           1255                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001CCC  6000 00D4               1256                          BRA     PRINT_EA_RETURN
00001CD0                          1257                          
00001CD0  B63C 0018               1258  CHECK_EA_POST   CMP.B   #$18,D3
00001CD4  6600 0026               1259                  BNE     CHECK_EA_PRE
00001CD8  4EB9 00001E86           1260                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001CDE  0604 00A0               1261                  ADD.B   #$A0, D4
00001CE2  4281                    1262                  CLR.L   D1
00001CE4  1204                    1263                  MOVE.B  D4, D1
00001CE6  4EB9 00001E32           1264                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001CEC  4EB9 00001E9A           1265                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001CF2  4EB9 00001EB2           1266                  JSR     PRINT_PLUS                  * +
00001CF8  6000 00A8               1267                  BRA     PRINT_EA_RETURN
00001CFC                          1268  
00001CFC  B63C 0020               1269  CHECK_EA_PRE        CMP.B   #$20,D3
00001D00  6600 0026               1270                      BNE     CHECK_EA_AB_W
00001D04  4EB9 00001EC6           1271                      JSR     PRINT_MINUS                 * -
00001D0A  4EB9 00001E86           1272                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001D10  0604 00A0               1273                      ADD.B   #$A0, D4
00001D14  4281                    1274                      CLR.L   D1
00001D16  1204                    1275                      MOVE.B  D4, D1
00001D18  4EB9 00001E32           1276                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001D1E  4EB9 00001E9A           1277                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001D24  6000 007C               1278                      BRA     PRINT_EA_RETURN
00001D28                          1279  
00001D28  D604                    1280  CHECK_EA_AB_W           ADD.B   D4,D3
00001D2A  B63C 0038               1281                          CMP.B   #$38,D3     
00001D2E  6600 0018               1282                          BNE     CHECK_EA_AB_L
00001D32  4EB9 00001F34           1283                          JSR     PRINT_DOLLAR        * $
00001D38  3A1A                    1284                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001D3A  163C 0002               1285                          MOVE.B  #2,D3
00001D3E  4EB9 00001DCA           1286                          JSR     PRINT_HEX
00001D44  6000 005C               1287                          BRA     PRINT_EA_RETURN
00001D48                          1288                          
00001D48  B63C 0039               1289  CHECK_EA_AB_L       CMP.B   #$39, D3
00001D4C  6600 0018               1290                      BNE     CHECK_EA_IMM
00001D50  4EB9 00001F34           1291                      JSR     PRINT_DOLLAR        * $
00001D56  2A1A                    1292                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001D58  163C 0004               1293                      MOVE.B  #4,D3
00001D5C  4EB9 00001DCA           1294                      JSR     PRINT_HEX
00001D62  6000 003E               1295                      BRA     PRINT_EA_RETURN
00001D66                          1296                      
00001D66  BE3C 0004               1297  CHECK_EA_IMM        CMP.B   #4,D7
00001D6A  6600 001E               1298                      BNE     READ_WORD_IMM
00001D6E  4EB9 00001F20           1299                      JSR     PRINT_HASH_SIGN     * #
00001D74  4EB9 00001F34           1300                      JSR     PRINT_DOLLAR        * $
00001D7A  2A1A                    1301                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001D7C  163C 0004               1302                      MOVE.B  #4,D3
00001D80  4EB9 00001DCA           1303                      JSR     PRINT_HEX
00001D86  6000 001A               1304                      BRA     PRINT_EA_RETURN
00001D8A                          1305                      
00001D8A  4EB9 00001F20           1306  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001D90  4EB9 00001F34           1307                      JSR     PRINT_DOLLAR        * $
00001D96  3A1A                    1308                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001D98  163C 0002               1309                      MOVE.B  #2,D3
00001D9C  4EB9 00001DCA           1310                      JSR     PRINT_HEX
00001DA2                          1311  
00001DA2  4CDF 7BFF               1312  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001DA6  4E75                    1313                      RTS
00001DA8                          1314  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001DA8                          1315  PRINT_BUFFER    DS.B    10
00001DB2= 30 30 30 30 30 30 ...   1316  IPUT_BUFFER_EX  DC.B    '00000000'
00001DBA                          1317  INPUT_BUFFER    DS.B    15                    
00001DCA  48E7 FFFE               1318  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001DCE  43F8 1DA8               1319                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001DD2  D3FC 0000000A           1320                  ADD.L       #10,A1
00001DD8  133C 0000               1321                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001DDC  6000 000E               1322                  BRA         POPULATE_BUFFER
00001DE0                          1323                  
00001DE0  103C 000E               1324  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001DE4  4E4F                    1325                      TRAP        #15
00001DE6  4CDF 7FFF               1326                      MOVEM.L     (SP)+,ALL_REG
00001DEA  4E75                    1327                      RTS
00001DEC                          1328                 
00001DEC  B63C 0000               1329  POPULATE_BUFFER     CMP.B       #0,D3
00001DF0  67EE                    1330                      BEQ         PRINT_HEX_RETURN
00001DF2  183C 000F               1331                      MOVE.B      #$0F,D4
00001DF6  C805                    1332                      AND.B       D5,D4
00001DF8  E81D                    1333                      ROR.B       #4,D5
00001DFA  4EB9 00001E16           1334                      JSR         HEX_TO_ASCII
00001E00  1304                    1335                      MOVE.B      D4,-(A1)
00001E02  1805                    1336                      MOVE.B      D5,D4
00001E04  C83C 000F               1337                      AND.B       #$0F,D4
00001E08  4EB9 00001E16           1338                      JSR         HEX_TO_ASCII
00001E0E  1304                    1339                      MOVE.B      D4,-(A1)
00001E10  E08D                    1340                      LSR.L       #8,D5
00001E12  5303                    1341                      SUB.B       #1,D3
00001E14  60D6                    1342                      BRA         POPULATE_BUFFER
00001E16                          1343  
00001E16  48E7 E7FE               1344  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001E1A  B83C 0009               1345                          CMP.B       #9,D4
00001E1E  6F00 000C               1346                          BLE         NUMBER_TO_ASCII
00001E22  0604 0037               1347                          ADD.B       #$37,D4
00001E26  4CDF 7FE7               1348  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001E2A  4E75                    1349                          RTS
00001E2C                          1350                  
00001E2C  0604 0030               1351  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001E30  60F4                    1352                      BRA     HEX_TO_ASCII_RETURN                    
00001E32                          1353                      
00001E32  48E7 FFFE               1354  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001E36  3F3C 0000               1355                      MOVE.W      #00,-(SP)           *for printing purpose
00001E3A  343C 00F0               1356                      MOVE.W      #$f0,D2             *manipulating each digit
00001E3E  C441                    1357                      AND.W       D1,D2
00001E40  E842                    1358                      ASR.W       #4,D2
00001E42  4EB9 00001E68           1359                      JSR         TO_STRING           * converts to the string ASCII val
00001E48  E142                    1360                      ASL.W       #8,D2
00001E4A                          1361                      
00001E4A  C27C 000F               1362                      AND.W       #$F,D1              * the last digit
00001E4E  1401                    1363                      MOVE.B      D1,D2               
00001E50  4EB9 00001E68           1364                      JSR         TO_STRING
00001E56  3F02                    1365                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001E58                          1366                      
00001E58  224F                    1367                      MOVE.L      SP,A1               * printing
00001E5A  103C 000E               1368                      MOVE.B      #14,D0
00001E5E  4E4F                    1369                      TRAP        #15
00001E60  2A1F                    1370                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001E62                          1371  
00001E62  4CDF 7FFF               1372  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001E66  4E75                    1373                                  RTS
00001E68                          1374                                  
00001E68  B43C 0009               1375  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001E6C  6E00 0008               1376              BGT     LETTERS     
00001E70  0602 0030               1377              ADD.B   #$30,D2             * offseting digit
00001E74  4E75                    1378              RTS
00001E76  0602 0037               1379  LETTERS     ADD.B   #$37,D2             * offseting leter
00001E7A  4E75                    1380              RTS   
00001E7C                          1381  
00001E7C                          1382  *________________________________________________________________________________________
00001E7C                          1383  
00001E7C                          1384  
00001E7C                          1385  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001E7C                          1386          *PARAMENTER     NO PARAMETER NEEDED
00001E7C= 28 00                   1387  OPEN_PAR_TAG        DC.B    '(',0  
00001E7E= 29 00                   1388  CLOSED_PAR_TAG      DC.B    ')',0
00001E80= 23 00                   1389  HASH_SIGN_TAG       DC.B    '#',0
00001E82= 24 00                   1390  DOLLAR_TAG          DC.B    '$',0
00001E84= 2F 00                   1391  FORWARD_SLASH_TAG   DC.B    '/',0      
00001E86  48E7 FFFE               1392  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001E8A  43F8 1E7C               1393                          LEA         OPEN_PAR_TAG, A1
00001E8E  103C 000E               1394                          MOVE.B      #14,D0
00001E92  4E4F                    1395                          TRAP        #15
00001E94  4CDF 7FFF               1396                          MOVEM.L     (SP)+,ALL_REG
00001E98  4E75                    1397                          RTS
00001E9A                          1398  *_________________________________________________________________________________
00001E9A                          1399  
00001E9A                          1400  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001E9A                          1401          *PARAMENTER     NO PARAMETER NEEDED
00001E9A                          1402          
00001E9A  48E7 FFFE               1403  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001E9E  43F8 1E7E               1404                              LEA         CLOSED_PAR_TAG, A1
00001EA2  103C 000E               1405                              MOVE.B      #14,D0
00001EA6  4E4F                    1406                              TRAP        #15
00001EA8  4CDF 7FFF               1407                              MOVEM.L     (SP)+,ALL_REG
00001EAC  4E75                    1408                              RTS
00001EAE                          1409  *__________________________________________________________________________________
00001EAE                          1410  
00001EAE                          1411  *________________ PRINT PLUS SIGN _________________________________________________
00001EAE                          1412          *PARAMENTER     NO PARAMETER NEEDED
00001EAE= 2B 00                   1413  PLUS_TAG            DC.B    '+',0
00001EB0= 2D 00                   1414  MINUS_TAG           DC.B    '-',0        
00001EB2  48E7 FFFE               1415  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001EB6  43F8 1EAE               1416                  LEA         PLUS_TAG, A1
00001EBA  103C 000E               1417                  MOVE.B      #14,D0
00001EBE  4E4F                    1418                  TRAP        #15
00001EC0  4CDF 7FFF               1419                  MOVEM.L     (SP)+,ALL_REG
00001EC4  4E75                    1420                  RTS
00001EC6                          1421  *_________________________________________________________________________________
00001EC6                          1422  
00001EC6                          1423  *________________ PRINT MINUS SIGN _______________________________________________
00001EC6                          1424          *PARAMENTER     NO PARAMETER NEEDED
00001EC6                          1425          
00001EC6  48E7 FFFE               1426  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001ECA  43F8 1EB0               1427                      LEA         MINUS_TAG, A1
00001ECE  103C 000E               1428                      MOVE.B      #14,D0
00001ED2  4E4F                    1429                      TRAP        #15
00001ED4  4CDF 7FFF               1430                      MOVEM.L     (SP)+,ALL_REG
00001ED8  4E75                    1431                      RTS
00001EDA                          1432  *_________________________________________________________________________________
00001EDA                          1433  
00001EDA                          1434  *________________ PRINT COMMA ____________________________________________________
00001EDA                          1435          *PARAMENTER     NO PARAMETER NEEDED
00001EDA= 09 00                   1436  TAB_TAG         DC.B    $9,0
00001EDC= 20 00                   1437  SPACE_TAG       DC.B    ' ',0
00001EDE= 2C 00                   1438  COMMA_TAG       DC.B    ',',0        
00001EE0  48E7 FFFE               1439  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001EE4  43F8 1EDE               1440                      LEA         COMMA_TAG, A1
00001EE8  103C 000E               1441                      MOVE.B      #14,D0
00001EEC  4E4F                    1442                      TRAP        #15
00001EEE  4CDF 7FFF               1443                      MOVEM.L     (SP)+,ALL_REG
00001EF2  4E75                    1444                      RTS
00001EF4                          1445  *_________________________________________________________________________________
00001EF4                          1446  
00001EF4                          1447  *________________ PRINT TAB ______________________________________________________
00001EF4                          1448          *PARAMENTER     NO PARAMETER NEEDED
00001EF4                          1449          
00001EF4  48E7 FFFE               1450  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001EF8  43F8 1EDA               1451                  LEA         TAB_TAG, A1
00001EFC  103C 000E               1452                  MOVE.B      #14,D0
00001F00  4E4F                    1453                  TRAP        #15
00001F02  4CDF 7FFF               1454                  MOVEM.L     (SP)+,ALL_REG
00001F06  4E75                    1455                  RTS
00001F08                          1456  *_________________________________________________________________________________
00001F08                          1457  
00001F08                          1458  
00001F08                          1459  *_______________    PRINT NEWLINE   ________________________________________________
00001F08                          1460          *PARAMETER NO PARAMETER NEEDED
00001F08= 0D 0A 00                1461  NEWLINE_TAG         DC.B    CR,LF,0        
00001F0C  48E7 FFFE               1462  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001F10  43F8 1F08               1463                      LEA         NEWLINE_TAG, A1
00001F14  103C 000E               1464                      MOVE.B      #14,D0
00001F18  4E4F                    1465                      TRAP        #15
00001F1A  4CDF 7FFF               1466                      MOVEM.L     (SP)+,ALL_REG
00001F1E  4E75                    1467                      RTS
00001F20                          1468  
00001F20                          1469  *___________________________________________________________________________________
00001F20                          1470  
00001F20                          1471  
00001F20                          1472  *_______________    PRINT HASH SIGN   ________________________________________________
00001F20                          1473          *PARAMETER NO PARAMETER NEEDED
00001F20                          1474          
00001F20  48E7 FFFE               1475  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001F24  43F8 1E80               1476                      LEA         HASH_SIGN_TAG, A1
00001F28  103C 000E               1477                      MOVE.B      #14,D0
00001F2C  4E4F                    1478                      TRAP        #15
00001F2E  4CDF 7FFF               1479                      MOVEM.L     (SP)+,ALL_REG
00001F32  4E75                    1480                      RTS
00001F34                          1481  
00001F34                          1482  *___________________________________________________________________________________
00001F34                          1483  
00001F34                          1484  
00001F34                          1485  
00001F34                          1486  *_______________    PRINT DOLLAR   ________________________________________________
00001F34                          1487          *PARAMETER NO PARAMETER NEEDED
00001F34                          1488          
00001F34  48E7 FFFE               1489  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001F38  43F8 1E82               1490                      LEA         DOLLAR_TAG, A1
00001F3C  103C 000E               1491                      MOVE.B      #14,D0
00001F40  4E4F                    1492                      TRAP        #15
00001F42  4CDF 7FFF               1493                      MOVEM.L     (SP)+,ALL_REG
00001F46  4E75                    1494                      RTS
00001F48                          1495  
00001F48                          1496  *___________________________________________________________________________________
00001F48                          1497  
00001F48                          1498  
00001F48                          1499  
00001F48                          1500  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001F48                          1501          *PARAMETER NO PARAMETER NEEDED
00001F48                          1502          
00001F48  48E7 FFFE               1503  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001F4C  43F8 1E84               1504                          LEA         FORWARD_SLASH_TAG, A1
00001F50  103C 000E               1505                          MOVE.B      #14,D0
00001F54  4E4F                    1506                          TRAP        #15
00001F56  4CDF 7FFF               1507                          MOVEM.L     (SP)+,ALL_REG
00001F5A  4E75                    1508                          RTS
00001F5C                          1509  
00001F5C                          1510  
00001F5C                          1511     
00001F5C                          1512  *********************************************************************
00001F5C                          1513  *Subroutine: OUTPUT
00001F5C                          1514  *What it does: Outputs parts of opword, moves to new screen if needed
00001F5C                          1515  *Registers: Uses register A1, D0,
00001F5C                          1516  *A1: Used to store messages and single char
00001F5C                          1517  *Paramemeters: A1, A2
00001F5C                          1518  *A1: Stores what should be used
00001F5C                          1519  *********************************************************************  
00001F5C                          1520  
00001F5C                          1521       OUTPUT:
00001F5C                          1522       
00001F5C  0C39 0001 0000233F      1523       CMP.B  #1,(OutputType)
00001F64  6700 0026               1524       BEQ    outputOpcode
00001F68  0C39 0002 0000233F      1525       CMP.B  #2,(OutputType)
00001F70  6700 0066               1526       BEQ    OutputSize
00001F74  0C39 0003 0000233F      1527       CMP.B  #3,(OutputType)
00001F7C  6700 0062               1528       BEQ    OutputData
00001F80  0C39 0004 0000233F      1529       CMP.B  #4,(OutputType)
00001F88  6700 00AC               1530       BEQ    OutputAddress
00001F8C                          1531       
00001F8C                          1532  outputOpcode    
00001F8C  0C39 001E 0000233E      1533       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001F94  6C00 0010               1534       BGE    outputOpcodeNewScreen
00001F98                          1535       
00001F98  103C 000E               1536       MOVE.B #14,D0
00001F9C  4E4F                    1537       TRAP   #15
00001F9E                          1538       
00001F9E  5239 0000233E           1539       ADD.B  #1,(LineCounter)
00001FA4                          1540       
00001FA4  4E75                    1541       RTS
00001FA6                          1542       
00001FA6                          1543       
00001FA6                          1544  outputOpcodeNewScreen
00001FA6  2F09                    1545       MOVE.L A1,-(SP)                Storing last message to be used later
00001FA8                          1546       
00001FA8  43F9 00002314           1547       LEA    OUTPUTNEWSCREEN,A1         
00001FAE  103C 000E               1548       MOVE.B #14,D0
00001FB2  4E4F                    1549       TRAP   #15
00001FB4                          1550       
00001FB4  43F9 00008008           1551       LEA    userInputStored,A1         Pauses program to show screen full of data
00001FBA  103C 0002               1552       MOVE.B #2,D0
00001FBE  4E4F                    1553       TRAP   #15
00001FC0                          1554       
00001FC0  13FC 0000 0000233E      1555       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001FC8                          1556       
00001FC8  225F                    1557       MOVE.L (SP)+,A1                Retriving message to be used
00001FCA                          1558       
00001FCA  103C 000E               1559       MOVE.B #14,D0                  Outputting decoded message
00001FCE  4E4F                    1560       TRAP   #15
00001FD0                          1561       
00001FD0  5239 0000233E           1562       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001FD6                          1563       
00001FD6  4E75                    1564       RTS
00001FD8                          1565       
00001FD8                          1566  outputSize
00001FD8  103C 000E               1567      MOVE.B  #14,D0
00001FDC  4E4F                    1568      TRAP    #15
00001FDE  4E75                    1569      RTS
00001FE0                          1570  outputData
00001FE0  267C 00000800           1571      MOVE.L   #$800,A3
00001FE6  3692                    1572      MOVE.W  (A2),(A3)
00001FE8  2F06                    1573      MOVE.L  D6,-(SP)
00001FEA  103C 0000               1574      MOVE.B  #0,D0
00001FEE  43F9 00009005           1575      LEA     addressOutput,A1
00001FF4                          1576  
00001FF4                          1577  outputDataLoop
00001FF4                          1578  *check if loop has run 4 times
00001FF4  B03C 0002               1579      CMP.B   #2,D0
00001FF8  6700 001C               1580      BEQ     outputDataLoopEnd
00001FFC                          1581      *Grab byte from address, dont increment
00001FFC  1C13                    1582      MOVE.B  (A3),D6
00001FFE                          1583      *LSR to isolate left bit
00001FFE  E80E                    1584      LSR.B   #4,D6
00002000                          1585      *Call converthtoa
00002000  6100 008A               1586      BSR     CONVERTHTOA
00002004  12C6                    1587      MOVE.B  D6,(A1)+   
00002006                          1588      *Grab bye from address, increment
00002006  1C1B                    1589      MOVE.B  (A3)+,D6
00002008                          1590      *AND Mask second digit
00002008  CC3C 000F               1591      AND.B   #$0F,D6
0000200C  6100 007E               1592      BSR     CONVERTHTOA
00002010  12C6                    1593      MOVE.B  D6,(A1)+
00002012  5200                    1594      ADD.B   #1,D0
00002014  60DE                    1595      BRA     outputDataLoop
00002016                          1596      
00002016                          1597  outputDataLoopEnd
00002016  12BC 0000               1598      MOVE.B  #$00,(A1)
0000201A  2C1F                    1599      MOVE.L  (SP)+,D6
0000201C  43F9 00009005           1600      LEA     addressOutput,A1
00002022  103C 000E               1601      MOVE.B  #14,D0
00002026  4E4F                    1602      TRAP    #15
00002028                          1603      
00002028  43F9 00002337           1604      LEA     NEWLINE,A1
0000202E  103C 000E               1605      MOVE.B  #14,D0
00002032  4E4F                    1606      TRAP    #15
00002034                          1607  
00002034  4E75                    1608      RTS
00002036                          1609   
00002036                          1610      
00002036                          1611  outputAddress
00002036  267C 00000800           1612      MOVE.L  #$800,A3
0000203C  268A                    1613      MOVE.L  A2,(A3)
0000203E  2F06                    1614      MOVE.L  D6,-(SP)
00002040  103C 0000               1615      MOVE.B  #0,D0
00002044  43F9 00009005           1616      LEA     addressOutput,A1
0000204A                          1617  outputAddressLoop
0000204A                          1618      *check if loop has run 4 times
0000204A  B03C 0004               1619      CMP.B   #4,D0
0000204E  6700 001C               1620      BEQ     outputAddressLoopEnd
00002052                          1621      *Grab byte from address, dont increment
00002052  1C13                    1622      MOVE.B  (A3),D6
00002054                          1623      *LSR to isolate left bit
00002054  E80E                    1624      LSR.B   #4,D6
00002056                          1625      *Call converthtoa
00002056  6100 0034               1626      BSR     CONVERTHTOA
0000205A  12C6                    1627      MOVE.B  D6,(A1)+   
0000205C                          1628      *Grab bye from address, increment
0000205C  1C1B                    1629      MOVE.B  (A3)+,D6
0000205E                          1630      *AND Mask second digit
0000205E  CC3C 000F               1631      AND.B   #$0F,D6
00002062  6100 0028               1632      BSR     CONVERTHTOA
00002066  12C6                    1633      MOVE.B  D6,(A1)+
00002068  5200                    1634      ADD.B   #1,D0
0000206A  60DE                    1635      BRA     outputAddressLoop
0000206C                          1636      
0000206C                          1637      
0000206C                          1638  outputAddressLoopEnd
0000206C  12BC 0000               1639      MOVE.B  #$00,(A1)
00002070  2C1F                    1640      MOVE.L  (SP)+,D6
00002072  43F9 00009005           1641      LEA     addressOutput,A1
00002078                          1642      
00002078  103C 000E               1643      MOVE.B  #14,D0
0000207C  4E4F                    1644      TRAP    #15
0000207E                          1645      
0000207E  43F9 0000233A           1646      LEA     spaces,A1
00002084  103C 000E               1647      MOVE.B  #14,D0
00002088  4E4F                    1648      TRAP    #15
0000208A                          1649  
0000208A                          1650  
0000208A  4E75                    1651      RTS
0000208C                          1652  
0000208C                          1653  *********************************************************************
0000208C                          1654  *Subroutine: CONVERTHTOA
0000208C                          1655  *What it does: Converts HEX to ASCII
0000208C                          1656  *Registers: Uses register D6,D0
0000208C                          1657  *D6: Stores hex character to be converted
0000208C                          1658  *Paramemeters: D6
0000208C                          1659  *D6: Stores hex characcter to be converted
0000208C                          1660  *********************************************************************
0000208C                          1661      CONVERTHTOA:
0000208C                          1662      
0000208C  BC3C 0009               1663      CMP.B   #9,D6
00002090  6F00 0006               1664      BLE     zerotonine
00002094  6000 000A               1665      BRA     AtoF
00002098                          1666      
00002098                          1667  zerotonine    
00002098  0686 00000030           1668      ADD.L   #$30,D6
0000209E  4E75                    1669      RTS
000020A0                          1670  AtoF
000020A0  0686 00000037           1671      ADD.L   #$37,D6
000020A6  4E75                    1672      RTS
000020A8                          1673      
000020A8                          1674  END_SIMULATION:
000020A8                          1675          
000020A8  103C 0009               1676      MOVE.B  #9,D0
000020AC  4E4F                    1677      TRAP    #15
000020AE                          1678  
000020AE  FFFF FFFF               1679      SIMHALT             ; halt simulator
000020B2                          1680  
000020B2                          1681  * Put variables and constants here
000020B2= 57 65 6C 63 6F 6D ...   1682  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
000020D8= 53 6F 6D 65 20 71 ...   1683                  DC.B    'Some quick rules:',CR,LF
000020EB= 31 29 20 4F 6E 6C ...   1684                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
00002127= 32 29 20 54 68 65 ...   1685                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
00002172= 33 29 20 41 6E 79 ...   1686                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
000021B6= 20 20 20 77 69 6C ...   1687                  DC.B    '   will be rejected',CR,LF
000021CB= 34 29 20 54 68 65 ...   1688                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
0000220E= 20 20 20 77 69 6C ...   1689                  DC.B    '   will be rejected',CR,LF,0      
00002224= 50 6C 65 61 73 65 ...   1690  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
0000224A= 50 6C 65 61 73 65 ...   1691  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
00002270                          1692  
00002270= 0D 0A 54 68 69 73 ...   1693  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
0000228E= 0D 0A 49 6E 70 75 ...   1694  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
000022CA                          1695  
000022CA= 54 6F 20 72 65 70 ...   1696  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
00002314                          1697  
00002314= 50 6C 65 61 73 65 ...   1698  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
00002337                          1699  
00002337= 0D 0A 00                1700  NEWLINE     DC.B    CR,LF,0
0000233A= 20 20 00                1701  SPACES      DC.B    '  ',0
0000233D                          1702  
0000233D= 01                      1703  InputQuality    DC.B    1       Set to 1 for default good
0000233E= 00                      1704  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
0000233F= 00                      1705  OutputType      DC.B    0      To track what type is being output
00002340= 00                      1706  RepeatFlag      DC.B    0
00002341                          1707  
00002341= 4E 4F 50 0D 0A 00       1708  nopout  DC.B    'NOP',CR,LF,0
00002347= 4D 4F 56 45 00          1709  moveout  DC.B    'MOVE',0
0000234C= 4D 4F 56 45 41 00       1710  moveaout DC.B      'MOVEA',0
00002352= 4D 4F 56 45 51 00       1711  moveqout DC.B   'MOVEQ',0
00002358= 4D 4F 56 45 4D 00       1712  movemout DC.B   'MOVEM',0
0000235E                          1713  
0000235E= 53 55 42 00             1714  subout    DC.B  'SUB',0
00002362= 41 44 44 00             1715  addout    DC.B 'ADD',0
00002366= 41 44 44 41 00          1716  addaout    DC.B 'ADDA',0
0000236B= 41 44 44 51 00          1717  addqout    DC.B 'ADDQ',0
00002370                          1718  
00002370= 4C 45 41 00             1719  leaout    DC.B  'LEA',0
00002374                          1720  
00002374= 4E 4F 54 00             1721  notout    DC.B  'NOT',0
00002378= 4F 52 00                1722  orout DC.B     'OR',0
0000237B= 41 4E 44 00             1723  andout DC.B     'AND',0
0000237F                          1724  
0000237F                          1725  
0000237F= 4C 53 4C 00             1726  lslout    DC.B  'LSL',0
00002383= 4C 53 52 00             1727  lsrout    DC.B  'LSR',0
00002387= 41 53 4C 00             1728  aslout    DC.B  'ASL',0
0000238B= 41 53 52 00             1729  asrout    DC.B  'ASR',0
0000238F                          1730  
0000238F= 52 4F 4C 00             1731  rolout    DC.B  'ROL',0
00002393= 52 4F 52 00             1732  rorout    DC.B  'ROR',0
00002397                          1733  
00002397= 42 47 54 00             1734  bgtout DC.B     'BGT',0
0000239B= 42 4C 45 00             1735  bleout DC.B     'BLE',0
0000239F= 42 45 51 00             1736  beqout DC.B     'BEQ',0
000023A3                          1737  
000023A3= 4A 53 52 00             1738  jsrout DC.B     'JSR',0
000023A7= 52 54 53 0D 0A 00       1739  rtsout DC.B     'RTS',CR,LF,0
000023AD= 42 52 41 00             1740  braout DC.B     'BRA',0
000023B1                          1741  
000023B1= 44 41 54 41 20 20 ...   1742  dataout DC.B    'DATA   ',0
000023B9                          1743  
000023B9                          1744  
000023B9                          1745  
000023B9= 2E 42 20 20 20 20 00    1746  byteout  DC.B    '.B    ',0
000023C0= 2E 57 20 20 20 20 00    1747  wordout  DC.B    '.W    ',0
000023C7= 2E 4C 20 20 20 20 00    1748  longout  DC.B    '.L    ',0
000023CE                          1749  
000023CE= 0D 0A 00                1750  empty    DC.B    '',CR,LF,0
000023D1                          1751  
000023D1  =0000000D               1752  CR  EQU $0D
000023D1  =0000000A               1753  LF  EQU $0A
000023D1                          1754  
000023D1                          1755  
000023D1                          1756      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 147E
ADDA                14C0
ADDAOUT             2366
ADDOUT              2362
ADDQ                143C
ADDQOUT             236B
ADDQ_EA             1B62
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 1780
ANDOUT              237B
ASL                 1610
ASLOUT              2387
ASR                 1652
ASROUT              238B
ATOF                20A0
ATOH                19C8
BCC                 17C2
BEQ                 182C
BEQOUT              239F
BGT                 17E8
BGTOUT              2397
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 180A
BLEOUT              239B
BRA                 184E
BRAOUT              23AD
BYTE                12B8
BYTEOUT             23B9
CHECK_EA_AB_L       1D48
CHECK_EA_AB_W       1D28
CHECK_EA_AR         1C90
CHECK_EA_IMM        1D66
CHECK_EA_INDIRECT   1CAA
CHECK_EA_POST       1CD0
CHECK_EA_PRE        1CFC
CHECK_VALID_EA      1C24
CLOSED_PAR_TAG      1E7E
COMMA_TAG           1EDE
CONVERTATOH         19C8
CONVERTHTOA         208C
CR                  D
DATA                1870
DATAOUT             23B1
DOLLAR_TAG          1E82
EA1_END             1AA6
EA1_MODE_ONE        1A9A
EA1_MODE_ZERO       1AA2
EA2_END             1AEA
EA2_IMMEDIATE       1AE2
EA2_REGISTER        1ADA
EA_GROUP1           1A7A
EA_GROUP2           1AC4
EA_GROUP3           1B0A
EA_GROUP4           1B26
EMPTY               23CE
END_SIMULATION      20A8
FINISH              1A1C
FIRSTINPUT          18E6
FORMAT_IMMEDIATE_DATA  1A28
FORWARD_SLASH_TAG   1E84
HASH_SIGN_TAG       1E80
HERE                1020
HEX_TO_ASCII        1E16
HEX_TO_ASCII_RETURN  1E26
IMMEDIATE0          1A38
IMMEDIATE_END       1A3A
INPUT1              8000
INPUT1MESSAGE       2224
INPUT2              8004
INPUT2MESSAGE       224A
INPUTERROR          1A1E
INPUTERROR2SMALLER  228E
INPUTERRORBADCHAR   2270
INPUTQUALITY        233D
INPUTREPEAT         22CA
INPUT_BUFFER        1DBA
INVALID_EA          1C5E
IPUT_BUFFER_EX      1DB2
JSR                 1524
JSROUT              23A3
LEA                 1718
LEAOUT              2370
LETSGO              1058
LETTERS             1E76
LF                  A
LINECOUNTER         233E
LONG                12E0
LONGOUT             23C7
LOWERCASE           1A04
LSL                 158C
LSLOUT              237F
LSR                 15CE
LSROUT              2383
MEMORY_TO_REGISTER  1BBC
MINUS_TAG           1EB0
MODE_010            1BEA
MODE_01_0           1C1C
MOVE                1318
MOVEA               1364
MOVEAOUT            234C
MOVEM               13C0
MOVEMOUT            2358
MOVEM_EA            1BB2
MOVEOUT             2347
MOVEQ               139A
MOVEQOUT            2352
MOVEQ_EA            1B8A
MOVE_MOVEA_EA       1A3C
NEWLINE             2337
NEWLINE_TAG         1F08
NOP                 12F6
NOPOUT              2341
NOT                 154A
NOTOUT              2374
NUMBER_TO_ASCII     1E2C
OPCODE              11B2
OPEN_PAR_TAG        1E7C
OR                  173E
OROUT               2378
OUTPUT              1F5C
OUTPUTADDRESS       2036
OUTPUTADDRESSLOOP   204A
OUTPUTADDRESSLOOPEND  206C
OUTPUTDATA          1FE0
OUTPUTDATALOOP      1FF4
OUTPUTDATALOOPEND   2016
OUTPUTNEWSCREEN     2314
OUTPUTOPCODE        1F8C
OUTPUTOPCODENEWSCREEN  1FA6
OUTPUTSIZE          1FD8
OUTPUTTYPE          233F
PLUS_TAG            1EAE
POPULATE_BUFFER     1DEC
PRINT_BUFFER        1DA8
PRINT_CLOSED_PARENTHESIS  1E9A
PRINT_COMMA         1EE0
PRINT_DOLLAR        1F34
PRINT_EA            1C68
PRINT_EA_RETURN     1DA2
PRINT_FORWARD_SLASH  1F48
PRINT_HASH_SIGN     1F20
PRINT_HEX           1DCA
PRINT_HEX_RETURN    1DE0
PRINT_MINUS         1EC6
PRINT_NEWLINE       1F0C
PRINT_OPEN_PARENTHESIS  1E86
PRINT_PLUS          1EB2
PRINT_REGISTOR      1E32
PRINT_REGISTOR_RETURN  1E62
PRINT_TAB           1EF4
READ_WORD_IMM       1D8A
REGISTER_TO_MEMORY  1BF8
REPEATFLAG          2340
RETURN              12B6
ROL                 1694
ROLOUT              238F
ROR                 16D6
ROROUT              2393
RTS                 14FE
RTSOUT              23A7
SECONDINPUT         194A
SPACES              233A
SPACE_TAG           1EDC
START               1000
STARTMESSAGE        20B2
SUB                 13FA
SUBOUT              235E
TAB_TAG             1EDA
THERE               1186
THROWINPUT1CHARERROR  192C
THROWINPUT2CHARERROR  1998
THROWINPUT2LOWERERROR  19B4
TO_STRING           1E68
UPPERCASE           19EC
USERINPUT           189E
USERINPUTREPEAT     1188
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1C46
WELCOMEEXPLANATION  18CC
WORD                12CC
WORDOUT             23C0
WRONG_INSTRUCTION   1BE0
ZEROTONINE          2098
