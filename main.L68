00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/10/2022 9:24:07 PM

00000000  =00009005                  1  addressOutput EQU   $9005
00000000  =00008000                  2  input1      EQU     $8000           where input 1 is stored (can be changed if needed)
00000000  =00008004                  3  input2      EQU     $8004          where input 2 is stored (can be changed if needed)
00000000  =00008008                  4  userInputStored    EQU     $8008   
00000000                             5  
00000000                             6  
00000000                             7  
00000000                             8  
00000000                             9  
00001000                            10      ORG    $1000
00001000                            11  START:                           *Main
00001000                            12  
00001000  13FC 0000 0000235A        13      MOVE.B  #0,(LineCounter)
00001008                            14  userInputStart
00001008  6100 08B0                 15      BSR     USERINPUT
0000100C                            16      
0000100C                            17  *testing purposes----------------------------------------------------
0000100C  1C3C 0004                 18      MOVE.B #$04, D6
00001010  347C 1004                 19      MOVE.W #$1004, A2
00001014  7C0A                      20      MOVEQ #10, D6
00001016  264A                      21      MOVEA.L A2, A3
00001018  B641                      22      CMP D1,D3
0000101A  9C82                      23      SUB.L D2, D6
0000101C                            24  
0000101C  6000 0002                 25      BRA here
00001020                            26  here
00001020  4EB9 00001186             27      JSR there
00001026  4693                      28      NOT.L (A3)
00001028  47D1                      29      LEA (A1),A3
0000102A  8AB9 00008000             30      OR.L input1, D5
00001030  48E7 FFFE                 31      MOVEM.L D0-D7/A0-A6,-(SP) 
00001034  CC01                      32      AND.B D1,D6
00001036  D803                      33      ADD.B D3,D4
00001038  D4C9                      34      ADDA.W A1,A2
0000103A  5E81                      35      ADDQ.L #7,D1
0000103C  E709                      36      LSL.B #3,D1
0000103E  E449                      37      lSR.W #2,D1
00001040  ED02                      38      ASL.B #6,D2
00001042  EA42                      39      ASR.W #5,D2
00001044  EB1B                      40      ROL.B #5,D3
00001046  E85B                      41      ROR.W #4,D3
00001048  6E00 000E                 42      BGT letsgo
0000104C  B67C 0004                 43      CMP #4,D3 
00001050  6700 0006                 44      BEQ letsgo
00001054  6F00 0002                 45      BLE letsgo
00001058                            46     
00001058                            47  letsgo
00001058                            48      
00001058                            49  * calls-------------------------------------------------------
00001058  347C 100C                 50      MOVE.W #$100C, A2
0000105C  6100 0154                 51      BSR     OPCODE * test MOVE.B
00001060                            52  
00001060  347C 1010                 53      MOVE.W #$1010, A2
00001064  6100 014C                 54      BSR     OPCODE * test MOVEA.W
00001068                            55      
00001068  347C 1014                 56      MOVE.W #$1014, A2
0000106C  6100 0144                 57      BSR     OPCODE * test MOVEQ
00001070                            58     
00001070  347C 1016                 59      MOVE.W #$1016, A2
00001074  6100 013C                 60      BSR     OPCODE *test MOVEA.L
00001078                            61      
00001078  347C 1018                 62      MOVE.W #$1018, A2
0000107C  6100 0134                 63      BSR     OPCODE *test DATA
00001080                            64      
00001080                            65      
00001080  347C 101A                 66      MOVE.W #$101A, A2
00001084  6100 012C                 67      BSR     OPCODE *test SUB.L
00001088                            68      
00001088  347C 101C                 69      MOVE.W #$101C, A2
0000108C  6100 0124                 70      BSR     OPCODE *test BRA
00001090                            71      
00001090  347C 1020                 72      MOVE.W #$1020, A2
00001094  6100 011C                 73      BSR     OPCODE *test JSR
00001098                            74      
00001098                            75      
00001098  43F9 000023F2             76      LEA empty,A1
0000109E  13FC 0001 0000235B        77      MOVE.B  #1,(OutputType)       
000010A6  6100 0ED0                 78      BSR    OUTPUT
000010AA                            79  
000010AA                            80      
000010AA  347C 1026                 81      MOVE.W #$1026, A2
000010AE  6100 0102                 82      BSR     OPCODE *test NOT
000010B2                            83      
000010B2  347C 1028                 84      MOVE.W #$1028, A2
000010B6  6100 00FA                 85      BSR     OPCODE *test LEA
000010BA                            86      
000010BA  347C 102A                 87      MOVE.W #$102A, A2
000010BE  6100 00F2                 88      BSR     OPCODE *test OR
000010C2                            89      
000010C2  43F9 000023F2             90       LEA empty,A1
000010C8  13FC 0001 0000235B        91      MOVE.B  #1,(OutputType)       
000010D0  6100 0EA6                 92      BSR    OUTPUT
000010D4                            93  
000010D4                            94      
000010D4  347C 1030                 95      MOVE.W #$1030, A2
000010D8  6100 00D8                 96      BSR     OPCODE *test MOVEM
000010DC                            97  
000010DC  347C 1034                 98      MOVE.W #$1034, A2
000010E0  6100 00D0                 99      BSR     OPCODE *test AND
000010E4                           100      
000010E4  347C 1036                101      MOVE.W #$1036, A2
000010E8  6100 00C8                102      BSR     OPCODE *test ADD
000010EC                           103      
000010EC  43F9 000023F2            104      LEA empty,A1
000010F2  13FC 0001 0000235B       105      MOVE.B  #1,(OutputType) * new line  
000010FA  6100 0E7C                106      BSR    OUTPUT
000010FE                           107  
000010FE  347C 1038                108      MOVE.W #$1038, A2
00001102  6100 00AE                109      BSR     OPCODE *test ADDA
00001106                           110      
00001106  347C 103A                111      MOVE.W #$103A, A2
0000110A  6100 00A6                112      BSR     OPCODE *test ADDQ
0000110E                           113      
0000110E  347C 103C                114      MOVE.W #$103C, A2
00001112  6100 009E                115      BSR     OPCODE *test LSL
00001116                           116  
00001116  347C 103E                117      MOVE.W #$103E, A2
0000111A  6100 0096                118      BSR     OPCODE *test LSR
0000111E                           119      
0000111E  347C 1040                120      MOVE.W #$1040, A2
00001122  6100 008E                121      BSR     OPCODE *test ASL
00001126                           122      
00001126  43F9 000023F2            123      LEA empty,A1
0000112C  13FC 0001 0000235B       124      MOVE.B  #1,(OutputType) * new line  
00001134  6100 0E42                125      BSR    OUTPUT
00001138                           126  
00001138                           127  
00001138  347C 1042                128      MOVE.W #$1042, A2
0000113C  6100 0074                129      BSR     OPCODE *test ASR
00001140                           130      
00001140                           131      
00001140  347C 1044                132      MOVE.W #$1044, A2
00001144  6100 006C                133      BSR     OPCODE *test ROL
00001148                           134  
00001148  347C 1046                135      MOVE.W #$1046, A2
0000114C  6100 0064                136      BSR     OPCODE *test ROR
00001150                           137      
00001150  43F9 000023F2            138      LEA empty,A1
00001156  13FC 0001 0000235B       139      MOVE.B  #1,(OutputType) * new line  
0000115E  6100 0E18                140      BSR    OUTPUT
00001162                           141  
00001162  347C 1048                142      MOVE.W #$1048, A2
00001166  6100 004A                143      BSR     OPCODE *test BGT
0000116A                           144  
0000116A  347C 1050                145      MOVE.W #$1050, A2
0000116E  6100 0042                146      BSR     OPCODE *test BLE
00001172                           147      
00001172  347C 1054                148      MOVE.W #$1054, A2
00001176  6100 003A                149      BSR     OPCODE *test BEQ
0000117A                           150      
0000117A                           151  
0000117A                           152    
0000117A  347C 1186                153      MOVE.W #$1186, A2
0000117E  6100 0032                154      BSR     OPCODE *test RTS
00001182                           155  
00001182                           156  
00001182                           157  * calls---------------------------------------------------------    
00001182  6000 0004                158      BRA userInputRepeat
00001186                           159  there    
00001186  4E75                     160      RTS
00001188                           161  * end testing--------------------------------------------------------------
00001188                           162   
00001188                           163  
00001188                           164       
00001188                           165    
00001188                           166  
00001188                           167      
00001188                           168  userInputRepeat
00001188  43F9 000022E6            169      LEA     INPUTREPEAT,A1
0000118E  103C 000E                170      MOVE.B  #14,D0
00001192  4E4F                     171      TRAP    #15
00001194  5239 0000235A            172      ADD.B   #1,(LineCounter)
0000119A                           173      
0000119A  43F9 00008008            174      LEA     userInputStored,A1
000011A0  103C 0005                175      MOVE.B  #5,D0
000011A4  4E4F                     176      TRAP    #15
000011A6                           177      
000011A6  B23C 000D                178      CMP.B   #$0D,D1
000011AA  6700 FE5C                179      BEQ     userInputStart
000011AE                           180   
000011AE  FFFF FFFF                181      SIMHALT
000011B2                           182  
000011B2                           183  **********************************************************
000011B2                           184  *Subroutine: OPCODE
000011B2                           185  *What it does: Looks at the word pointed to by A2 and determines opcode
000011B2                           186  *Registers: 
000011B2                           187  *A1: printing
000011B2                           188  *A2: parameter with instruction address
000011B2                           189  *D0: printing
000011B2                           190  *D3: used for determing the instruction, mostly shifts
000011B2                           191  *D2: used for determing the size
000011B2                           192  *D4: used for passing size to SIZE
000011B2                           193  *Paramemeters: A2 the memory address to decode from
000011B2                           194  **********************************************************
000011B2                           195  OPCODE:
000011B2  4243                     196      CLR D3
000011B4                           197      
000011B4  0C52 4E75                198      CMP #$4E75, (A2) * RTS compare, this has to be done before JSR, LEA, and NOT
000011B8  6700 0360                199      BEQ rts
000011BC                           200      
000011BC  0C52 4E71                201      CMP #$4E71, (A2) *NOP compare
000011C0  6700 0152                202      BEQ nop
000011C4                           203      
000011C4  3612                     204      Move.W (A2), D3 
000011C6  E04B                     205      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
000011C8  E84B                     206      LSR #4,D3
000011CA                           207      
000011CA                           208      
000011CA  B67C 0008                209      CMP #%1000, D3 * OR compare
000011CE  6700 058A                210      BEQ or
000011D2                           211      
000011D2                           212      
000011D2  B67C 0003                213      CMP #%0011, D3 *MOVE and MOVEA compare
000011D6  6F00 015C                214      BLE move
000011DA                           215      
000011DA  B67C 0007                216      CMP #%0111, D3 *MOVEQ compare
000011DE  6700 01D6                217      BEQ moveq
000011E2                           218      
000011E2  B67C 0009                219      CMP #%1001, D3 *SUB compare
000011E6  6700 022E                220      BEQ sub
000011EA                           221      
000011EA  B67C 000C                222      CMP #%1100, D3 *AND compare
000011EE  6700 05AC                223      BEQ and
000011F2                           224      
000011F2  B67C 0005                225      CMP #%0101, D3 *ADDQ compare
000011F6  6700 0260                226      BEQ addq
000011FA                           227      
000011FA  B67C 0006                228      CMP #%0110, D3 *BCC compare, BGT, BLE, and BEQ are branched from internally
000011FE  6700 05DE                229      BEQ bcc
00001202                           230      
00001202                           231  
00001202  3612                     232      Move.W (A2), D3 * reset D3
00001204  0243 F118                233      ANDI.W #%1111000100011000,D3  * the bits relevant to LSL
00001208  B67C E108                234      CMP #%1110000100001000,D3 * LSL compare
0000120C  6700 039A                235      BEQ lsl
00001210                           236  
00001210  3612                     237      Move.W (A2), D3 * reset D3
00001212  0243 F118                238      ANDI.W #%1111000100011000,D3  * the bits relevant to LSR
00001216  B67C E008                239      CMP #%1110000000001000,D3 * LSR compare
0000121A  6700 03CE                240      BEQ lsr
0000121E                           241      
0000121E                           242      
0000121E  3612                     243      Move.W (A2), D3 * reset D3
00001220  0243 F118                244      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001224  B67C E100                245      CMP #%1110000100000000,D3 * ASL compare
00001228  6700 0402                246      BEQ asl
0000122C                           247  
0000122C  3612                     248      Move.W (A2), D3 * reset D3
0000122E  0243 F118                249      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
00001232  B67C E000                250      CMP #%1110000000000000,D3 * ASR compare
00001236  6700 0436                251      BEQ asr
0000123A                           252  
0000123A  3612                     253      Move.W (A2), D3 * reset D3
0000123C  0243 F118                254      ANDI.W #%1111000100011000,D3  * the bits relevant to ASL
00001240  B67C E118                255      CMP #%1110000100011000,D3 * ROL compare
00001244  6700 046A                256      BEQ rol
00001248                           257  
00001248  3612                     258      Move.W (A2), D3 * reset D3
0000124A  0243 F118                259      ANDI.W #%1111000100011000,D3  * the bits relevant to ASR
0000124E  B67C E018                260      CMP #%1110000000011000,D3 * ROR compare
00001252  6700 049E                261      BEQ ror
00001256                           262  
00001256                           263      
00001256                           264      
00001256  3612                     265      Move.W (A2), D3 * reset D3
00001258  0243 F0C0                266      ANDI.W #%1111000011000000,D3  * the bits relevant to ADDA
0000125C  B67C D0C0                267      CMP #%1101000011000000,D3 * ADDA compare, must be done before add
00001260  6700 027A                268      BEQ adda
00001264                           269      
00001264  3612                     270      Move.W (A2), D3 
00001266  E04B                     271      LSR #8,D3 * make D3 only contain the first 4 bits of the instruction as its LSig word
00001268  E84B                     272      LSR #4,D3
0000126A  B67C 000D                273      CMP #%1101, D3 *ADD compare
0000126E  6700 022A                274      BEQ add
00001272                           275  
00001272                           276    
00001272  3612                     277      Move.W (A2), D3 * reset D3
00001274  0243 FB80                278      ANDI.W #%1111101110000000,D3  * the bits relevant to MOVEM
00001278  B67C 4880                279      CMP #%0100100010000000,D3 * MOVEM compare
0000127C  6700 015E                280      BEQ movem
00001280                           281  
00001280                           282      
00001280                           283      
00001280  3612                     284      Move.W (A2), D3 * reset D3
00001282  EC4B                     285      LSR #6,D3 * make D3 only contain the first 10 bits of the instruction
00001284  B67C 013A                286      CMP #%0000000100111010, D3 * JSR compare, this has to be done before NOT and LEA
00001288  6700 02B6                287      BEQ jsr
0000128C                           288  
0000128C  3612                     289      Move.W (A2), D3 * reset D3
0000128E  E04B                     290      LSR #8,D3 * make D3 only contain the first 8 bits
00001290  B67C 0046                291      CMP #%01000110,D3 * NOT compare, this has to be done before LEA
00001294  6700 02D0                292      BEQ not
00001298                           293      
00001298  3612                     294      Move.W (A2), D3 * reset D3
0000129A  0243 F1C0                295      ANDI.W #%1111000111000000,D3 * the bits relevant to LEA
0000129E  B67C 41C0                296      CMP #%0100000111000000,D3 *LEA compare
000012A2  6700 0490                297      BEQ lea
000012A6                           298      
000012A6                           299      
000012A6                           300      
000012A6                           301      
000012A6                           302      
000012A6                           303  
000012A6                           304  
000012A6                           305     
000012A6  3612                     306      Move.W (A2), D3 * reset D3
000012A8  E04B                     307      LSR #8,D3 * make D3 only contain the first 8 bits of the instruction
000012AA  B67C 0060                308      CMP #%01100000, D3 *BRA compare
000012AE  6700 05BA                309      BEQ bra
000012B2                           310      
000012B2                           311      
000012B2  6000 05D8                312      BRA data
000012B6                           313      
000012B6                           314  return
000012B6  4E75                     315      RTS
000012B8                           316      
000012B8                           317  SIZE:
000012B8                           318      * standarize the size indicator, each OPCODE will decide if its size 2,4,8 based on its specific handling of bits
000012B8  B47C 0002                319      CMP #2, D2 *byte is 2
000012BC  6000 0012                320      BRA byte
000012C0  B47C 0004                321      CMP #4, D2 *word is 4
000012C4  6000 0020                322      BRA word
000012C8  B47C 0008                323      CMP #8, D2 *long is 8
000012CC  6000 002E                324      BRA long
000012D0                           325  
000012D0                           326      
000012D0                           327  byte
000012D0  43F9 000023D5            328      LEA    byteout,A1        
000012D6  13FC 0002 0000235B       329      MOVE.B  #2,(OutputType)
000012DE  6100 0C98                330      BSR     OUTPUT 
000012E2  6000 002E                331      BRA     endsize
000012E6                           332  word
000012E6  43F9 000023DC            333      LEA    wordout,A1        
000012EC  13FC 0002 0000235B       334      MOVE.B  #2,(OutputType)
000012F4  6100 0C82                335      BSR     OUTPUT
000012F8  6000 0018                336      BRA     endsize
000012FC                           337  long
000012FC  43F9 000023E3            338      LEA    longout,A1        
00001302  13FC 0002 0000235B       339      MOVE.B  #2,(OutputType)
0000130A  6100 0C6C                340      BSR     OUTPUT 
0000130E  6000 0002                341      BRA     endsize
00001312                           342      
00001312                           343      
00001312                           344  endsize    
00001312  4E75                     345      RTS        
00001314                           346  
00001314                           347  
00001314                           348  l
00001314                           349  
00001314                           350  w
00001314                           351  
00001314                           352  b
00001314                           353      
00001314                           354      
00001314                           355  nop 
00001314  13FC 0004 0000235B       356      MOVE.B  #4,(OutputType)
0000131C  6100 0C5A                357      BSR     OUTPUT
00001320  43F9 0000235D            358      LEA    nopout,A1        
00001326  13FC 0001 0000235B       359      MOVE.B  #1,(OutputType)
0000132E  6100 0C48                360      BSR     OUTPUT
00001332  6082                     361      BRA return
00001334                           362      
00001334                           363  move
00001334                           364      * put the size of the instruction into D2 to use later
00001334                           365      * since the first two bits of D3 are 00 for move moving the entire word works
00001334  3403                     366      Move.W D3, D2
00001336                           367  
00001336                           368  
00001336                           369      * determine if MOVE or MOVEA
00001336                           370      * if bits 8,7,6 = 001 its MOVEA
00001336  3612                     371      MOVE.W (A2),D3
00001338  0243 01C0                372      ANDI.W #%0000000111000000, D3 *extract only bits 8,7,6
0000133C                           373      
0000133C  B67C 0040                374      CMP #%0000000001000000,D3 * if only the sixth bit is set then instruction is MOVEA
00001340  6700 003E                375      BEQ movea
00001344                           376      
00001344  13FC 0004 0000235B       377      MOVE.B  #4,(OutputType)
0000134C  6100 0C2A                378      BSR     OUTPUT
00001350                           379  
00001350  43F9 00002363            380      LEA    moveout,A1     *print the type
00001356  13FC 0001 0000235B       381      MOVE.B  #1,(OutputType)   
0000135E  6100 0C18                382      BSR    OUTPUT
00001362                           383      
00001362                           384      *now to print size  
00001362  B47C 0002                385      cmp #2,D2 *if the size is 2 branch to long
00001366  67AC                     386      BEQ l
00001368  B47C 0003                387      cmp #3,D2 *if the size is 3 branch to word
0000136C  67A6                     388      BEQ w
0000136E  B47C 0001                389      cmp #1,D2 * if the size is 1 branch to byte
00001372  67A0                     390      BEQ b
00001374                           391      
00001374  6100 FF42                392      BSR SIZE
00001378  6100 06DE                393      BSR MOVE_MOVEA_EA
0000137C                           394      
0000137C  6000 FF38                395      BRA return
00001380                           396      
00001380                           397      
00001380                           398  movea
00001380  13FC 0004 0000235B       399      MOVE.B  #4,(OutputType)
00001388  6100 0BEE                400      BSR     OUTPUT
0000138C                           401  
0000138C  43F9 00002368            402      LEA    moveaout,A1
00001392  13FC 0001 0000235B       403      MOVE.B  #1,(OutputType)       
0000139A  6100 0BDC                404      BSR    OUTPUT
0000139E                           405      
0000139E                           406      *now to print size  
0000139E  B47C 0002                407      cmp #2,D2 *if the size is 2 branch to long
000013A2  6700 FF58                408      BEQ long
000013A6  B47C 0003                409      cmp #3,D2 *if the size is 3 branch to word
000013AA  6700 FF3A                410      BEQ word
000013AE                           411      
000013AE  6100 06A8                412      BSR MOVE_MOVEA_EA
000013B2                           413      
000013B2  6000 FF02                414      BRA return
000013B6                           415      
000013B6                           416  moveq
000013B6  13FC 0004 0000235B       417      MOVE.B  #4,(OutputType)
000013BE  6100 0BB8                418      BSR     OUTPUT
000013C2                           419  
000013C2  43F9 0000236E            420      LEA    moveqout,A1
000013C8  13FC 0001 0000235B       421      MOVE.B  #1,(OutputType)       
000013D0  6100 0BA6                422      BSR    OUTPUT
000013D4  6100 07D0                423      BSR MOVEQ_EA
000013D8  6000 FEDC                424      BRA return
000013DC                           425  
000013DC                           426      
000013DC                           427  movem
000013DC  13FC 0004 0000235B       428      MOVE.B  #4,(OutputType)
000013E4  6100 0B92                429      BSR     OUTPUT
000013E8                           430      
000013E8  43F9 00002374            431      LEA    movemout,A1
000013EE  13FC 0001 0000235B       432      MOVE.B  #1,(OutputType)       
000013F6  6100 0B80                433      BSR    OUTPUT
000013FA                           434      
000013FA  3412                     435      MOVE.W (A2),D2
000013FC  0242 0040                436      ANDI.W #%0000000001000000, D2 * set to only the size bits
00001400  EC4A                     437      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001402  B47C 0001                438      CMP #1, D2 * if the size is 1 branch to long
00001406  6700 FEF4                439      BEQ long
0000140A  6100 FEDA                440      BSR word * otherwise branch to word
0000140E  6100 07BE                441      BSR MOVEM_EA
00001412                           442      
00001412  6000 FEA2                443      BRA return
00001416                           444  sub 
00001416  13FC 0004 0000235B       445      MOVE.B  #4,(OutputType)
0000141E  6100 0B58                446      BSR     OUTPUT
00001422                           447     
00001422  43F9 0000237A            448      LEA    subout,A1
00001428  13FC 0001 0000235B       449      MOVE.B  #1,(OutputType)       
00001430  6100 0B46                450      BSR    OUTPUT
00001434                           451      
00001434  3412                     452      MOVE.W (A2),D2
00001436  0242 00C0                453      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000143A  EC4A                     454      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000143C                           455  
0000143C                           456  
0000143C                           457      
0000143C                           458      *now to print size  
0000143C  B47C 0002                459      cmp #2,D2 *if the size is 2 branch to long
00001440  6700 FEBA                460      BEQ long
00001444  B47C 0001                461      cmp #1,D2 *if the size is 1 branch to word
00001448  6700 FE9C                462      BEQ word
0000144C  6100 FE82                463      BSR byte *otherwise branch to byte
00001450  6100 0644                464      BSR EA_GROUP1
00001454  6000 FE60                465      BRA return
00001458                           466      
00001458                           467  addq 
00001458  13FC 0004 0000235B       468      MOVE.B  #4,(OutputType)
00001460  6100 0B16                469      BSR     OUTPUT
00001464                           470     
00001464  43F9 00002387            471      LEA    addqout,A1
0000146A  13FC 0001 0000235B       472      MOVE.B  #1,(OutputType)       
00001472  6100 0B04                473      BSR    OUTPUT
00001476                           474      
00001476  3412                     475      MOVE.W (A2),D2
00001478  0242 00C0                476      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000147C  EC4A                     477      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000147E                           478  
0000147E                           479  
0000147E                           480      
0000147E                           481      *now to print size  
0000147E  B47C 0002                482      cmp #2,D2 *if the size is 2 branch to long
00001482  6700 FE78                483      BEQ long
00001486  B47C 0001                484      cmp #1,D2 *if the size is 1 branch to word
0000148A  6700 FE5A                485      BEQ word
0000148E  6100 FE40                486      BSR byte *otherwise branch to byte
00001492  6100 06EA                487          BSR ADDQ_EA
00001496                           488  
00001496  6000 FE1E                489      BRA return    
0000149A                           490      
0000149A                           491      
0000149A                           492  add
0000149A  13FC 0004 0000235B       493      MOVE.B  #4,(OutputType)
000014A2  6100 0AD4                494      BSR     OUTPUT
000014A6                           495  
000014A6  43F9 0000237E            496      LEA    addout,A1
000014AC  13FC 0001 0000235B       497      MOVE.B  #1,(OutputType)       
000014B4  6100 0AC2                498      BSR    OUTPUT
000014B8                           499      
000014B8  3412                     500      MOVE.W (A2),D2
000014BA  0242 00C0                501      ANDI.W #%0000000011000000, D2 * set to only the size bits
000014BE  EC4A                     502      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000014C0                           503  
000014C0                           504  
000014C0                           505      
000014C0                           506      *now to print size  
000014C0  B47C 0002                507      cmp #2,D2 *if the size is 2 branch to long
000014C4  6700 FE36                508      BEQ long
000014C8  B47C 0001                509      cmp #1,D2 *if the size is 1 branch to word
000014CC  6700 FE18                510      BEQ word
000014D0  6100 FDFE                511      BSR byte *otherwise branch to byte
000014D4  6100 05C0                512          BSR EA_GROUP1
000014D8                           513  
000014D8  6000 FDDC                514      BRA return
000014DC                           515  
000014DC                           516  adda
000014DC                           517  
000014DC  13FC 0004 0000235B       518      MOVE.B  #4,(OutputType)
000014E4  6100 0A92                519      BSR     OUTPUT
000014E8                           520  
000014E8  43F9 00002382            521      LEA    addaout,A1
000014EE  13FC 0001 0000235B       522      MOVE.B  #1,(OutputType)       
000014F6  6100 0A80                523      BSR    OUTPUT
000014FA                           524      
000014FA  3412                     525      MOVE.W (A2),D2
000014FC  0242 0100                526      ANDI.W #%0000000100000000, D2 * set to only the size bit
00001500  E04A                     527      LSR #8,D2 * make the size bits the first two bits in D2 LSig word
00001502                           528  
00001502                           529  
00001502                           530      
00001502                           531      *now to print size  
00001502  B47C 0001                532      cmp #1,D2 *if the size is 1 branch to long
00001506  6700 FDF4                533      BEQ long
0000150A  B47C 0000                534      cmp #0,D2 *if the size is 0 branch to word
0000150E  6700 FDD6                535      BEQ word
00001512  6100 062E                536          BSR EA_GROUP4
00001516                           537     
00001516  6000 FD9E                538      BRA return
0000151A                           539  
0000151A                           540      
0000151A                           541  rts
0000151A  13FC 0004 0000235B       542      MOVE.B  #4,(OutputType)
00001522  6100 0A54                543      BSR     OUTPUT
00001526                           544  
00001526  43F9 000023C3            545      LEA    rtsout,A1
0000152C  13FC 0001 0000235B       546      MOVE.B  #1,(OutputType)       
00001534  6100 0A42                547      BSR    OUTPUT
00001538  6100 05A6                548          BSR EA_GROUP2
0000153C                           549  
0000153C  6000 FD78                550      BRA return
00001540                           551      
00001540                           552      
00001540                           553  jsr 
00001540  13FC 0004 0000235B       554      MOVE.B  #4,(OutputType)
00001548  6100 0A2E                555      BSR     OUTPUT
0000154C                           556     
0000154C  43F9 000023BF            557      LEA    jsrout,A1
00001552  13FC 0001 0000235B       558      MOVE.B  #1,(OutputType)       
0000155A  6100 0A1C                559      BSR    OUTPUT
0000155E  6100 0580                560          BSR EA_GROUP2
00001562                           561  
00001562  6000 FD52                562      BRA return
00001566                           563      
00001566                           564      
00001566                           565  not 
00001566  13FC 0004 0000235B       566      MOVE.B  #4,(OutputType)
0000156E  6100 0A08                567      BSR     OUTPUT
00001572                           568    
00001572  43F9 00002390            569      LEA    notout,A1
00001578  13FC 0001 0000235B       570      MOVE.B  #1,(OutputType)       
00001580  6100 09F6                571      BSR    OUTPUT
00001584                           572      
00001584  3412                     573      MOVE.W (A2),D2
00001586  0242 00C0                574      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000158A  EC4A                     575      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
0000158C                           576  
0000158C                           577      *now to print size  
0000158C  B47C 0002                578      cmp #2,D2 *if the size is 2 branch to long
00001590  6700 FD6A                579      BEQ long
00001594  B47C 0001                580      cmp #1,D2 *if the size is 1 branch to word
00001598  6700 FD4C                581      BEQ word
0000159C  6100 FD32                582      BSR byte *otherwise branch to byte
000015A0                           583      
000015A0  6100 0584                584      BSR EA_GROUP3
000015A4                           585      
000015A4  6000 FD10                586      BRA return
000015A8                           587  
000015A8                           588  lsl
000015A8  13FC 0004 0000235B       589      MOVE.B  #4,(OutputType)
000015B0  6100 09C6                590      BSR     OUTPUT
000015B4                           591  
000015B4  43F9 0000239B            592      LEA    lslout,A1
000015BA  13FC 0001 0000235B       593      MOVE.B  #1,(OutputType)       
000015C2  6100 09B4                594      BSR    OUTPUT
000015C6                           595      
000015C6  3412                     596      MOVE.W (A2),D2
000015C8  0242 00C0                597      ANDI.W #%0000000011000000, D2 * set to only the size bits
000015CC  EC4A                     598      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000015CE                           599  
000015CE                           600  
000015CE                           601      
000015CE                           602      *now to print size  
000015CE  B47C 0002                603      cmp #2,D2 *if the size is 2 branch to long
000015D2  6700 FD28                604      BEQ long
000015D6  B47C 0001                605      cmp #1,D2 *if the size is 1 branch to word
000015DA  6700 FD0A                606      BEQ word
000015DE  6100 FCF0                607      BSR byte *otherwise branch to byte
000015E2  6100 04FC                608          BSR EA_GROUP2
000015E6                           609  
000015E6  6000 FCCE                610      BRA return
000015EA                           611  
000015EA                           612  lsr
000015EA  13FC 0004 0000235B       613      MOVE.B  #4,(OutputType)
000015F2  6100 0984                614      BSR     OUTPUT
000015F6                           615  
000015F6  43F9 0000239F            616      LEA    lsrout,A1
000015FC  13FC 0001 0000235B       617      MOVE.B  #1,(OutputType)       
00001604  6100 0972                618      BSR    OUTPUT
00001608                           619      
00001608  3412                     620      MOVE.W (A2),D2
0000160A  0242 00C0                621      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000160E  EC4A                     622      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001610                           623  
00001610                           624  
00001610                           625      
00001610                           626      *now to print size  
00001610  B47C 0002                627      cmp #2,D2 *if the size is 2 branch to long
00001614  6700 FCE6                628      BEQ long
00001618  B47C 0001                629      cmp #1,D2 *if the size is 1 branch to word
0000161C  6700 FCC8                630      BEQ word
00001620  6100 FCAE                631      BSR byte *otherwise branch to byte
00001624  6100 04BA                632          BSR EA_GROUP2
00001628                           633  
00001628  6000 FC8C                634      BRA return
0000162C                           635  asl
0000162C  13FC 0004 0000235B       636      MOVE.B  #4,(OutputType)
00001634  6100 0942                637      BSR     OUTPUT
00001638                           638  
00001638  43F9 000023A3            639      LEA    aslout,A1
0000163E  13FC 0001 0000235B       640      MOVE.B  #1,(OutputType)       
00001646  6100 0930                641      BSR    OUTPUT
0000164A                           642      
0000164A  3412                     643      MOVE.W (A2),D2
0000164C  0242 00C0                644      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001650  EC4A                     645      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001652                           646  
00001652                           647  
00001652                           648      
00001652                           649      *now to print size  
00001652  B47C 0002                650      cmp #2,D2 *if the size is 2 branch to long
00001656  6700 FCA4                651      BEQ long
0000165A  B47C 0001                652      cmp #1,D2 *if the size is 1 branch to word
0000165E  6700 FC86                653      BEQ word
00001662  6100 FC6C                654      BSR byte *otherwise branch to byte
00001666  6100 0478                655          BSR EA_GROUP2
0000166A                           656  
0000166A  6000 FC4A                657      BRA return
0000166E                           658  
0000166E                           659  asr
0000166E  13FC 0004 0000235B       660      MOVE.B  #4,(OutputType)
00001676  6100 0900                661      BSR     OUTPUT
0000167A                           662  
0000167A  43F9 000023A7            663      LEA    asrout,A1
00001680  13FC 0001 0000235B       664      MOVE.B  #1,(OutputType)       
00001688  6100 08EE                665      BSR    OUTPUT
0000168C                           666      
0000168C  3412                     667      MOVE.W (A2),D2
0000168E  0242 00C0                668      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001692  EC4A                     669      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001694                           670  
00001694                           671  
00001694                           672      
00001694                           673      *now to print size  
00001694  B47C 0002                674      cmp #2,D2 *if the size is 2 branch to long
00001698  6700 FC62                675      BEQ long
0000169C  B47C 0001                676      cmp #1,D2 *if the size is 1 branch to word
000016A0  6700 FC44                677      BEQ word
000016A4  6100 FC2A                678      BSR byte *otherwise branch to byte
000016A8  6100 0436                679          BSR EA_GROUP2
000016AC                           680  
000016AC  6000 FC08                681      BRA return
000016B0                           682      
000016B0                           683  rol
000016B0  13FC 0004 0000235B       684      MOVE.B  #4,(OutputType)
000016B8  6100 08BE                685      BSR     OUTPUT
000016BC                           686  
000016BC  43F9 000023AB            687      LEA    rolout,A1
000016C2  13FC 0001 0000235B       688      MOVE.B  #1,(OutputType)       
000016CA  6100 08AC                689      BSR    OUTPUT
000016CE                           690      
000016CE  3412                     691      MOVE.W (A2),D2
000016D0  0242 00C0                692      ANDI.W #%0000000011000000, D2 * set to only the size bits
000016D4  EC4A                     693      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000016D6                           694  
000016D6                           695  
000016D6                           696      
000016D6                           697      *now to print size  
000016D6  B47C 0002                698      cmp #2,D2 *if the size is 2 branch to long
000016DA  6700 FC20                699      BEQ long
000016DE  B47C 0001                700      cmp #1,D2 *if the size is 1 branch to word
000016E2  6700 FC02                701      BEQ word
000016E6  6100 FBE8                702      BSR byte *otherwise branch to byte
000016EA  6100 03F4                703          BSR EA_GROUP2
000016EE                           704  
000016EE  6000 FBC6                705      BRA return
000016F2                           706  
000016F2                           707  ror
000016F2  13FC 0004 0000235B       708      MOVE.B  #4,(OutputType)
000016FA  6100 087C                709      BSR     OUTPUT
000016FE                           710  
000016FE  43F9 000023AF            711      LEA    rorout,A1
00001704  13FC 0001 0000235B       712      MOVE.B  #1,(OutputType)       
0000170C  6100 086A                713      BSR    OUTPUT
00001710                           714      
00001710  3412                     715      MOVE.W (A2),D2
00001712  0242 00C0                716      ANDI.W #%0000000011000000, D2 * set to only the size bits
00001716  EC4A                     717      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001718                           718  
00001718                           719  
00001718                           720      
00001718                           721      *now to print size  
00001718  B47C 0002                722      cmp #2,D2 *if the size is 2 branch to long
0000171C  6700 FBDE                723      BEQ long
00001720  B47C 0001                724      cmp #1,D2 *if the size is 1 branch to word
00001724  6700 FBC0                725      BEQ word
00001728  6100 FBA6                726      BSR byte *otherwise branch to byte
0000172C  6100 03B2                727          BSR EA_GROUP2
00001730                           728  
00001730  6000 FB84                729      BRA return
00001734                           730      
00001734                           731      
00001734                           732  
00001734                           733  lea
00001734  13FC 0004 0000235B       734      MOVE.B  #4,(OutputType)
0000173C  6100 083A                735      BSR     OUTPUT
00001740                           736  
00001740  43F9 0000238C            737      LEA    leaout,A1
00001746  13FC 0001 0000235B       738      MOVE.B  #1,(OutputType)       
0000174E  6100 0828                739      BSR    OUTPUT
00001752  6100 03EE                740          BSR EA_GROUP4
00001756                           741  
00001756  6000 FB5E                742      BRA return
0000175A                           743      
0000175A                           744  or
0000175A  13FC 0004 0000235B       745      MOVE.B  #4,(OutputType)
00001762  6100 0814                746      BSR     OUTPUT
00001766                           747  
00001766  43F9 00002394            748      LEA    orout,A1
0000176C  13FC 0001 0000235B       749      MOVE.B  #1,(OutputType)       
00001774  6100 0802                750      BSR    OUTPUT
00001778                           751      
00001778                           752          
00001778  3412                     753      MOVE.W (A2),D2
0000177A  0242 00C0                754      ANDI.W #%0000000011000000, D2 * set to only the size bits
0000177E  EC4A                     755      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
00001780                           756  
00001780                           757      *now to print size  
00001780  B47C 0002                758      cmp #2,D2 *if the size is 2 branch to long
00001784  6700 FB76                759      BEQ long
00001788  B47C 0001                760      cmp #1,D2 *if the size is 1 branch to word
0000178C  6700 FB58                761      BEQ word
00001790  6100 FB3E                762      BSR byte *otherwise branch to byte
00001794  6100 0300                763      BSR EA_GROUP1
00001798  6000 FB1C                764      BRA return
0000179C                           765      
0000179C                           766  and
0000179C  13FC 0004 0000235B       767      MOVE.B  #4,(OutputType)
000017A4  6100 07D2                768      BSR     OUTPUT
000017A8                           769  
000017A8  43F9 00002397            770      LEA    andout,A1
000017AE  13FC 0001 0000235B       771      MOVE.B  #1,(OutputType)       
000017B6  6100 07C0                772      BSR    OUTPUT
000017BA                           773      
000017BA                           774          
000017BA  3412                     775      MOVE.W (A2),D2
000017BC  0242 00C0                776      ANDI.W #%0000000011000000, D2 * set to only the size bits
000017C0  EC4A                     777      LSR #6,D2 * make the size bits the first two bits in D2 LSig word
000017C2                           778  
000017C2                           779      *now to print size  
000017C2  B47C 0002                780      cmp #2,D2 *if the size is 2 branch to long
000017C6  6700 FB34                781      BEQ long
000017CA  B47C 0001                782      cmp #1,D2 *if the size is 1 branch to word
000017CE  6700 FB16                783      BEQ word
000017D2  6100 FAFC                784      BSR byte *otherwise branch to byte
000017D6  6100 02BE                785      BSR EA_GROUP1
000017DA  6000 FADA                786      BRA return    
000017DE                           787  
000017DE                           788  bcc
000017DE  4243                     789      CLR D3
000017E0  3612                     790      MOVE.W (A2), D3
000017E2                           791      
000017E2  0243 0F00                792      ANDI.W #%0000111100000000,D3 * bits [11-8]
000017E6  E04B                     793      LSR.W #8,D3
000017E8  B67C 000E                794      CMP #%1110, D3 * BGT compare
000017EC  6700 0016                795      BEQ bgt
000017F0  B67C 000F                796      CMP #%1111, D3 * BLE compare
000017F4  6700 0030                797      BEQ ble
000017F8  B67C 0007                798      CMP #%0111, D3 * BEQ compare
000017FC  6700 004A                799      BEQ beq
00001800  6000 008A                800      BRA data * goto data if doesn't work
00001804                           801  
00001804                           802  bgt
00001804  13FC 0004 0000235B       803      MOVE.B  #4,(OutputType)
0000180C  6100 076A                804      BSR     OUTPUT
00001810                           805  
00001810  43F9 000023B3            806      LEA    bgtout,A1
00001816  13FC 0001 0000235B       807      MOVE.B  #1,(OutputType)       
0000181E  6100 0758                808      BSR    OUTPUT
00001822  6000 FA92                809      BRA return
00001826                           810  
00001826                           811  ble
00001826  13FC 0004 0000235B       812      MOVE.B  #4,(OutputType)
0000182E  6100 0748                813      BSR     OUTPUT
00001832                           814  
00001832  43F9 000023B7            815      LEA    bleout,A1
00001838  13FC 0001 0000235B       816      MOVE.B  #1,(OutputType)       
00001840  6100 0736                817      BSR    OUTPUT
00001844  6000 FA70                818      BRA return
00001848                           819  beq
00001848  13FC 0004 0000235B       820      MOVE.B  #4,(OutputType)
00001850  6100 0726                821      BSR     OUTPUT
00001854                           822  
00001854  43F9 000023BB            823      LEA    beqout,A1
0000185A  13FC 0001 0000235B       824      MOVE.B  #1,(OutputType)       
00001862  6100 0714                825      BSR    OUTPUT
00001866  6000 FA4E                826      BRA return
0000186A                           827  
0000186A                           828  bra
0000186A  13FC 0004 0000235B       829      MOVE.B  #4,(OutputType)
00001872  6100 0704                830      BSR     OUTPUT
00001876                           831  
00001876  43F9 000023C9            832      LEA    braout,A1
0000187C  13FC 0001 0000235B       833      MOVE.B  #1,(OutputType)       
00001884  6100 06F2                834      BSR    OUTPUT
00001888  6000 FA2C                835      BRA return
0000188C                           836  
0000188C                           837  data
0000188C  13FC 0004 0000235B       838      MOVE.B  #4,(OutputType)
00001894  6100 06E2                839      BSR     OUTPUT
00001898                           840  
00001898  43F9 000023CD            841      LEA    dataout,A1
0000189E  13FC 0001 0000235B       842      MOVE.B  #1,(OutputType)       
000018A6  6100 06D0                843      BSR    OUTPUT
000018AA                           844      
000018AA  13FC 0003 0000235B       845      MOVE.B  #3,(OutputType)       
000018B2  6100 06C4                846      BSR    OUTPUT     
000018B6  6000 F9FE                847      BRA return
000018BA                           848  
000018BA                           849  
000018BA                           850  **********************************************************
000018BA                           851  *Subroutine: USERINPUT
000018BA                           852  *What it does: Takes in user input, rejects bad input
000018BA                           853  *Registers: Uses register A1, D0, D5
000018BA                           854  *A1: Stores messages and user input
000018BA                           855  *D0: Used for TRAP #15
000018BA                           856  *D5: Temporaraly stores user input to be masked then transfered
000018BA                           857  *Paramemeters: No parameters
000018BA                           858  **********************************************************
000018BA                           859  USERINPUT:
000018BA  4281                     860      CLR.L   D1
000018BC  4282                     861      CLR.L   D2
000018BE  4283                     862      CLR.L   D3
000018C0  4284                     863      CLR.L   D4
000018C2  4285                     864      CLR.L   D5
000018C4  0C39 0000 0000235C       865      CMP.B   #0,(RepeatFlag)
000018CC  6700 001A                866      BEQ     welcomeExplanation
000018D0  6000 0030                867      BRA     firstInput
000018D4  02B9 00000000 00008000   868      AND.L   #$00000000,(Input1)
000018DE  02B9 00000000 00008004   869      AND.L   #$00000000,(Input2)
000018E8                           870      
000018E8                           871  welcomeExplanation
000018E8  43F9 000020CE            872      LEA     STARTMESSAGE,A1         
000018EE  103C 000E                873      MOVE.B  #14,D0
000018F2  4E4F                     874      TRAP    #15
000018F4                           875      
000018F4  5039 0000235A            876      ADD.B   #8,(LineCounter)
000018FA  13FC 0001 0000235C       877      MOVE.B  #1,(RepeatFlag)
00001902                           878  
00001902                           879  firstInput
00001902  43F9 00002240            880      LEA     INPUT1MESSAGE,A1        
00001908  103C 000E                881      MOVE.B  #14,D0                  
0000190C  4E4F                     882      TRAP    #15                     Asks user for first input
0000190E  5239 0000235A            883      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001914                           884      
00001914  43F9 00008008            885      LEA     userInputStored,A1
0000191A  103C 0002                886      MOVE.B  #2,D0                   
0000191E  4E4F                     887      TRAP    #15                     User can input string for address
00001920  5239 0000235A            888      ADD.B   #1,(LineCounter)        Adds 1 to line counter
00001926                           889  
00001926                           890      
00001926  6100 00BC                891      BSR     CONVERTATOH                 String converted to hex address
0000192A                           892      
0000192A  0C39 0000 00002359       893      CMP.B   #0,(InputQuality)       Checks if bad input flag set
00001932  6700 0014                894      BEQ     throwInput1CharError
00001936                           895  
00001936                           896      
00001936  CABC 00FFFFFF            897      AND.L   #$00FFFFFF,D5
0000193C  23C5 00008000            898      MOVE.L  D5,input1               Moves result into input 1 memory location
00001942  4285                     899      CLR.L   D5                      Clears D5 for future use
00001944  6000 0020                900      BRA     secondInput
00001948                           901      
00001948                           902  throwInput1CharError
00001948  43F9 0000228C            903      LEA     INPUTERRORBADCHAR,A1
0000194E  103C 000E                904      MOVE.B  #14,D0
00001952  4E4F                     905      TRAP    #15                     Outputs bad character error message
00001954  5639 0000235A            906      ADD.B   #3,(LineCounter)        Adds 2 to line counter
0000195A                           907      
0000195A  13FC 0001 00002359       908      MOVE.B  #1,(InputQuality)       Resets quality flag to default (good)
00001962  4285                     909      CLR.L   D5                      Clears D5 for future use
00001964                           910      
00001964                           911      
00001964                           912      
00001964  609C                     913      BRA     firstInput              Tries again for input1
00001966                           914  
00001966                           915      
00001966                           916  secondInput
00001966  43F9 00002266            917      LEA     INPUT2MESSAGE,A1        
0000196C  103C 000E                918      MOVE.B  #14,D0                  
00001970  4E4F                     919      TRAP    #15                     Asks user for second input
00001972  5239 0000235A            920      ADD.B   #1,(LineCounter)
00001978                           921      
00001978  43F9 00008008            922      LEA     userInputStored,A1
0000197E  103C 0002                923      MOVE.B  #2,D0                   
00001982  4E4F                     924      TRAP    #15                     User can input string for address
00001984  5239 0000235A            925      ADD.B   #1,(LineCounter)
0000198A                           926  
0000198A                           927      
0000198A  6100 0058                928      BSR     CONVERTATOH                 String converted to hex address
0000198E                           929  
0000198E  0C39 0000 00002359       930      CMP.B   #0,(InputQuality)       
00001996  6700 001C                931      BEQ     throwInput2CharError    Checks if bad input flag set
0000199A                           932      
0000199A  CABC 00FFFFFF            933      AND.L   #$00FFFFFF,D5
000019A0  BAB9 00008000            934      CMP.L   (input1),D5
000019A6  6D00 0028                935      BLT     throwInput2LowerError
000019AA                           936      
000019AA                           937      
000019AA                           938      
000019AA  23C5 00008004            939      MOVE.L  D5,input2               Moves result into input 2 memory location
000019B0  4285                     940      CLR.L   D5                      Clears D5 for future use
000019B2  4E75                     941      RTS    
000019B4                           942      
000019B4                           943  throwInput2CharError
000019B4  43F9 0000228C            944      LEA     INPUTERRORBADCHAR,A1    
000019BA  103C 000E                945      MOVE.B  #14,D0
000019BE  4E4F                     946      TRAP    #15                     Outputs bad character error message
000019C0                           947      
000019C0  5639 00002359            948      ADD.B  #3,(InputQuality)        Resets quality flag to default (good)
000019C6  4285                     949      CLR.L   D5                      Clears D5 for future use
000019C8                           950      
000019C8  5639 0000235A            951      ADD.B   #3,(LineCounter)
000019CE                           952      
000019CE  6096                     953      BRA     secondInput             Tries again for input2
000019D0                           954      
000019D0                           955  throwInput2LowerError
000019D0  43F9 000022AA            956      LEA     INPUTERROR2SMALLER,A1
000019D6  103C 000E                957      MOVE.B  #14,D0
000019DA  4E4F                     958      TRAP    #15
000019DC                           959      
000019DC  5639 0000235A            960      ADD.B   #3,(LineCounter)
000019E2                           961      
000019E2  6082                     962      BRA     secondInput
000019E4                           963  
000019E4                           964  
000019E4                           965  **********************************************************
000019E4                           966  *Subroutine: CONVERTATOH
000019E4                           967  *What it does: Converts user input to hex code
000019E4                           968  *Registers: Uses register A1, D2, D5
000019E4                           969  *Paramemeters: User input stored in (A1)
000019E4                           970  ********************************************************** 
000019E4                           971  CONVERTATOH:
000019E4                           972      
000019E4                           973  AtoH
000019E4  1419                     974      MOVE.B  (A1)+,D2                Takes first bit (letter), moves to D2 for testing
000019E6                           975      
000019E6  B43C 0000                976      CMP.B   #$00,D2                 Compares to 00, since 00 is null (enter)
000019EA  6700 004C                977      BEQ     Finish                  Moves to finish if they are equal (no more input)
000019EE                           978      
000019EE  E985                     979      ASL.L   #4,D5
000019F0                           980      
000019F0  B43C 0030                981      CMP.B   #$30,D2
000019F4  6D00 0044                982      BLT     inputError
000019F8                           983      
000019F8  B43C 0039                984      CMP.B   #$39,D2                 Compares to 39, because 39 in ASCII is 9, which is largest number
000019FC  6E00 000A                985      BGT     upperCase               Branches if greater, may or may not be a letter in hex
00001A00                           986      
00001A00  0402 0030                987      SUBI.B  #$30,D2                 Subtracts 30 to turn it into it's hex format
00001A04  DA02                     988      ADD.B   D2,D5
00001A06                           989      
00001A06  60DC                     990      BRA     AtoH
00001A08                           991  
00001A08                           992          
00001A08                           993  upperCase   
00001A08  B43C 0041                994      CMP.B   #$41,D2
00001A0C  6D00 002C                995      BLT     InputError              Greater than 39 and less than 41 is not part of hex code
00001A10                           996      
00001A10  B43C 0046                997      CMP.B   #$46,D2                 
00001A14  6E00 000A                998      BGT     lowerCase               Greater than 46 may be hex code in lowercase
00001A18                           999      
00001A18  0402 0037               1000      SUBI.B  #$37,D2                 Subtracts 37 to turn it into hex format
00001A1C  DA02                    1001      ADD.B   D2,D5
00001A1E  60C4                    1002      BRA     AtoH
00001A20                          1003  
00001A20                          1004  lowerCase
00001A20  B43C 0061               1005      CMP.B   #$61,D2
00001A24  6D00 0014               1006      BLT     InputError              Greater than 46 and less than 61 is not part of hex code
00001A28                          1007      
00001A28  B43C 0066               1008      CMP.B   #$66,D2
00001A2C  6E00 000C               1009      BGT     InputError              Greater than 66 is not part of hex code
00001A30                          1010      
00001A30  0402 0057               1011      SUBI.B  #$57,D2
00001A34  DA02                    1012      ADD.B   D2,D5
00001A36  60AC                    1013      BRA     AtoH
00001A38                          1014          
00001A38                          1015  Finish
00001A38  4E75                    1016      RTS                             Return from CONVERT
00001A3A                          1017      
00001A3A                          1018  inputError
00001A3A  13FC 0000 00002359      1019      MOVE.B  #0,(InputQuality)
00001A42  4E75                    1020      RTS
00001A44                          1021  
00001A44                          1022  *********************************************************************
00001A44                          1023  *Subroutine: EA
00001A44                          1024  *What it does: Outputs parts of opword, moves to new screen if needed
00001A44                          1025  *Registers: Uses register A1, D0,
00001A44                          1026  *A1: Used to store messages and single char
00001A44                          1027  *Paramemeters: A1
00001A44                          1028  *A1: Stores what should be used--++
00001A44                          1029  *********************************************************************  
00001A44  =0000003F               1030  BITS0TO5_MASK   EQU %00111111
00001A44  =000000C0               1031  BITS7TO8_MASK   EQU %11000000
00001A44  =00000E00               1032  BITS9TO11_MASK  EQU %00000111000000000
00001A44                          1033  
00001A44  1E3C 000A               1034  FORMAT_IMMEDIATE_DATA   MOVE.B  #10,D7
00001A48  BC7C 0000               1035                          CMP     #0,D6
00001A4C  6700 0006               1036                          BEQ     IMMEDIATE0
00001A50  6000 0004               1037                          BRA     IMMEDIATE_END
00001A54  7C08                    1038  IMMEDIATE0              MOVEQ   #8,D6
00001A56                          1039  
00001A56  4E75                    1040  IMMEDIATE_END           RTS
00001A58                          1041  
00001A58  3212                    1042  MOVE_MOVEA_EA   MOVE.W  (A2),D1
00001A5A  0201 003F               1043                  ANDI.B  #BITS0TO5_MASK,D1           * Isolate the source EA bits
00001A5E  0001 00C0               1044                  ORI.B   #BITS7TO8_MASK,D1           * Populate the S and D bits
00001A62  1C01                    1045                  MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001A64  3212                    1046                  MOVE.W  (A2),D1         
00001A66  3412                    1047                  MOVE.W  (A2),D2 
00001A68  0241 0E00               1048                  ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001A6C  163C 0009               1049                  MOVE.B  #9,D3                   * Prepare shift count
00001A70  E669                    1050                  LSR.W   D3,D1                   * Move destination register bits right
00001A72  0242 01C0               1051                  ANDI.W  #%0000000111000000,D2   * Isolate the destination mode
00001A76  E64A                    1052                  LSR.W   #3,D2                  * Move destination mode bits right
00001A78  8242                    1053                  OR.W    D2,D1
00001A7A  1A01                    1054                  MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001A7C  1206                    1055                  MOVE.B  D6,D1               * Pass source into subroutine
00001A7E  4EB9 00001C40           1056                  JSR     CHECK_VALID_EA
00001A84  1205                    1057                  MOVE.B  D5,D1               * Pass destination into subroutine
00001A86  4EB9 00001C40           1058                  JSR     CHECK_VALID_EA
00001A8C  6100 01F6               1059                  BSR print_EA
00001A90  6100 0496               1060                  BSR print_NEWLINE
00001A94                          1061                  
00001A94  4E75                    1062                  RTS
00001A96                          1063  *should be for the following opcodes- MOVEA, ADD, SUB, AND, OR 
00001A96  3212                    1064  EA_GROUP1     MOVE.W  (A2),D1                 * Prepare to capture register field
00001A98  3412                    1065          MOVE.W  (A2),D2                 * Prepare to capture EA field
00001A9A  0201 003F               1066          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001A9E                          1067          
00001A9E  0242 0E00               1068          ANDI.W  #BITS9TO11_MASK,D2      * Isolate the source EA bits
00001AA2  163C 0009               1069          MOVE.B  #9,D3                   * Prepare shift count
00001AA6  E66A                    1070          LSR.W   D3,D2                   * Move register bits right
00001AA8  0202 00C7               1071          ANDI.B  #%11000111,D2           * Set EA mode
00001AAC  3612                    1072          MOVE.W  (A2),D3
00001AAE  0803 0008               1073          BTST    #8,D3                   * Check opmode
00001AB2  6700 000A               1074          BEQ     EA1_MODE_ZERO           * Check opmode
00001AB6                          1075          
00001AB6  3A01                    1076  EA1_MODE_ONE    MOVE.W  D1,D5           * Set EA as destination
00001AB8  3C02                    1077                  MOVE.W  D2,D6           * Set register as source
00001ABA  6000 0006               1078                  BRA EA1_END             * Complete subroutine
00001ABE                          1079          
00001ABE  3C01                    1080  EA1_MODE_ZERO   MOVE.W  D1,D6           * Set EA as source
00001AC0  3A02                    1081                  MOVE.W  D2,D5           * Set register as destination
00001AC2                          1082  
00001AC2  0006 00C0               1083  EA1_END         ORI.B   #BITS7TO8_MASK,D6       * Populate the S and D bits
00001AC6  1206                    1084                  MOVE.B  D6,D1               * Pass source into subroutine
00001AC8  4EB9 00001C40           1085                  JSR     CHECK_VALID_EA
00001ACE  1205                    1086                  MOVE.B  D5,D1               * Pass destination into subroutine
00001AD0  4EB9 00001C40           1087                  JSR     CHECK_VALID_EA
00001AD6  6100 01AC               1088                  BSR print_EA
00001ADA  6100 044C               1089                  BSR print_NEWLINE
00001ADE                          1090  
00001ADE  4E75                    1091                  RTS
00001AE0                          1092  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001AE0  3C12                    1093  EA_GROUP2             MOVE.W  (A2),D6         * Prepare to capture source EA
00001AE2  0246 0E00               1094                  ANDI.W  #BITS9TO11_MASK,D6      * Isolate the source EA bits
00001AE6  163C 0009               1095                  MOVE.B  #9,D3                   * Prepare shift count
00001AEA  E66E                    1096                  LSR.W   D3,D6                   * Move register bits right
00001AEC  3612                    1097                  MOVE.W  (A2),D3
00001AEE  0803 0005               1098                  BTST    #5,D3           * Check whether shift count is immediate
00001AF2  6700 000A               1099                  BEQ     EA2_IMMEDIATE
00001AF6                          1100   
00001AF6  0006 00C0               1101  EA2_REGISTER    ORI.B   #%11000000,D6   * Set S and D bits
00001AFA  6000 000A               1102                  BRA     EA2_END         * Complete subroutine
00001AFE                          1103                  
00001AFE  1E3C 000A               1104  EA2_IMMEDIATE   MOVE.B  #10,D7          * Prepare to pass immediate data to print subroutine
00001B02  4EB8 1A44               1105                  JSR     FORMAT_IMMEDIATE_DATA
00001B06                          1106                  
00001B06  3A12                    1107  EA2_END         MOVE.W  (A2),D5         * Prepare to capture destination EA
00001B08  CA3C 0007               1108                  AND.B   #%00000111,D5
00001B0C  1206                    1109                  MOVE.B  D6,D1               * Pass source into subroutine
00001B0E  4EB9 00001C40           1110                  JSR     CHECK_VALID_EA
00001B14  1205                    1111                  MOVE.B  D5,D1               * Pass destination into subroutine
00001B16  4EB9 00001C40           1112                  JSR     CHECK_VALID_EA
00001B1C  6100 0166               1113                  BSR print_EA
00001B20  6100 0406               1114                  BSR print_NEWLINE
00001B24  4E75                    1115                  RTS   
00001B26                          1116  
00001B26                          1117  
00001B26                          1118  *should be for opcode LSL LSR ASL ASR ROL ROR but for register shifts
00001B26  3C12                    1119  EA_GROUP3     MOVE.W  (A2),D6
00001B28  0206 003F               1120          ANDI.B  #BITS0TO5_MASK,D6       * Isolate the source EA bits
00001B2C  0006 0080               1121          ORI.B   #%10000000,D6
00001B30  1206                    1122          MOVE.B  D6,D1               * Pass source into subroutine
00001B32  4EB9 00001C40           1123          JSR     CHECK_VALID_EA
00001B38  6100 014A               1124          BSR print_EA
00001B3C  6100 03EA               1125          BSR print_NEWLINE
00001B40  4E75                    1126          RTS
00001B42                          1127  
00001B42                          1128  *should be for LEA and ADDA(SHOULD WORK BETTER THEN EA GROUP 1)
00001B42  3212                    1129  EA_GROUP4     MOVE.W  (A2),D1         
00001B44  0201 003F               1130          ANDI.B  #BITS0TO5_MASK,D1       * Isolate the source EA bits
00001B48  0001 00C0               1131          ORI.B   #BITS7TO8_MASK,D1       * Populate the S and D bits
00001B4C  1C01                    1132          MOVE.B  D1,D6                   * Pass source EA to print subroutine
00001B4E  3212                    1133          MOVE.W  (A2),D1         
00001B50                          1134          
00001B50  0241 0E00               1135          ANDI.W  #BITS9TO11_MASK,D1   * Isolate the destination register number
00001B54  143C 0009               1136          MOVE.B  #9,D2                   * Prepare shift count
00001B58  E469                    1137          LSR.W   D2,D1                   * Move register bits right
00001B5A  0201 00CF               1138          ANDI.B  #%11001111,D1           * Set destination mode
00001B5E  0001 0008               1139          ORI.B   #%00001000,D1           * Set destination mode
00001B62  1A01                    1140          MOVE.B  D1,D5                   * Pass destination EA to print subroutine
00001B64  1206                    1141          MOVE.B  D6,D1               * Pass source into subroutine
00001B66  4EB9 00001C40           1142          JSR     CHECK_VALID_EA
00001B6C  1205                    1143          MOVE.B  D5,D1               * Pass destination into subroutine
00001B6E  4EB9 00001C40           1144          JSR     CHECK_VALID_EA
00001B74  6100 010E               1145          BSR print_EA
00001B78  6100 03AE               1146          BSR print_NEWLINE
00001B7C  4E75                    1147          RTS
00001B7E                          1148          
00001B7E  3C12                    1149  ADDQ_EA MOVE.W  (A2),D6                 * Prepare source data bits
00001B80  0246 0E00               1150          ANDI.W  #BITS9TO11_MASK,D6      * Isolate source data bits
00001B84  163C 0009               1151          MOVE.B  #9,D3                   * Prepare shift count
00001B88  E66E                    1152          LSR.W   D3,D6                  * Move source data bits right            !---
00001B8A  3A12                    1153          MOVE.W  (A2),D5                 * Prepare destination bits
00001B8C  0205 003F               1154          ANDI.B  #BITS0TO5_MASK,D5       * Isolate destination bits
00001B90  4EB8 1A44               1155          JSR     FORMAT_IMMEDIATE_DATA
00001B94  1206                    1156          MOVE.B  D6,D1               * Pass source into subroutine
00001B96  4EB9 00001C40           1157          JSR     CHECK_VALID_EA
00001B9C  1205                    1158          MOVE.B  D5,D1               * Pass destination into subroutine
00001B9E  4EB9 00001C40           1159          JSR     CHECK_VALID_EA
00001BA4  4E75                    1160          RTS                                    !---
00001BA6                          1161          
00001BA6  3C12                    1162  MOVEQ_EA    MOVE.W  (A2),D6                 * Prepare source data bits          !---
00001BA8  CC7C 00FF               1163              AND.W   #$00FF,D6                                                   !---
00001BAC  3A12                    1164              MOVE.W  (A2),D5                 * Prepare destination regiter bits
00001BAE  0245 0E00               1165              ANDI.W  #BITS9TO11_MASK,D5      * Isolate destination register bits
00001BB2  163C 0009               1166              MOVE.B  #9,D3                   * Prepare shift count
00001BB6  E66D                    1167              LSR.W   D3,D5                   * Move destination register bits right
00001BB8  1E3C 000A               1168              MOVE.B  #10,D7
00001BBC  1206                    1169              MOVE.B  D6,D1               * Pass source into subroutine
00001BBE  4EB9 00001C40           1170              JSR     CHECK_VALID_EA
00001BC4  1205                    1171              MOVE.B  D5,D1               * Pass destination into subroutine
00001BC6  4EB9 00001C40           1172              JSR     CHECK_VALID_EA
00001BCC  4E75                    1173              RTS                                 !---
00001BCE                          1174  
00001BCE                          1175  
00001BCE                          1176  
00001BCE                          1177  
00001BCE  3412                    1178  MOVEM_EA   MOVE.W (A2),D2
00001BD0  0802 000A               1179             BTST    #10, D2
00001BD4  6700 003E               1180             BEQ     Register_to_memory *IF THE DIRCTION BIT IS 0, 
00001BD8                          1181            
00001BD8                          1182             
00001BD8                          1183                  
00001BD8                          1184  *ELSE IT IS  memory-to-register transfers
00001BD8                          1185  
00001BD8                          1186  
00001BD8                          1187  
00001BD8                          1188  
00001BD8                          1189     
00001BD8  E68A                    1190  Memory_to_Register LSR.L #3, D2
00001BDA  C43C 0007               1191                     AND.B #$07, D2
00001BDE  B43C 0002               1192                     CMP.B #$2,D2
00001BE2  6700 0022               1193                     BEQ   MODE_010
00001BE6  B43C 0003               1194                     CMP.B #$03, D2
00001BEA  6700 001A               1195                     BEQ   MODE_010  
00001BEE  B43C 0007               1196                     CMP.B #$07,D2
00001BF2  6700 0012               1197                     BEQ   MODE_010  
00001BF6  4EF9 00001BFC           1198                     JMP   WRONG_INSTRUCTION    
00001BFC                          1199     
00001BFC  1E3C 0005               1200  WRONG_INSTRUCTION            MOVE.B   #5, D7 ; A WRONG INSTRUCTION 'KEY'
00001C00  2C4A                    1201                               MOVEA.L  A2, A6 ;MOVING THE MEMORY ADDRESS INTO A6 WHEN INSTRUCTION IS WRONG 
00001C02  3C12                    1202                               MOVE.W  (A2),D6 ;MOVE MEMORY ADDRESS INTO D6, AND INCREMENT A2 BY WORD
00001C04  4E75                    1203                               RTS 
00001C06                          1204             
00001C06  3412                    1205  MODE_010  MOVE.W    (A2),D2
00001C08  C43C 003F               1206            AND.B     #$3F,D2
00001C0C  08C2 0007               1207            BSET      #7,D2 *SET THE DESTINATION INDICATOR
00001C10  1C02                    1208            MOVE.B    D2,D6
00001C12  4E75                    1209            RTS
00001C14                          1210  
00001C14  3412                    1211  Register_to_memory MOVE.W (A2),D2
00001C16  E68A                    1212                     LSR.L #3, D2
00001C18  C43C 0007               1213                     AND.B #$07, D2
00001C1C  B43C 0002               1214                     CMP.B #$2,D2
00001C20  6700 0016               1215                     BEQ   MODE_01_0
00001C24  B43C 0004               1216                     CMP.B #$04, D2
00001C28  6700 000E               1217                     BEQ   MODE_01_0 
00001C2C  B43C 0007               1218                     CMP.B #$07,D2
00001C30  6700 0006               1219                     BEQ   MODE_01_0 
00001C34  4EF8 1BFC               1220                     JMP   WRONG_INSTRUCTION
00001C38                          1221                     
00001C38                          1222  
00001C38  3C12                    1223  MODE_01_0       MOVE.W  (A2),D6
00001C3A  0206 003F               1224                  ANDI.B  #$3F,D6
00001C3E  4E75                    1225                  RTS
00001C40                          1226           
00001C40  1001                    1227  CHECK_VALID_EA  MOVE.B  D1,D0
00001C42  0200 0038               1228                  ANDI.B  #%111000,D0
00001C46  E648                    1229                  LSR     #3,D0
00001C48  B03C 0005               1230                  CMP.B   #%00000101,D0
00001C4C  6700 002C               1231                  BEQ     INVALID_EA
00001C50  B03C 0006               1232                  CMP.B   #%00000110,D0
00001C54  6700 0024               1233                  BEQ     INVALID_EA
00001C58  B03C 0007               1234                  CMP.B   #%00000111,D0
00001C5C  6700 0004               1235                  BEQ     VALID_EA_PC
00001C60  4E75                    1236                  RTS
00001C62                          1237                  
00001C62                          1238                  
00001C62  1001                    1239  VALID_EA_PC     MOVE.B  D1,D0
00001C64  0200 0007               1240                  ANDI.B  #%000111,D0
00001C68  B03C 0010               1241                  CMP.B   #%00010000,D0
00001C6C  6700 000C               1242                  BEQ     INVALID_EA
00001C70  B03C 0018               1243                  CMP.B   #%00011000,D0
00001C74  6700 0004               1244                  BEQ     INVALID_EA
00001C78  4E75                    1245                  RTS
00001C7A                          1246                  
00001C7A  4EB8 1BFC               1247  INVALID_EA      JSR     WRONG_INSTRUCTION
00001C7E  3A7C 0005               1248                  MOVE.W  #5, A5
00001C82  4E75                    1249                  RTS
00001C84                          1250                  
00001C84  48E7 FFDE               1251  PRINT_EA        MOVEM.L A0-A1/A3-A6/D0-D7,-(SP)
00001C88  163C 0038               1252                  MOVE.B  #$38,D3
00001C8C  C604                    1253                  AND.B   D4,D3
00001C8E  C83C 0007               1254                  AND.B   #$7, D4
00001C92                          1255                  
00001C92  B63C 0000               1256                  CMP.B   #$0, D3
00001C96  6600 0014               1257                  BNE     CHECK_EA_AR
00001C9A  0604 00D0               1258                  ADD.B   #$D0, D4
00001C9E  4281                    1259                  CLR.L   D1
00001CA0  1204                    1260                  MOVE.B  D4, D1
00001CA2  4EB9 00001E4E           1261                  JSR     PRINT_REGISTOR              * DATA REG
00001CA8  6000 0114               1262                  BRA     PRINT_EA_RETURN
00001CAC                          1263  
00001CAC  B63C 0008               1264  CHECK_EA_AR         CMP.B   #$8, D3
00001CB0  6600 0014               1265                      BNE     CHECK_EA_INDIRECT
00001CB4  0604 00A0               1266                      ADD.B   #$A0, D4
00001CB8  4281                    1267                      CLR.L   D1
00001CBA  1204                    1268                      MOVE.B  D4, D1
00001CBC  4EB9 00001E4E           1269                      JSR     PRINT_REGISTOR          * ADDRESS REG
00001CC2  6000 00FA               1270                      BRA     PRINT_EA_RETURN
00001CC6                          1271                      
00001CC6  B63C 0010               1272  CHECK_EA_INDIRECT       CMP.B   #$10, D3
00001CCA  6600 0020               1273                          BNE     CHECK_EA_POST
00001CCE  4EB9 00001EA2           1274                          JSR     PRINT_OPEN_PARENTHESIS      * (
00001CD4  0604 00A0               1275                          ADD.B   #$A0, D4
00001CD8  4281                    1276                          CLR.L   D1
00001CDA  1204                    1277                          MOVE.B  D4, D1
00001CDC  4EB9 00001E4E           1278                          JSR     PRINT_REGISTOR              * ADDRESS REG
00001CE2  4EB9 00001EB6           1279                          JSR     PRINT_CLOSED_PARENTHESIS    * )
00001CE8  6000 00D4               1280                          BRA     PRINT_EA_RETURN
00001CEC                          1281                          
00001CEC  B63C 0018               1282  CHECK_EA_POST   CMP.B   #$18,D3
00001CF0  6600 0026               1283                  BNE     CHECK_EA_PRE
00001CF4  4EB9 00001EA2           1284                  JSR     PRINT_OPEN_PARENTHESIS      * (
00001CFA  0604 00A0               1285                  ADD.B   #$A0, D4
00001CFE  4281                    1286                  CLR.L   D1
00001D00  1204                    1287                  MOVE.B  D4, D1
00001D02  4EB9 00001E4E           1288                  JSR     PRINT_REGISTOR              * ADDRESS REG
00001D08  4EB9 00001EB6           1289                  JSR     PRINT_CLOSED_PARENTHESIS    * )
00001D0E  4EB9 00001ECE           1290                  JSR     PRINT_PLUS                  * +
00001D14  6000 00A8               1291                  BRA     PRINT_EA_RETURN
00001D18                          1292  
00001D18  B63C 0020               1293  CHECK_EA_PRE        CMP.B   #$20,D3
00001D1C  6600 0026               1294                      BNE     CHECK_EA_AB_W
00001D20  4EB9 00001EE2           1295                      JSR     PRINT_MINUS                 * -
00001D26  4EB9 00001EA2           1296                      JSR     PRINT_OPEN_PARENTHESIS      * (
00001D2C  0604 00A0               1297                      ADD.B   #$A0, D4
00001D30  4281                    1298                      CLR.L   D1
00001D32  1204                    1299                      MOVE.B  D4, D1
00001D34  4EB9 00001E4E           1300                      JSR     PRINT_REGISTOR              * ADDRESS REG
00001D3A  4EB9 00001EB6           1301                      JSR     PRINT_CLOSED_PARENTHESIS    * )
00001D40  6000 007C               1302                      BRA     PRINT_EA_RETURN
00001D44                          1303  
00001D44  D604                    1304  CHECK_EA_AB_W           ADD.B   D4,D3
00001D46  B63C 0038               1305                          CMP.B   #$38,D3     
00001D4A  6600 0018               1306                          BNE     CHECK_EA_AB_L
00001D4E  4EB9 00001F50           1307                          JSR     PRINT_DOLLAR        * $
00001D54  3A1A                    1308                          MOVE.W  (A2)+,D5            * PRINTING WORD ABSOLUTE
00001D56  163C 0002               1309                          MOVE.B  #2,D3
00001D5A  4EB9 00001DE6           1310                          JSR     PRINT_HEX
00001D60  6000 005C               1311                          BRA     PRINT_EA_RETURN
00001D64                          1312                          
00001D64  B63C 0039               1313  CHECK_EA_AB_L       CMP.B   #$39, D3
00001D68  6600 0018               1314                      BNE     CHECK_EA_IMM
00001D6C  4EB9 00001F50           1315                      JSR     PRINT_DOLLAR        * $
00001D72  2A1A                    1316                      MOVE.L  (A2)+,D5            * PRINTING LONG ABSOLUTE
00001D74  163C 0004               1317                      MOVE.B  #4,D3
00001D78  4EB9 00001DE6           1318                      JSR     PRINT_HEX
00001D7E  6000 003E               1319                      BRA     PRINT_EA_RETURN
00001D82                          1320                      
00001D82  BE3C 0004               1321  CHECK_EA_IMM        CMP.B   #4,D7
00001D86  6600 001E               1322                      BNE     READ_WORD_IMM
00001D8A  4EB9 00001F3C           1323                      JSR     PRINT_HASH_SIGN     * #
00001D90  4EB9 00001F50           1324                      JSR     PRINT_DOLLAR        * $
00001D96  2A1A                    1325                      MOVE.L  (A2)+,D5            * PRINTING LONG IMMIDIATE
00001D98  163C 0004               1326                      MOVE.B  #4,D3
00001D9C  4EB9 00001DE6           1327                      JSR     PRINT_HEX
00001DA2  6000 001A               1328                      BRA     PRINT_EA_RETURN
00001DA6                          1329                      
00001DA6  4EB9 00001F3C           1330  READ_WORD_IMM       JSR     PRINT_HASH_SIGN     * #
00001DAC  4EB9 00001F50           1331                      JSR     PRINT_DOLLAR        * $
00001DB2  3A1A                    1332                      MOVE.W  (A2)+,D5            * PRINTING WORD/BYTE IMMIDIATE        
00001DB4  163C 0002               1333                      MOVE.B  #2,D3
00001DB8  4EB9 00001DE6           1334                      JSR     PRINT_HEX
00001DBE                          1335  
00001DBE  4CDF 7BFF               1336  PRINT_EA_RETURN     MOVEM.L     (SP)+,A0-A1/A3-A6/D0-D7   * THE RETURN FOR THE EA PRINTER
00001DC2  4E75                    1337                      RTS
00001DC4                          1338  ALL_REG     REG     D0-D7/A0-A6         ; all registers
00001DC4                          1339  PRINT_BUFFER    DS.B    10
00001DCE= 30 30 30 30 30 30 ...   1340  IPUT_BUFFER_EX  DC.B    '00000000'
00001DD6                          1341  INPUT_BUFFER    DS.B    15                    
00001DE6  48E7 FFFE               1342  PRINT_HEX       MOVEM.L     ALL_REG,-(SP)
00001DEA  43F8 1DC4               1343                  LEA         PRINT_BUFFER, A1        *SETTING UP PRINT BUFFER
00001DEE  D3FC 0000000A           1344                  ADD.L       #10,A1
00001DF4  133C 0000               1345                  MOVE.B      #0,-(A1)                *NULL FOR PRINTER TO STOP
00001DF8  6000 000E               1346                  BRA         POPULATE_BUFFER
00001DFC                          1347                  
00001DFC  103C 000E               1348  PRINT_HEX_RETURN    MOVE.B      #14,D0
00001E00  4E4F                    1349                      TRAP        #15
00001E02  4CDF 7FFF               1350                      MOVEM.L     (SP)+,ALL_REG
00001E06  4E75                    1351                      RTS
00001E08                          1352                 
00001E08  B63C 0000               1353  POPULATE_BUFFER     CMP.B       #0,D3
00001E0C  67EE                    1354                      BEQ         PRINT_HEX_RETURN
00001E0E  183C 000F               1355                      MOVE.B      #$0F,D4
00001E12  C805                    1356                      AND.B       D5,D4
00001E14  E81D                    1357                      ROR.B       #4,D5
00001E16  4EB9 00001E32           1358                      JSR         HEX_TO_ASCII
00001E1C  1304                    1359                      MOVE.B      D4,-(A1)
00001E1E  1805                    1360                      MOVE.B      D5,D4
00001E20  C83C 000F               1361                      AND.B       #$0F,D4
00001E24  4EB9 00001E32           1362                      JSR         HEX_TO_ASCII
00001E2A  1304                    1363                      MOVE.B      D4,-(A1)
00001E2C  E08D                    1364                      LSR.L       #8,D5
00001E2E  5303                    1365                      SUB.B       #1,D3
00001E30  60D6                    1366                      BRA         POPULATE_BUFFER
00001E32                          1367  
00001E32  48E7 E7FE               1368  HEX_TO_ASCII            MOVEM.L     A0-A6/D0-D2/D5-D7,-(SP)
00001E36  B83C 0009               1369                          CMP.B       #9,D4
00001E3A  6F00 000C               1370                          BLE         NUMBER_TO_ASCII
00001E3E  0604 0037               1371                          ADD.B       #$37,D4
00001E42  4CDF 7FE7               1372  HEX_TO_ASCII_RETURN     MOVEM.L   (SP)+,A0-A6/D0-D2/D5-D7
00001E46  4E75                    1373                          RTS
00001E48                          1374                  
00001E48  0604 0030               1375  NUMBER_TO_ASCII     ADD.B   #$30,D4
00001E4C  60F4                    1376                      BRA     HEX_TO_ASCII_RETURN                    
00001E4E                          1377                      
00001E4E  48E7 FFFE               1378  PRINT_REGISTOR      MOVEM.L     ALL_REG,-(SP)       * keeping old value
00001E52  3F3C 0000               1379                      MOVE.W      #00,-(SP)           *for printing purpose
00001E56  343C 00F0               1380                      MOVE.W      #$f0,D2             *manipulating each digit
00001E5A  C441                    1381                      AND.W       D1,D2
00001E5C  E842                    1382                      ASR.W       #4,D2
00001E5E  4EB9 00001E84           1383                      JSR         TO_STRING           * converts to the string ASCII val
00001E64  E142                    1384                      ASL.W       #8,D2
00001E66                          1385                      
00001E66  C27C 000F               1386                      AND.W       #$F,D1              * the last digit
00001E6A  1401                    1387                      MOVE.B      D1,D2               
00001E6C  4EB9 00001E84           1388                      JSR         TO_STRING
00001E72  3F02                    1389                      MOVE.W      D2,-(SP)            * puting on the stack to print
00001E74                          1390                      
00001E74  224F                    1391                      MOVE.L      SP,A1               * printing
00001E76  103C 000E               1392                      MOVE.B      #14,D0
00001E7A  4E4F                    1393                      TRAP        #15
00001E7C  2A1F                    1394                      MOVE.L      (SP)+, D5           * Adjesting the sp
00001E7E                          1395  
00001E7E  4CDF 7FFF               1396  PRINT_REGISTOR_RETURN           MOVEM.L     (SP)+,ALL_REG   *returning the original val
00001E82  4E75                    1397                                  RTS
00001E84                          1398                                  
00001E84  B43C 0009               1399  TO_STRING   CMP.B   #9,D2               * check if digit or leter
00001E88  6E00 0008               1400              BGT     LETTERS     
00001E8C  0602 0030               1401              ADD.B   #$30,D2             * offseting digit
00001E90  4E75                    1402              RTS
00001E92  0602 0037               1403  LETTERS     ADD.B   #$37,D2             * offseting leter
00001E96  4E75                    1404              RTS   
00001E98                          1405  
00001E98                          1406  *________________________________________________________________________________________
00001E98                          1407  
00001E98                          1408  
00001E98                          1409  *________________ PRINT OPEN PARENTHESIS ________________________________________
00001E98                          1410          *PARAMENTER     NO PARAMETER NEEDED
00001E98= 28 00                   1411  OPEN_PAR_TAG        DC.B    '(',0  
00001E9A= 29 00                   1412  CLOSED_PAR_TAG      DC.B    ')',0
00001E9C= 23 00                   1413  HASH_SIGN_TAG       DC.B    '#',0
00001E9E= 24 00                   1414  DOLLAR_TAG          DC.B    '$',0
00001EA0= 2F 00                   1415  FORWARD_SLASH_TAG   DC.B    '/',0      
00001EA2  48E7 FFFE               1416  PRINT_OPEN_PARENTHESIS  MOVEM.L     ALL_REG, -(SP)
00001EA6  43F8 1E98               1417                          LEA         OPEN_PAR_TAG, A1
00001EAA  103C 000E               1418                          MOVE.B      #14,D0
00001EAE  4E4F                    1419                          TRAP        #15
00001EB0  4CDF 7FFF               1420                          MOVEM.L     (SP)+,ALL_REG
00001EB4  4E75                    1421                          RTS
00001EB6                          1422  *_________________________________________________________________________________
00001EB6                          1423  
00001EB6                          1424  *________________ PRINT CLOSED PARENTHESIS ________________________________________
00001EB6                          1425          *PARAMENTER     NO PARAMETER NEEDED
00001EB6                          1426          
00001EB6  48E7 FFFE               1427  PRINT_CLOSED_PARENTHESIS    MOVEM.L     ALL_REG, -(SP)
00001EBA  43F8 1E9A               1428                              LEA         CLOSED_PAR_TAG, A1
00001EBE  103C 000E               1429                              MOVE.B      #14,D0
00001EC2  4E4F                    1430                              TRAP        #15
00001EC4  4CDF 7FFF               1431                              MOVEM.L     (SP)+,ALL_REG
00001EC8  4E75                    1432                              RTS
00001ECA                          1433  *__________________________________________________________________________________
00001ECA                          1434  
00001ECA                          1435  *________________ PRINT PLUS SIGN _________________________________________________
00001ECA                          1436          *PARAMENTER     NO PARAMETER NEEDED
00001ECA= 2B 00                   1437  PLUS_TAG            DC.B    '+',0
00001ECC= 2D 00                   1438  MINUS_TAG           DC.B    '-',0        
00001ECE  48E7 FFFE               1439  PRINT_PLUS      MOVEM.L     ALL_REG, -(SP)
00001ED2  43F8 1ECA               1440                  LEA         PLUS_TAG, A1
00001ED6  103C 000E               1441                  MOVE.B      #14,D0
00001EDA  4E4F                    1442                  TRAP        #15
00001EDC  4CDF 7FFF               1443                  MOVEM.L     (SP)+,ALL_REG
00001EE0  4E75                    1444                  RTS
00001EE2                          1445  *_________________________________________________________________________________
00001EE2                          1446  
00001EE2                          1447  *________________ PRINT MINUS SIGN _______________________________________________
00001EE2                          1448          *PARAMENTER     NO PARAMETER NEEDED
00001EE2                          1449          
00001EE2  48E7 FFFE               1450  PRINT_MINUS         MOVEM.L     ALL_REG, -(SP)
00001EE6  43F8 1ECC               1451                      LEA         MINUS_TAG, A1
00001EEA  103C 000E               1452                      MOVE.B      #14,D0
00001EEE  4E4F                    1453                      TRAP        #15
00001EF0  4CDF 7FFF               1454                      MOVEM.L     (SP)+,ALL_REG
00001EF4  4E75                    1455                      RTS
00001EF6                          1456  *_________________________________________________________________________________
00001EF6                          1457  
00001EF6                          1458  *________________ PRINT COMMA ____________________________________________________
00001EF6                          1459          *PARAMENTER     NO PARAMETER NEEDED
00001EF6= 09 00                   1460  TAB_TAG         DC.B    $9,0
00001EF8= 20 00                   1461  SPACE_TAG       DC.B    ' ',0
00001EFA= 2C 00                   1462  COMMA_TAG       DC.B    ',',0        
00001EFC  48E7 FFFE               1463  PRINT_COMMA         MOVEM.L     ALL_REG,-(SP)
00001F00  43F8 1EFA               1464                      LEA         COMMA_TAG, A1
00001F04  103C 000E               1465                      MOVE.B      #14,D0
00001F08  4E4F                    1466                      TRAP        #15
00001F0A  4CDF 7FFF               1467                      MOVEM.L     (SP)+,ALL_REG
00001F0E  4E75                    1468                      RTS
00001F10                          1469  *_________________________________________________________________________________
00001F10                          1470  
00001F10                          1471  *________________ PRINT TAB ______________________________________________________
00001F10                          1472          *PARAMENTER     NO PARAMETER NEEDED
00001F10                          1473          
00001F10  48E7 FFFE               1474  PRINT_TAB       MOVEM.L     ALL_REG,-(SP)
00001F14  43F8 1EF6               1475                  LEA         TAB_TAG, A1
00001F18  103C 000E               1476                  MOVE.B      #14,D0
00001F1C  4E4F                    1477                  TRAP        #15
00001F1E  4CDF 7FFF               1478                  MOVEM.L     (SP)+,ALL_REG
00001F22  4E75                    1479                  RTS
00001F24                          1480  *_________________________________________________________________________________
00001F24                          1481  
00001F24                          1482  
00001F24                          1483  *_______________    PRINT NEWLINE   ________________________________________________
00001F24                          1484          *PARAMETER NO PARAMETER NEEDED
00001F24= 0D 0A 00                1485  NEWLINE_TAG         DC.B    CR,LF,0        
00001F28  48E7 FFFE               1486  PRINT_NEWLINE       MOVEM.L     ALL_REG,-(SP)
00001F2C  43F8 1F24               1487                      LEA         NEWLINE_TAG, A1
00001F30  103C 000E               1488                      MOVE.B      #14,D0
00001F34  4E4F                    1489                      TRAP        #15
00001F36  4CDF 7FFF               1490                      MOVEM.L     (SP)+,ALL_REG
00001F3A  4E75                    1491                      RTS
00001F3C                          1492  
00001F3C                          1493  *___________________________________________________________________________________
00001F3C                          1494  
00001F3C                          1495  
00001F3C                          1496  *_______________    PRINT HASH SIGN   ________________________________________________
00001F3C                          1497          *PARAMETER NO PARAMETER NEEDED
00001F3C                          1498          
00001F3C  48E7 FFFE               1499  PRINT_HASH_SIGN     MOVEM.L     ALL_REG,-(SP)
00001F40  43F8 1E9C               1500                      LEA         HASH_SIGN_TAG, A1
00001F44  103C 000E               1501                      MOVE.B      #14,D0
00001F48  4E4F                    1502                      TRAP        #15
00001F4A  4CDF 7FFF               1503                      MOVEM.L     (SP)+,ALL_REG
00001F4E  4E75                    1504                      RTS
00001F50                          1505  
00001F50                          1506  *___________________________________________________________________________________
00001F50                          1507  
00001F50                          1508  
00001F50                          1509  
00001F50                          1510  *_______________    PRINT DOLLAR   ________________________________________________
00001F50                          1511          *PARAMETER NO PARAMETER NEEDED
00001F50                          1512          
00001F50  48E7 FFFE               1513  PRINT_DOLLAR        MOVEM.L     ALL_REG,-(SP)
00001F54  43F8 1E9E               1514                      LEA         DOLLAR_TAG, A1
00001F58  103C 000E               1515                      MOVE.B      #14,D0
00001F5C  4E4F                    1516                      TRAP        #15
00001F5E  4CDF 7FFF               1517                      MOVEM.L     (SP)+,ALL_REG
00001F62  4E75                    1518                      RTS
00001F64                          1519  
00001F64                          1520  *___________________________________________________________________________________
00001F64                          1521  
00001F64                          1522  
00001F64                          1523  
00001F64                          1524  *_______________    PRINT FORWARD SLASH   ________________________________________________
00001F64                          1525          *PARAMETER NO PARAMETER NEEDED
00001F64                          1526          
00001F64  48E7 FFFE               1527  PRINT_FORWARD_SLASH     MOVEM.L     ALL_REG,-(SP)
00001F68  43F8 1EA0               1528                          LEA         FORWARD_SLASH_TAG, A1
00001F6C  103C 000E               1529                          MOVE.B      #14,D0
00001F70  4E4F                    1530                          TRAP        #15
00001F72  4CDF 7FFF               1531                          MOVEM.L     (SP)+,ALL_REG
00001F76  4E75                    1532                          RTS
00001F78                          1533  
00001F78                          1534  
00001F78                          1535     
00001F78                          1536  *********************************************************************
00001F78                          1537  *Subroutine: OUTPUT
00001F78                          1538  *What it does: Outputs parts of opword, moves to new screen if needed
00001F78                          1539  *Registers: Uses register A1, D0,
00001F78                          1540  *A1: Used to store messages and single char
00001F78                          1541  *Paramemeters: A1, A2
00001F78                          1542  *A1: Stores what should be used
00001F78                          1543  *********************************************************************  
00001F78                          1544  
00001F78                          1545       OUTPUT:
00001F78                          1546       
00001F78  0C39 0001 0000235B      1547       CMP.B  #1,(OutputType)
00001F80  6700 0026               1548       BEQ    outputOpcode
00001F84  0C39 0002 0000235B      1549       CMP.B  #2,(OutputType)
00001F8C  6700 0066               1550       BEQ    OutputSize
00001F90  0C39 0003 0000235B      1551       CMP.B  #3,(OutputType)
00001F98  6700 0062               1552       BEQ    OutputData
00001F9C  0C39 0004 0000235B      1553       CMP.B  #4,(OutputType)
00001FA4  6700 00AC               1554       BEQ    OutputAddress
00001FA8                          1555       
00001FA8                          1556  outputOpcode    
00001FA8  0C39 001E 0000235A      1557       CMP.B  #30, (LineCounter)      Console holds 32 lines total, 30 used for dissassembly data
00001FB0  6C00 0010               1558       BGE    outputOpcodeNewScreen
00001FB4                          1559       
00001FB4  103C 000E               1560       MOVE.B #14,D0
00001FB8  4E4F                    1561       TRAP   #15
00001FBA                          1562       
00001FBA  5239 0000235A           1563       ADD.B  #1,(LineCounter)
00001FC0                          1564       
00001FC0  4E75                    1565       RTS
00001FC2                          1566       
00001FC2                          1567       
00001FC2                          1568  outputOpcodeNewScreen
00001FC2  2F09                    1569       MOVE.L A1,-(SP)                Storing last message to be used later
00001FC4                          1570       
00001FC4  43F9 00002330           1571       LEA    OUTPUTNEWSCREEN,A1         
00001FCA  103C 000E               1572       MOVE.B #14,D0
00001FCE  4E4F                    1573       TRAP   #15
00001FD0                          1574       
00001FD0  43F9 00008008           1575       LEA    userInputStored,A1         Pauses program to show screen full of data
00001FD6  103C 0002               1576       MOVE.B #2,D0
00001FDA  4E4F                    1577       TRAP   #15
00001FDC                          1578       
00001FDC  13FC 0000 0000235A      1579       MOVE.B #0,(LineCounter)        Sets LineCounter to 0 to reset screen
00001FE4                          1580       
00001FE4  225F                    1581       MOVE.L (SP)+,A1                Retriving message to be used
00001FE6                          1582       
00001FE6  103C 000E               1583       MOVE.B #14,D0                  Outputting decoded message
00001FEA  4E4F                    1584       TRAP   #15
00001FEC                          1585       
00001FEC  5239 0000235A           1586       ADD.B  #1,(LineCounter)        Add to line counter for new screen
00001FF2                          1587       
00001FF2  4E75                    1588       RTS
00001FF4                          1589       
00001FF4                          1590  outputSize
00001FF4  103C 000E               1591      MOVE.B  #14,D0
00001FF8  4E4F                    1592      TRAP    #15
00001FFA  4E75                    1593      RTS
00001FFC                          1594  outputData
00001FFC  267C 00000800           1595      MOVE.L   #$800,A3
00002002  3692                    1596      MOVE.W  (A2),(A3)
00002004  2F06                    1597      MOVE.L  D6,-(SP)
00002006  103C 0000               1598      MOVE.B  #0,D0
0000200A  43F9 00009005           1599      LEA     addressOutput,A1
00002010                          1600  
00002010                          1601  outputDataLoop
00002010                          1602  *check if loop has run 4 times
00002010  B03C 0002               1603      CMP.B   #2,D0
00002014  6700 001C               1604      BEQ     outputDataLoopEnd
00002018                          1605      *Grab byte from address, dont increment
00002018  1C13                    1606      MOVE.B  (A3),D6
0000201A                          1607      *LSR to isolate left bit
0000201A  E80E                    1608      LSR.B   #4,D6
0000201C                          1609      *Call converthtoa
0000201C  6100 008A               1610      BSR     CONVERTHTOA
00002020  12C6                    1611      MOVE.B  D6,(A1)+   
00002022                          1612      *Grab bye from address, increment
00002022  1C1B                    1613      MOVE.B  (A3)+,D6
00002024                          1614      *AND Mask second digit
00002024  CC3C 000F               1615      AND.B   #$0F,D6
00002028  6100 007E               1616      BSR     CONVERTHTOA
0000202C  12C6                    1617      MOVE.B  D6,(A1)+
0000202E  5200                    1618      ADD.B   #1,D0
00002030  60DE                    1619      BRA     outputDataLoop
00002032                          1620      
00002032                          1621  outputDataLoopEnd
00002032  12BC 0000               1622      MOVE.B  #$00,(A1)
00002036  2C1F                    1623      MOVE.L  (SP)+,D6
00002038  43F9 00009005           1624      LEA     addressOutput,A1
0000203E  103C 000E               1625      MOVE.B  #14,D0
00002042  4E4F                    1626      TRAP    #15
00002044                          1627      
00002044  43F9 00002353           1628      LEA     NEWLINE,A1
0000204A  103C 000E               1629      MOVE.B  #14,D0
0000204E  4E4F                    1630      TRAP    #15
00002050                          1631  
00002050  4E75                    1632      RTS
00002052                          1633   
00002052                          1634      
00002052                          1635  outputAddress
00002052  267C 00000800           1636      MOVE.L  #$800,A3
00002058  268A                    1637      MOVE.L  A2,(A3)
0000205A  2F06                    1638      MOVE.L  D6,-(SP)
0000205C  103C 0000               1639      MOVE.B  #0,D0
00002060  43F9 00009005           1640      LEA     addressOutput,A1
00002066                          1641  outputAddressLoop
00002066                          1642      *check if loop has run 4 times
00002066  B03C 0004               1643      CMP.B   #4,D0
0000206A  6700 001C               1644      BEQ     outputAddressLoopEnd
0000206E                          1645      *Grab byte from address, dont increment
0000206E  1C13                    1646      MOVE.B  (A3),D6
00002070                          1647      *LSR to isolate left bit
00002070  E80E                    1648      LSR.B   #4,D6
00002072                          1649      *Call converthtoa
00002072  6100 0034               1650      BSR     CONVERTHTOA
00002076  12C6                    1651      MOVE.B  D6,(A1)+   
00002078                          1652      *Grab bye from address, increment
00002078  1C1B                    1653      MOVE.B  (A3)+,D6
0000207A                          1654      *AND Mask second digit
0000207A  CC3C 000F               1655      AND.B   #$0F,D6
0000207E  6100 0028               1656      BSR     CONVERTHTOA
00002082  12C6                    1657      MOVE.B  D6,(A1)+
00002084  5200                    1658      ADD.B   #1,D0
00002086  60DE                    1659      BRA     outputAddressLoop
00002088                          1660      
00002088                          1661      
00002088                          1662  outputAddressLoopEnd
00002088  12BC 0000               1663      MOVE.B  #$00,(A1)
0000208C  2C1F                    1664      MOVE.L  (SP)+,D6
0000208E  43F9 00009005           1665      LEA     addressOutput,A1
00002094                          1666      
00002094  103C 000E               1667      MOVE.B  #14,D0
00002098  4E4F                    1668      TRAP    #15
0000209A                          1669      
0000209A  43F9 00002356           1670      LEA     spaces,A1
000020A0  103C 000E               1671      MOVE.B  #14,D0
000020A4  4E4F                    1672      TRAP    #15
000020A6                          1673  
000020A6                          1674  
000020A6  4E75                    1675      RTS
000020A8                          1676  
000020A8                          1677  *********************************************************************
000020A8                          1678  *Subroutine: CONVERTHTOA
000020A8                          1679  *What it does: Converts HEX to ASCII
000020A8                          1680  *Registers: Uses register D6,D0
000020A8                          1681  *D6: Stores hex character to be converted
000020A8                          1682  *Paramemeters: D6
000020A8                          1683  *D6: Stores hex characcter to be converted
000020A8                          1684  *********************************************************************
000020A8                          1685      CONVERTHTOA:
000020A8                          1686      
000020A8  BC3C 0009               1687      CMP.B   #9,D6
000020AC  6F00 0006               1688      BLE     zerotonine
000020B0  6000 000A               1689      BRA     AtoF
000020B4                          1690      
000020B4                          1691  zerotonine    
000020B4  0686 00000030           1692      ADD.L   #$30,D6
000020BA  4E75                    1693      RTS
000020BC                          1694  AtoF
000020BC  0686 00000037           1695      ADD.L   #$37,D6
000020C2  4E75                    1696      RTS
000020C4                          1697      
000020C4                          1698  END_SIMULATION:
000020C4                          1699          
000020C4  103C 0009               1700      MOVE.B  #9,D0
000020C8  4E4F                    1701      TRAP    #15
000020CA                          1702  
000020CA  FFFF FFFF               1703      SIMHALT             ; halt simulator
000020CE                          1704  
000020CE                          1705  * Put variables and constants here
000020CE= 57 65 6C 63 6F 6D ...   1706  STARTMESSAGE    DC.B    'Welcome to the CSS 422 dissasembler!',CR,LF
000020F4= 53 6F 6D 65 20 71 ...   1707                  DC.B    'Some quick rules:',CR,LF
00002107= 31 29 20 4F 6E 6C ...   1708                  DC.B    '1) Only the last 6 characters will be saved as the address',CR,LF
00002143= 32 29 20 54 68 65 ...   1709                  DC.B    '2) The input only accepts hexadecimal input, both in upper and lower case',CR,LF
0000218E= 33 29 20 41 6E 79 ...   1710                  DC.B    '3) Any part of the input that is not within the hexadecimal range ',CR,LF
000021D2= 20 20 20 77 69 6C ...   1711                  DC.B    '   will be rejected',CR,LF
000021E7= 34 29 20 54 68 65 ...   1712                  DC.B    '4) The first input must be smaller than the second, otherwise it ',CR,LF
0000222A= 20 20 20 77 69 6C ...   1713                  DC.B    '   will be rejected',CR,LF,0      
00002240= 50 6C 65 61 73 65 ...   1714  INPUT1MESSAGE   DC.B    'Please input the lower address edge',CR,LF,0
00002266= 50 6C 65 61 73 65 ...   1715  INPUT2MESSAGE   DC.B    'Please input the upper address edge',CR,LF,0
0000228C                          1716  
0000228C= 0D 0A 54 68 69 73 ...   1717  INPUTERRORBADCHAR   DC.B    CR,LF,'This value is not valid',CR,LF,CR,LF,0
000022AA= 0D 0A 49 6E 70 75 ...   1718  INPUTERROR2SMALLER  DC.B    CR,LF,'Input 2 is smaller than input 1. Input a larger value',CR,LF,CR,LF,0
000022E6                          1719  
000022E6= 54 6F 20 72 65 70 ...   1720  INPUTREPEAT     DC.B    'To repeat the program, press enter. Otherwise, press any button to quit',CR,LF,0
00002330                          1721  
00002330= 50 6C 65 61 73 65 ...   1722  OUTPUTNEWSCREEN     DC.B    'Please press enter for more code',CR,LF,0
00002353                          1723  
00002353= 0D 0A 00                1724  NEWLINE     DC.B    CR,LF,0
00002356= 20 20 00                1725  SPACES      DC.B    '  ',0
00002359                          1726  
00002359= 01                      1727  InputQuality    DC.B    1       Set to 1 for default good
0000235A= 00                      1728  LineCounter     DC.B    0      Counts the number of lines used per screen (max of 31)
0000235B= 00                      1729  OutputType      DC.B    0      To track what type is being output
0000235C= 00                      1730  RepeatFlag      DC.B    0
0000235D                          1731  
0000235D= 4E 4F 50 0D 0A 00       1732  nopout  DC.B    'NOP',CR,LF,0
00002363= 4D 4F 56 45 00          1733  moveout  DC.B    'MOVE',0
00002368= 4D 4F 56 45 41 00       1734  moveaout DC.B      'MOVEA',0
0000236E= 4D 4F 56 45 51 00       1735  moveqout DC.B   'MOVEQ',0
00002374= 4D 4F 56 45 4D 00       1736  movemout DC.B   'MOVEM',0
0000237A                          1737  
0000237A= 53 55 42 00             1738  subout    DC.B  'SUB',0
0000237E= 41 44 44 00             1739  addout    DC.B 'ADD',0
00002382= 41 44 44 41 00          1740  addaout    DC.B 'ADDA',0
00002387= 41 44 44 51 00          1741  addqout    DC.B 'ADDQ',0
0000238C                          1742  
0000238C= 4C 45 41 00             1743  leaout    DC.B  'LEA',0
00002390                          1744  
00002390= 4E 4F 54 00             1745  notout    DC.B  'NOT',0
00002394= 4F 52 00                1746  orout DC.B     'OR',0
00002397= 41 4E 44 00             1747  andout DC.B     'AND',0
0000239B                          1748  
0000239B                          1749  
0000239B= 4C 53 4C 00             1750  lslout    DC.B  'LSL',0
0000239F= 4C 53 52 00             1751  lsrout    DC.B  'LSR',0
000023A3= 41 53 4C 00             1752  aslout    DC.B  'ASL',0
000023A7= 41 53 52 00             1753  asrout    DC.B  'ASR',0
000023AB                          1754  
000023AB= 52 4F 4C 00             1755  rolout    DC.B  'ROL',0
000023AF= 52 4F 52 00             1756  rorout    DC.B  'ROR',0
000023B3                          1757  
000023B3= 42 47 54 00             1758  bgtout DC.B     'BGT',0
000023B7= 42 4C 45 00             1759  bleout DC.B     'BLE',0
000023BB= 42 45 51 00             1760  beqout DC.B     'BEQ',0
000023BF                          1761  
000023BF= 4A 53 52 00             1762  jsrout DC.B     'JSR',0
000023C3= 52 54 53 0D 0A 00       1763  rtsout DC.B     'RTS',CR,LF,0
000023C9= 42 52 41 00             1764  braout DC.B     'BRA',0
000023CD                          1765  
000023CD= 44 41 54 41 20 20 ...   1766  dataout DC.B    'DATA   ',0
000023D5                          1767  
000023D5                          1768  
000023D5                          1769  
000023D5= 2E 42 20 20 20 20 00    1770  byteout  DC.B    '.B    ',0
000023DC= 2E 57 20 20 20 20 00    1771  wordout  DC.B    '.W    ',0
000023E3= 2E 4C 20 20 20 20 00    1772  longout  DC.B    '.L    ',0
000023EA= 20 20 20 20 20 20 ...   1773  nosizeout DC.B   '       ',0
000023F2                          1774  
000023F2= 0D 0A 00                1775  empty    DC.B    '',CR,LF,0
000023F5                          1776  
000023F5  =0000000D               1777  CR  EQU $0D
000023F5  =0000000A               1778  LF  EQU $0A
000023F5                          1779  
000023F5                          1780  
000023F5                          1781      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADD                 149A
ADDA                14DC
ADDAOUT             2382
ADDOUT              237E
ADDQ                1458
ADDQOUT             2387
ADDQ_EA             1B7E
ADDRESSOUTPUT       9005
ALL_REG             7FFF
AND                 179C
ANDOUT              2397
ASL                 162C
ASLOUT              23A3
ASR                 166E
ASROUT              23A7
ATOF                20BC
ATOH                19E4
B                   1314
BCC                 17DE
BEQ                 1848
BEQOUT              23BB
BGT                 1804
BGTOUT              23B3
BITS0TO5_MASK       3F
BITS7TO8_MASK       C0
BITS9TO11_MASK      E00
BLE                 1826
BLEOUT              23B7
BRA                 186A
BRAOUT              23C9
BYTE                12D0
BYTEOUT             23D5
CHECK_EA_AB_L       1D64
CHECK_EA_AB_W       1D44
CHECK_EA_AR         1CAC
CHECK_EA_IMM        1D82
CHECK_EA_INDIRECT   1CC6
CHECK_EA_POST       1CEC
CHECK_EA_PRE        1D18
CHECK_VALID_EA      1C40
CLOSED_PAR_TAG      1E9A
COMMA_TAG           1EFA
CONVERTATOH         19E4
CONVERTHTOA         20A8
CR                  D
DATA                188C
DATAOUT             23CD
DOLLAR_TAG          1E9E
EA1_END             1AC2
EA1_MODE_ONE        1AB6
EA1_MODE_ZERO       1ABE
EA2_END             1B06
EA2_IMMEDIATE       1AFE
EA2_REGISTER        1AF6
EA_GROUP1           1A96
EA_GROUP2           1AE0
EA_GROUP3           1B26
EA_GROUP4           1B42
EMPTY               23F2
ENDSIZE             1312
END_SIMULATION      20C4
FINISH              1A38
FIRSTINPUT          1902
FORMAT_IMMEDIATE_DATA  1A44
FORWARD_SLASH_TAG   1EA0
HASH_SIGN_TAG       1E9C
HERE                1020
HEX_TO_ASCII        1E32
HEX_TO_ASCII_RETURN  1E42
IMMEDIATE0          1A54
IMMEDIATE_END       1A56
INPUT1              8000
INPUT1MESSAGE       2240
INPUT2              8004
INPUT2MESSAGE       2266
INPUTERROR          1A3A
INPUTERROR2SMALLER  22AA
INPUTERRORBADCHAR   228C
INPUTQUALITY        2359
INPUTREPEAT         22E6
INPUT_BUFFER        1DD6
INVALID_EA          1C7A
IPUT_BUFFER_EX      1DCE
JSR                 1540
JSROUT              23BF
L                   1314
LEA                 1734
LEAOUT              238C
LETSGO              1058
LETTERS             1E92
LF                  A
LINECOUNTER         235A
LONG                12FC
LONGOUT             23E3
LOWERCASE           1A20
LSL                 15A8
LSLOUT              239B
LSR                 15EA
LSROUT              239F
MEMORY_TO_REGISTER  1BD8
MINUS_TAG           1ECC
MODE_010            1C06
MODE_01_0           1C38
MOVE                1334
MOVEA               1380
MOVEAOUT            2368
MOVEM               13DC
MOVEMOUT            2374
MOVEM_EA            1BCE
MOVEOUT             2363
MOVEQ               13B6
MOVEQOUT            236E
MOVEQ_EA            1BA6
MOVE_MOVEA_EA       1A58
NEWLINE             2353
NEWLINE_TAG         1F24
NOP                 1314
NOPOUT              235D
NOSIZEOUT           23EA
NOT                 1566
NOTOUT              2390
NUMBER_TO_ASCII     1E48
OPCODE              11B2
OPEN_PAR_TAG        1E98
OR                  175A
OROUT               2394
OUTPUT              1F78
OUTPUTADDRESS       2052
OUTPUTADDRESSLOOP   2066
OUTPUTADDRESSLOOPEND  2088
OUTPUTDATA          1FFC
OUTPUTDATALOOP      2010
OUTPUTDATALOOPEND   2032
OUTPUTNEWSCREEN     2330
OUTPUTOPCODE        1FA8
OUTPUTOPCODENEWSCREEN  1FC2
OUTPUTSIZE          1FF4
OUTPUTTYPE          235B
PLUS_TAG            1ECA
POPULATE_BUFFER     1E08
PRINT_BUFFER        1DC4
PRINT_CLOSED_PARENTHESIS  1EB6
PRINT_COMMA         1EFC
PRINT_DOLLAR        1F50
PRINT_EA            1C84
PRINT_EA_RETURN     1DBE
PRINT_FORWARD_SLASH  1F64
PRINT_HASH_SIGN     1F3C
PRINT_HEX           1DE6
PRINT_HEX_RETURN    1DFC
PRINT_MINUS         1EE2
PRINT_NEWLINE       1F28
PRINT_OPEN_PARENTHESIS  1EA2
PRINT_PLUS          1ECE
PRINT_REGISTOR      1E4E
PRINT_REGISTOR_RETURN  1E7E
PRINT_TAB           1F10
READ_WORD_IMM       1DA6
REGISTER_TO_MEMORY  1C14
REPEATFLAG          235C
RETURN              12B6
ROL                 16B0
ROLOUT              23AB
ROR                 16F2
ROROUT              23AF
RTS                 151A
RTSOUT              23C3
SECONDINPUT         1966
SIZE                12B8
SPACES              2356
SPACE_TAG           1EF8
START               1000
STARTMESSAGE        20CE
SUB                 1416
SUBOUT              237A
TAB_TAG             1EF6
THERE               1186
THROWINPUT1CHARERROR  1948
THROWINPUT2CHARERROR  19B4
THROWINPUT2LOWERERROR  19D0
TO_STRING           1E84
UPPERCASE           1A08
USERINPUT           18BA
USERINPUTREPEAT     1188
USERINPUTSTART      1008
USERINPUTSTORED     8008
VALID_EA_PC         1C62
W                   1314
WELCOMEEXPLANATION  18E8
WORD                12E6
WORDOUT             23DC
WRONG_INSTRUCTION   1BFC
ZEROTONINE          20B4
